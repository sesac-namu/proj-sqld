id,title,content_img,content_text,choices_1,choices_2,choices_3,choices_4,answer
1,다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?,,,SELECT * FROM TAB1 WHERE COL1 NOT NULL;,SELECT * FROM TAB1 WHERE COL1 != NULL;,SELECT * FROM TAB1 WHERE COL1 <> NULL;,SELECT * FROM TAB1 WHERE COL1 IS NOT NULL;,"정답: 4
해설: NULL은 일반적인 비교연산을 수행할 수 없고 IS NULL, IS NOT NULL로 비교해야 한다."
2,다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?,,가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다. 나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다. 다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다. 라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.,"가,나,다,라","나,다,라","가,나,라","가,나,다","정답: 1
해설: None"
3,"테이블 A에 대해 아래와 같은 SQL을 수행하였을 때 테이블 A의 ID ’001’에 해당하는 최종 VAL의 값이 ORACLE에서는 200, SQL Server에서는 100이 되었다. 다음 설명 중 가장 부적절한 것은? (단, AUTO COMMIT은 FALSE로 설정되어 있다)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j61-1.png,,"SQL Server에서는 ROLLBACK 실행으로 인하여 UPDATE가 취소되 었으며, 최종적으로 B 테이블은 생성되지 않았다.","ORACLE에서는 CREATE TABLE 문장 수행에 의해 VAL 값은 200이 되었지만, ROLLBACK 실행으로 인하여 최종적으로 B 테이블은 생성 되지 않았다.",SQL Server에서는 ROLLBACK 문장에 의해 UPDATE가 취소되어 VAL 값은 100이 되었다.,"ORACLE에서는 CREATE TABLE 문장을 수행한 후, 묵시적으로 COMMIT이 수행 되어 VAL 값은 200이 되었다.","정답: 2
해설: None"
4,ERD 작성 순서로 올바른 것을 고르시오.,,가) 엔터티를 그린다. 나) 엔터티를 적절하게 배치한다. 다) 엔터티 간에 관계를 설정한다. 라) 관계명을 기술한다. 마) 관계의 참여도를 기술한다. 바) 관계의 필수 여부를 기술한다.,가->나->다->마->바->라,가->나->라->다->마->바,나->가->다->라->마->바,가->나->다->라->마->바,"정답: 4
해설: None"
5,속성에 대한 설명으로 가장 적절하지 않은 것은?,,,속성은 정해진 주식별자에 함수적 종속성을 가져야 한다.,하나의 인스턴스에서 각각의 속성은 하나 이상의 속성값을 가질 수 있다.,하나의 엔터티는 두 개 이상의 속성을 갖는다.,업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소 데이터 단위를 나타낸다.,"정답: 2
해설: 하나의 인스턴스는 속성마다 반드시 하나의 속성값을 가져야한다.(속성의 원자성)"
6,다음은 ABC 증권회사의 데이터베이스 모델링이다. 모델링은 고객과 계좌 간의 관계를 표현한 것이다. 보기 중에서 그 설명이 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j446-1.png,,한 명의 고객에게 하나의 고객등급만 부여된다.,고객마스터와 계좌마스터의 관계는 식별 관계이다.,계좌번호는 전체 고객마다 유일한 번호가 부여된다.,계좌를 개설하지 않은 고객은 ABC증권회사의 고객이 될 수가 없다.,"정답: 3
해설: 계좌마스터의 기본키가 계좌번호와 고객번호이므로 전체 고객에게 유일한 번호가 할당되는 것은 아니다. 즉, 고객별 유일한 계좌번호가 된다."
7,다음 중 식별자로 가장 부적절한 것은?,,,,,,,"정답: 2
해설: None"
8,다음이 설명하는 모델링의 특징으로 가장 적절한 것은?,,누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것을 의미한다.,그룹화,단순화,추상화,명확화,"정답: 4
해설: 모델링의 특징은 단순화, 추상화, 명확화가 있다. 이 중 누구나 이해하기 쉽게 대상에 대한 애매모호함을 제거하고 정확하게 기술하는 것은 명확화에 해당된다."
9,관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?,,,행위 관계는 엔터티 간의 어떤 행위가 있는 것을 의미한다.,관계를 맺는 엔터티를 다시 연결하는 과정을 조인이라고 한다.,정규화를 거쳐 분리된 엔터티는 서로 관계를 맺지 않아도 된다.,관계란 엔터티의 인스턴스 사이의 논리적인 연관성을 의미한다.,"정답: 3
해설: 정규화에 의해 분리된 두 테이블은 서로 관계를 맺는다."
10,데이터 모델링에 대한 설명 중 알맞은 것은?,,,논리 모델링이 외래키는 물리 모델에서 반드시 구현되지는 않는다.,물리 모델링 -> 논리 모델링 -> 개념 모델링 단계로 갈수록 구체적이다.,실제로 데이터베이스를 구축할 때 참고되는 모델은 개념적 데이터 모델링이다.,"데이터 모델링의 3가지 요소는 Process, Attributes, Relationships이다.","정답: 1
해설: ① 논리 모델링의 외래키는 물리 모델에서 반드시 구현되지 않는 선택사항이다. ② 개념 모델링에서 물리 모델링으로 가면서 더 구체적이며 개념 모델링이 가장 추상적이다. ③ 실제 데이터베이스 구축 시 참고되는 모델은 물리적 데이터 모델링이다. ④ 데이터 모델링의 3요소는 Things, Attributes, Relationships 이다."
11,부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은?,,,"SELECT ENAME, SAL, DEPTNO, ROUND(PERCENT_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL) * 100, 2) AS SAL_RATIO FROM EMP E1 ORDER BY DEPTNO, SAL DESC;","SELECT E1.ENAME, E1.SAL, E1.DEPTNO, ROUND(E1.SAL/I.SUM_SAL * 100, 2) AS SAL_RATIO FROM EMP E1, (SELECT DEPTNO, SUM(SAL) AS SUM_SAL FROM EMP GROUP BY DEPTNO) I WHERE E1.DEPTNO = I.DEPTNO ORDER BY DEPTNO, SAL DESC;","SELECT ENAME, SAL, DEPTNO, ROUND(RATIO_TO_REPORT(SAL) OVER(PARTITION BY DEPTNO) * 100, 2) AS SAL_RATIO FROM EMP E1 ORDER BY DEPTNO, SAL DESC;","SELECT ENAME, SAL, DEPTNO, ROUND(SAL/(SELECT SUM(SAL) FROM EMP E2 WHERE E1.DEPTNO = E2.DEPTNO) * 100, 2) AS SAL_RATIO FROM EMP E1 ORDER BY DEPTNO, SAL DESC;","정답: 1
해설: PERCENT_RANK는 특정 값의 상대적 비율이 아닌, 그 값의 위치를 백분율로 리턴하는 함수이기 때문에 급여의 비율을 출력하기 위한 표현으로 적절하지 않다."
12,트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?,,,하나의 트랜잭션으로 구성된 작업은 부분 COMMIT이 불가하다.,순차적으로 수행되는 작업 A와 B가 하나의 트랜잭션일 경우 A만 실행되고 시스템 장애가 발생했다면 A를 undo해야 한다.,원자성이란 하나의 트랜잭션의 작업이 모두 성공하거나 모두 취소되어야 하는 특징을 말한다.,트랜잭션에 의한 관계는 선택적인 관계 형태를 가진다.,"정답: 4
해설: 두 엔터티의 관계가 서로 필수적일 때 하나의 트랜잭션을 형성할 수 있다. 두 엔터티가 서로 독립적으로 수행이 가능하다면 선택적 관계로 정의한다."
13,다음 결과를 출력하는 SQL 문으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j789-1.png,,"SELECT COUNT(DECODE(COL2, 10, 'O', 'X')) AS CNT10, COUNT(DECODE(COL2, 20, 'O', 'X')) AS CNT20 FROM TAB1;","SELECT SUM(DECODE(COL2, 10, 'O', 'X')) AS CNT10, SUM(DECODE(COL2, 20, 'O', 'X')) AS CNT20 FROM TAB1;","SELECT COUNT(DECODE(COL2, 10, 1, 0)) AS CNT10, COUNT(DECODE(COL2, 20, 1, 0)) AS CNT20 FROM TAB1;","SELECT SUM(DECODE(COL2, 10, 1, 0)) AS CNT10, SUM(DECODE(COL2, 20, 1, 0)) AS CNT20 FROM TAB1;","정답: 4
해설: 특정 대상의 수를 세려면 COUNT는 세고자 하는 값이 어떤 값이든 존재(1이나 ‘X’ 등)하면 되고, 반대로 세지 않을 값은 반드시 NULL이어야 한다. SUM은 세고자 하는 값이 1이고, 나머지는 NULL이거나 0이면 된다. 따라서 해당 조 건에 만족하는 문장은 1번이다."
14,다음 주어진 테이블에서 아래의 SQL문을 수행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j539-1.png,SELECT SUM(COL1+COL2+COL3+COL4) FROM test23; SELECT SUM(COL1) + SUM(COL2) + SUM(COL3) + SUM(COL4) FROM tset23;,"Null, Null","50, 240","Null, 240","50, Null","정답: 2
해설: 첫 번째 SQL문의 첫 번째 행인(10,10,10,20)은 NULL 값이 없으므로 합계 50이 조회된다. 그리고 두 번째 SQL문에서는 240의 합계가 조회된다. 즉, SUM 집계함수에서 NULL은 자동으로 제외한다."
15,다음 중 아래와 같은 상황에서 사용할 수 있는 SQL 명령어는?,,"우리가 관리하는 데이터베이스의 ""매출"" 테이블이 너무나 많은 디스크 용량을 차지하여 ""매출” 테이블에서 필요한 데이터만을 추출하여 별도의 테이블로 옮겨 놓았다. 이후 ""매출"" 원본 테이블의 데이터를 모두 삭제함과 동시에, 디스크 사용량도 초기화 하고자 한다.(단, ""매출"" 테이블의 스키마 정의는 유지한다.)",DELETE TABLE FROM 매출;,DROP TABLE 매출;,DELETE FROM 매출;,TRUNCATE TABLE 매출;,"정답: 4
해설: None"
16,"다음 중 아래 TBL1, TBL2 테이블에 대해 SQL을 수행한 결과인 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j104-1.png,,,,,,"정답: 4
해설: 집합 연산자는 SQL에서 위에 정의된 연산자가 먼저 수행된다. 그러므로 UNION이 나중에 수행되므로 결과적으로 중복 데이터가 모두 제거되어 ④과 같은 결과가 도출된다. 만일 UNION과 UNION ALL의 순서를 바꾼다면 ③과 같은 결과가 도출된다"
17,아래는 어느 회사의 생산설비를 위한 데이터 모델의 일부에 대한 설명으로 가장 적절한 것을 2개 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j91-1.png,,"SELECT C.컨텐츠 ID, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A.고객ID = #custId# AND A.고객ID = B.고객ID) INNER JOIN 컨텐츠 C ON (B.컨텐츠 D = C.컨텐츠ID) WHERE B.추천대상일자 = TO_CHAR(SYSDATE, ’YYYY.MM.DD') AND NOT EXISTS (SELECT X.컨텐츠ID FROM 비선호컨텐츠 X WHERE X. 고객ID = B. 고객ID AND X. 컨텐츠ID = B. 컨텐츠ID;","SELECT C.컨텐츠 D, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A.고객ID = B.고객ID) INNER JOIN 컨텐츠 C ON (B.컨텐츠D = C.컨텐츠ID) LEFT OUTER JOIN 비선호컨텐츠 D ON (B.고객ID = D.고객ID AND B.컨텐츠ID = D.컨텐츠ID) WHERE A. 고객ID = #custId# AND B.추천대상일자 = TO_CHAR(SYSDATE, ’YYYY.MM.DD') AND D.컨텐츠ID IS NULL;","SELECT C.컨텐츠ID, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A.고객lD = #custId# AND A.고객ID = B.고객ID) INNER JOIN 컨텐츠 C ON (B.컨텐츠ID = C.컨텐츠ID) RIGHT OUTER JOIN 비선호컨텐츠 D ON (B.고객ID = D.고객ID AND B.컨텐츠ID = D.컨텐츠ID) WHERE B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD') AND B.컨텐츠ID IS NOT NULL；","SELECT C.컨텐츠ID, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A. 고객ID = B. 고객ID) INNER JOIN 컨텐츠 C ON (B. 컨텐츠 D = C. 컨텐츠 D) WHERE A. 고객ID = #custld# AND B. 추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD') AND NOT EXISTS (SELECT X.컨텐츠ID FROM 비선호컨텐츠 X WHERE X.고객ID = B.고객ID);","정답: 3,4
해설: None"
18,"다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)",,"SELECT SYSDATE, TO_DATE(SYSDATE,'YYYY') FROM DUAL;",에러가 발생한다.,22 - 04 - 30 00 : 00 : 00 2022,2022/04/30 00 : 00 : 00 2022,2022 - 04 - 30 00 : 00 : 00 2022,"정답: 1
해설: SYSDATE는 Oracle에서 오늘의 날짜와 시간을 가지고 있는 Date 타입이다.따라서 Date 타입을 다시 TO_DATE로 형 변환을 하면 동일 타입을 변환하기 때문에 오류가 발생한다. 즉 이러한 경우는 TO_CHAR를 사용해서 문자형 타입으로 변환해야 한다."
19,다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?,,,오라클의 계층형 질의문에서 PRIOR 키워드는 CONNECT BY 절에만 사용할 수 있으며 'prior 자식 = 부모' 형태로 사용하면 순방향 전개로 수행 된다.,오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용된다.,SQL Server에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다.,SQL Server에서의 게층형 질의문은 CTE(Common Table Expression)를 재귀 호출함으로써 계층 구조를 전개한다.,"정답: 1
해설: 오라클 계층형 질의문에서 PRIOR 키워드 SELECT, WHERE 절에서도 사용할 수 있다."
20,SELECT문의 처리 순서로 올바른 것은?,,"SELECT deptno,sum(sal) FROM dept WHERE deptno > 10 GROUP BY deptno ORDER BY deptno;","ORDER BY, SELECT, WHERE, GROUP BY, FROM","SELECT, FROM, WHERE, GROUP BY, ORDER BY","FROM, WHERE, GROUP BY, SELECT, ORDER BY","WHERE, GROUP BY, ORDER BY, FROM, SELECT","정답: 3
해설: None"
21,다음은 NULL 값에 대한 설명이다. 올바른 것은?,,,NULL 값은 아직 알려지지 않은 미지의 값이다.,ORACLE에서 NULL은 TRUE 혹은 FALSE의 의미이다.,MS-SQL에서 NULL 값은 0이다.,데이터베이스의 NULL 값의 의미는 DBMS 종류별로 다르게 해석한다.,"정답: 1
해설: NULL 값은 아직 알려지지 않은 미지의 값으로 0 혹은 TRUE, FALSE와는 다른 것이다."
22,다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?,,데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.,외래키,후보키,수퍼키,인조키,"정답: 2
해설: 후보키는 유일성과 최소성을 만족하는 키이다."
23,트랜잭션이 가지는 특징에 해당되지 않는 것은?,,,통합성,고립성,일관성,원자성,"정답: 1
해설: 트랜잭션이 가지는 특징은 원지성,일관성,고립성,지속성 이다."
24,아래 SQL에서 출력되는 ROWS의 개수를 구하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j401-1.png,"SELECT DNAME, JOB, COUNT(*) ""Total EMP"", SUM(SAL) ""Total Sal"" FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY CUBE(DNAME,JOB);",20건,18건,14건,10건,"정답: 2
해설: 두 개의 테이블을 조인하면 14개의 행이 나오게 된다. 이를 CUBE로 집계를 하면 전체합계 1건, JOB별 집계 5건, DEPTNO별 집계 3건, DEPTNO에서의 JOB별 집계가 3건씩 9건으로 총 18건이 출력된다."
25,"아래의 테이블 스키마 정보를 참고하여, 다음 중 '구매 이력이 있는 고객 중 구매 홧수가 3회 이상인 고객의 이름과 등급을 출력하시오'라는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 구문으로 가장 적절한 것은?",,"[테이블] 고객(고객번호(PK), 이름, 등급) 구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK)) * 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다. [SQL 문장] SELECT A.이름 , A.등급 FROM 고객 A (ㄱ) GROUP BY A.이름 ,A.등급 (ㄴ)",(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : WHERE B.구매번호〉=3,(ㄱ) : LEFT OUTER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B.구매번호) >=3,(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING COUNT(B. 구매번호) >=3,(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B. 구매번호)〉=3,"정답: 3
해설: None"
26,다음 중 주어진 테이블을 수행하였을 때 결괏값이 다른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j495-1.png,,SELECT COUNT(*) FROM TEST16 WHERE MemberID IS NOT NULL;,"SELECT COUNT (NULLIF(MemberID, NULL)) FROM TEST16;",SELECT COUNT(MemberID) FROM TEST16;,SELECT COUNT(1) FROM TEST16;,"정답: 4
해설: 보기 ④번은 6개를 반환하고 나머지는 모두 4개를 반환한다."
27,다음 보기의 SQL문을 실행 했을 때 결괏값이 다른 하나는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j294-1.png,,"select NVL(a.COL1,-1) as data from Mytest a;","select DECODE(a.COL1, null,-1,a.col1) as data from Mytest a;",select case when a.COL1 is null then -1 else 0 end as data from Mytest a;,select case a.COL1 when null then -1 else 0 end as data from Mytest a;,"정답: 4
해설: 나머지 보기는 모두 COL1 값이 NULL일 때 -1을 반환하는데 ④번 보기만 COL1값이 NULL일 때 0 을 반환한다. 즉, CASE문으로 NULL을 비교할 때 알수 없음이 된다."
28,다음 주어진 테이블에 대해서 아래와 같은 SQL문을 수행하였을 때 반환되는 ROW 값의 수는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j195-1.png,,4,3,2,1,"정답: 1
해설: 주어진 SQL문 앞에 UNION 연산을 수행하면 1,2,3,4,5,가 반환되고 이어서 minus를 수행하면 1,3,4,5가 반환된다."
29,다음 중 SQL 명령어가 올바르지 않은 것은?,,,DML : RENAME,DCL : REVOKE,DDL : ALTER,DDL : TRUNCATE,"정답: 1
해설: DDL은 CREATE, ALTER, DROP 문이 있다."
30,다음의 SQL문을 실행한 결과를 쓰시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j358-1.png,"SELECT SUM(CASE WHEN COL1 ='A' THEN 1 END) AS SUM1, SUM(CASE WHEN COL3 < 20000 THEN 1 END) AS SUM2 FROM Mytest;","4,8","3,7","2,6","1,5","정답: 2
해설: SUM1은 COL1 ='A'조건을 만족하는 1,2,3행을 각각 1로 되돌리고 합계를 계산하기 때문에 3이 된다. COL2 < 20000 조건은 모든 행이 만족하고 1을 되돌리므로 합계는 7이 된다."
31,다음 주어진 데이터에서 해당 SQL문을 실행 했을 때의 결괏값으로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j536-1.png,"SELECT A, SUM(X) AS TAB FROM TABLE_B GROUP BY A;",,,,,"정답: 2
해설: A 칼럼별로 그룹화하고 집계 함수에서 NULL값을 제외하고 연산을 수행한다."
32,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j696-1.png,SELECT COUNT(TAB1.COL1) AS CNT FROM TAB1 LEFT OUTER JOIN TAB2 ON TAB1.COL2 = TAB2.COL2 AND TAB1.COL1 = TAB2.COL1;,6,5,4,3,"정답: 2
해설: None"
33,다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.,,SELECT ... FROM 급여이력 S WHERE NOT EXISTS (SELECT 'X' FROM 사원 P WHERE P.사원번호 = S.사원번호) [SQL문] SELECT .... FROM 급여이력 S LEFT OUTER JOIN 사원 P ON(S.사원번호=P.사원번호) WHERE ( );,P.사원번호 IS NULL,P.사원번호 IS NOT NULL,P.사원번호 > 0,P.사원번호 = NULL,"정답: 1
해설: NOT EXISTS는 OUTER JOIN으로 변경할 경우 NOT NULL칼럼에 대해서 IS NULL로 검사하여 NOT EXISTS를 구현한다."
34,다음 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j751-1.png,"SELECT SUM(E2.SAL) AS RESULT FROM EMP E1, EMP E2 WHERE E1.HIREDATE >= E2.HIREDATE GROUP BY E1.ENAME;",,,,,"정답: 2
해설: 셀프조인을 통해 각 행마다 입사일이 작거나 같은 모든 행을 출력하는 쿼리로, 각 행마다의 누적 급여 총 합을 출력 하게 된다."
35,아래의 데이터 모델에서 SQL을 이용하여 표(지역별 월별 이용량)와 같은 형식의 데이터를 추출하려고 할 때 올바른 SQL 문장은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j125-1.png,,"SELECT (CASE GROUPING(B.지역ID) WHEN 1 THEN '지역전체' ELSE MIN(B.지역명) END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, 'YYYY.MM')) WHEN 1 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY GROUPING SETS(B.지역ID, TO_CHAR(A.이용일시, 'YYYY.MM'))","SELECT (CASE GROUPINGS(B.지역명) WHEN 1 THEN '지역전체' ELSE B.지역명 END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, 'YYYY.MM')) WHEN 1 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY CUBE(B.지역명, TO_CHAR(A.이용일시, 'YYYY.MM'))","SELECT (CASE GROUPINGS(B.지역ID) WHEN 1 THEN '지역전체' ELSE MIN(B.지역명) END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, 'YYYY.MM')) WHEN 1 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY ROLLUP(B.지역ID, TO_CHAR(A.이용일시, 'YYYY.MM'))","SELECT (CASE GROUPING(B.지역명) WHEN 0 THEN '지역전체' ELSE B.지역명 END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, ’YYYY.MM')) WHEN 0 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY ROLLUP(B.지역명, TO_CHAR(A.이용일시, 'YYYY.MM'))","정답: 3
해설: 위의 결과 데이터는 지역에 대해서 월별 이용량 및 소계와 전체 이용량을 출력하였으므로, ROLLUP 함수를 활용할 수 있다. ROLLUP 집계 그룹 함수는 나열된 컬럼에 대해 계층 구조로 집계를 출력하는 함수로서 ROLLUP(A, B)를 수행하면 (A, B)별 집계, A별 집계와 전체 집계를 출력할 수 있다. ④번 보기의 경우 CASE 절의 GROUPING 함수의 사용이 잘못 (0이 아닌 1이 되어야 함) 되었으며, ②번 보기처럼 CUBE를 사용하게 되면, 결합 가능한 모든 값에 대하여 다차원 집계를 생성하게 된다. ①번 보기처럼 GROUPING SETS를 사용하게 되면 계층구조 없이 지역에 대한 합계와 월별 합계를 각각 생성하게 된다."
36,아래와 같은 데이터 모델에 대해 SQL을 수행 하였다. 다음 중 수행된 SQL과 동일한 결과를 도출하는 SQL은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j101-1.png,,"SELECT A.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A WHERE 서비스ID IN (SELECT 서비스ID FROM 서비스이용 MINUS SELECT 서비스ID FROM 서비스);","SELECT B.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A LEFT OUTER JOIN 서비스이용 B ON (A.서비스ID = B.서비스ID) WHERE B.서비스ID IS NULL GROUP BY B.서비스ID, A.서비스명, A.서비스URL;","SELECT X.서비스ID, X.서비스명, X.서비스URL FROM 서비스 X WHERE NOT EXISTS (SELECT 1 FROM (SELECT 서비스ID FROM 서비스 MINUS SELECT 서비스ID FROM 서비스이용) Y WHERE X.서비스ID = Y.서비스ID);","SELECT B.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A, 서비스이용 B WHERE A.서비스ID = B.서비스ID;","정답: 3
해설: 수행한 SQL은 이용된 적이 있었던 서비스를 추출하는 SQL이다. ① 서비스와 서비스이용 테이블의 순서를 변경하고 IN 절을 NOT IN으로 변경하면 동일한 결과를 출력할 수 있다. ② 서비스를 기준으로 OUTER JOIN을 수행하였으므로, 이용된 적이 없었던 서비스만 출력된다. B.서비스ID IS NOT NULL로 변경해야 동일한 결과가 출력된다. ③ 전체 서비스에서 이용된 적이 있었던 서비스를 MINUS하였으므로 이용된 적이 없었던 서비스가 서브쿼리에서 추출된다. 그러므로 NOT EXISTS 구문을 적용하면 이용된 적이 있었던 서비스가 출력된다. ④ 이용된 적이 있었던 서비스를 추출하는 것은 동일하나 서비스와 서비스이용은 1:n 관계이므로 서비스 이용건수 만큼 추출되므로 전체 결과가 다르다. GROUP BY를 수행하면 동일한 결과를 출력할 수 있다."
37,다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?,,,"서브쿼리는 SELECT절, FROM절, WHERE절 등에서 사용 가능하다.",메인쿼리에서 서브쿼리 내에 있는 칼럼을 사용할 수 없다.,"서브쿼리는 단일행 서브쿼리와 다중행 서브쿼리로 분리되고 다중행 서브쿼리의 경우 IN, ANY, EXISTS, ALL과 같은 함수를 사용해야 한다.","서브쿼리는 SQL문의 SELECT구, FROM구, WHERE구 모두 사용이 가능하다.","정답: 2
해설: 서브쿼리 중에서 INLINE VIEW의 칼럼은 메인쿼리에서도 사용 가능하다."
38,다음 주어진 테이블에서 아래와 같은 결괏값을 반환하는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j199-1.png,,"select count(case when 반=1 then 1 end) as ""결괏값"" count(case when 반=2 then 1 end) as b, count(case when 반=3 then 1 end) as c from SQLD_67;","select 반, count(distinct 이름) AS ""결괏값"" FROM SQLD_67 group by 반;","select 반, count(1) AS ""결괏값"" FROM SQLD_67 group by 반;","select 반, count(*) AS ""결괏값"" FROM SQLD_67 group by 반;","정답: 2
해설: ② 번에서 주어진 테이블을 '반'속성별로 그룹화한 다음 각 '반' 속성별 행의 수를 count하는데 distinct 인자로 중복되는 이름값은 제외하고 count를 수행하여 결괏값과 같이 반환된다."
39,다음 중 파티션에 대한 설명으로 올바르지 않은 것은?,,,"AVG(SAL) OVER (PARTITION BY MGR ORDER BY TODAY ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) : 각 MGR 별로 앞의 한 건, 현재 행, 뒤의 한 건 사이에서 SAL의 평균을 계산한다.",COUNT(*) OVER (ORDER BY SAL) RANGE BETWEEN 10 PRECEDING AND 150 FOLLOWING) : SAL을 기준으로 현재 행에서의 SAL의 -10에서 +150사이의 급여를 가지는 행의 수를 계산한다.,SUM(SAL) OVER (PARTITION BY MGR ORDER BY SAL RANGE UNBOUNDED PRECEDING) :각 MGR별 현재 행부터 파티션 내 첫 번째 행까지의 SAL의 합계를 계산한다.,RANK() OVER (PARTITION BY JOB ORDER BY SAL ASC) JOB_RANK :각 JOB 별 SAL이 낮은 순서대로 순위가 부여된다.,"정답: 1
해설: ①번 보기는 각 MGR별로 SAL의 평균을 계산하기 전에 TODAY를 기준으로 정렬을 수행한 다음에 SAL의 평균을 계산한다. 즉, 각 MGR별 TODAY 기준으로 정렬하였을 때 파티션 내에서 앞의 한 건, 현재 행, 뒤의 한 건 사이의 급여의 평균을 계산한다."
40,다음 계층형 쿼리문에 대한 설명으로 옳지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j458-1.png,"SELECT ID, PARENT_ID, NAME, PARENT_NAME FROM SQLD_13 WHERE PARENT_ID NOT IN (3) START WITH PARENT_ID = 0 CONNECT BY PRIOR ID = PARENT_ID ORDER SIBLINGS BY PARENT_ID ASC, ID ASC;",ORDER SIBLINGS BY를 하면 전체 테이블 기준으로 정렬한다.,중복이 생겼을 때 루프를 돌지 않기 위해 NO CYCLE 옵션을 사용할 수 있다.,순방향 전개다.,PARENT_ID가 0이라도 3이 포함되면 전개를 멈춘다.,"정답: 1
해설: ④의 경우, 계층쿼리는 일단 START WITH_CONNECT BY로 전개를 수행한 후에 WHERE로 필터링을 한다. 만약 CONNECT BY에 AND 조건을 PARENT_ID != 3 식이었다면 전개 중에 멈추겠지만 WHERE에서 필터링을 하는 것이므로 일단 전개를 완료한 후에 WHERE가 실행되는 것으로 볼 수 있다."
41,"부서와 사원 테이블을 생성하는 SQL 문장을 수행한 후 튜플 삽입으로 두 테이블의 상태가 다음과 같을 때, 테이블 연산 수행에 대한 설명으로 올바르지 않은 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j249-1.png,,"부서 테이블에 (1,'연구부') 튜플을 삽입한다면 참조 무결성 제약조건을 위배한다.","사원 테이블에 (14,'김유신',0) 튜플을 삽입한다면 참조 무결성 제약조건을 위배한다.","사원 테이블에 (13,'강감찬','A1') 튜플을 삽입한다면 도메인 무결성 제약조건을 위배한다.","부서 테이블에서 (2,'영업부') 튜플을 삭제한다면 참조 무결성 제약조건을 위배한다.","정답: 1
해설: 부서 테이블은 마스터 테이블이므로 사원 테이블에 없는 부서번호 등을 자유롭게 입력할 수 있다. 따라서 부서 테이블에 (1,""연구부"")을 입력하는 것은 참조 무결성 위배가 아니다. 단, 부서테이블에 부서번호 칼럼은 PRIMARY KEY이므로 중복값이 입력되면 안된다. 즉, 이미 부서번호가 1인 대상이 있으므로, 무결성 제약 조건에 위배된다."
42,다음 설명 중 가장 적절한 것은?,,,CUBE 그룹 함수는 인자로 주어진 컬럼의 결합 가능한 모든 조합에 대해서 집계를 수행하므로 다른 그룹 함수에 비해 시스템에 대한 부하가 크다.,"CUBE, ROLLUP, GROUPING SETS 함수들의 대상 컬럼 중 집계된 컬럼 이외의 대상 컬럼 값은 해당 컬럼의 데이터 중 가장 작은 값을 반환한다.",GROUPING SETS 함수의 경우에는 함수의 인자로 주어진 컬럼의 순서에 따라 결과가 달라지므로 컬럼의 순서가 중요하다.,"일반 그룹 함수를 사용하여 CUBE, GROUPING SETS와 같은 그룹함수와 동일한 결과를 추출할 수 있으나, ROLLUP 그룹 함수와 동일한 결과는 추출할 수 없다.","정답: 1
해설: ② CUBE, ROLLUP, GROUPING SETS 함수들에 의해 집계된 레코드에서 집계 대상 컬럼 이외의 GROUP 대상 컬럼의 값은 NULL을 반환한다. ③ 함수의 인자로 주어진 컬럼의 순서에 따라 다른 결과를 추출하게 되는 그룹 함수는 ROLLUP 이며, 나열된 컬럼에 대해 계층 구조로 집계를 출력한다. ④ CUBE, GROUPING SETS, ROLLUP 세가지 그룹 함수 모두 일반 그룹 함수로 동일한 결과를 추출할 수 있다."
43,다음 SQL문의 ( )를 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j435-1.png,,"ㄱ: RANK(), ㄴ: DENSE_RANK()","ㄱ: DENSE_RANK(), ㄴ: ROW_NUMBER()","ㄱ : ROW_NUMBER(), ㄴ : RANK()","ㄱ : RANK(), ㄴ : ROW_NUMBER()","정답: 4
해설: 첫 번째 실행 결과는 급여가 동일하므로 같은 등수가 조회되었다. 따라서 RANK() 함수이다. 두 번째 실행 결과는 급여가 동일하지만 유일한 등수가 부여되었다. 따라서 ROW_NUMBER() 함수이다."
44,다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?,,,계층형 질의는 하나의 테이블에서 자기 자신을 조인하는 형태를 사용한다.,재무제표 및 조직도와 같은 구조에서 사용할 수 있다.,순방향과 역방향 모두 수행할 수 있다.,루트 노드의 LEVEL 값은 가장 큰 값을 가진다.,"정답: 4
해설: Oracle 계층형 질의에서 루트 노드의 LEVEL값은 1이다."
45,"A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?",,,B 사용자는 홍길동 데이터를 수정할 수 있다.,A 사용자는 홍길동 데이터를 수정할 수 있다.,B 사용자는 홍길동 데이터가 조회되지 않는다.,A 사용자는 홍길동 데이터를 조회할 수 있다.,"정답: 1
해설: 트랜잭션의 특징 중 고립성은 COMMIT이 완료되어야 다른 사용자가 해당 데이터를 조회하거나 수정할 수 있는 것이다. COMMIT 완료 전에는 해당 사용자만 조회하거나 수정할 수 있다."
46,아래 SQL 수행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j644-1.png,"SELECT COL1 FROM TAB1 ORDER BY CASE WHEN MOD(COL2, 3) = 0 THEN 'A' ELSE 'B' END, COL1;",,,,,"정답: 3
해설: CASE문 결과를 1차 정렬로 한 뒤, 이 값이 같을 경우 COL1의 값으로 2차 정렬을 수행한다. 이렇게 정렬된 COL1의 값은 SCOTT, ALLEN, FORD, SMITH 순으로 출력된다."
47,"Gender 칼럼이 0이면 남자, 1이면 여자를 출력 SELECT ( ㄱ ) FROM EMP; V_NAME은 문자열 변수 SELECT NAME ( ㄴ ) V_NAME FROM EMP;",,,"ㄱ : DECODE(GENDER, 0, '남자', '여자'), ㄴ : ON","ㄱ : DECODE(GENDER, 0, '남자', '여자'), ㄴ : INTO","ㄱ : DECODE(GENDER, 1, '남자', '여자'), ㄴ : ON","ㄱ : DECODE(GENDER, 0, '남자', '여자'), ㄴ : INTO","정답: 4
해설: DECODE 혹은 CASE문으로 구현되고 PL/SQL문에서 변수에 값을 넣기 위해서는 INTO구를 사용해야 한다."
48,"주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)",,"insert into test32 values (null,10); insert into test32 values (12,null); insert into test32 values (null,null); insert into test32 values (10,12); ㄱ. SELECT COUNT(COL1) FROM test32; ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null); ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;","4,2,3","2,2,3","2,1,3","2,3,4","정답: 2
해설: ㄱ은 COUNT(COL1)을 사용하므로 NULL은 제외되기 때문에 2가 된다. 그리고 ㄴ은 IN구를 사용해서 NULL까지 조건으로 넣었지만, 12,10만 조회된다. 즉, NULL은 제외된다. 그리고 ㄷ은 COL1로 GROUP BY하였으므로 3건이 된다."
49,이래는 어느 회사의 정산 데이터 모델의 일부이며 고객이 서비스를 사용한 시간대에 따라 차등 단가를 적용하려고 한다. 다음 중 시간대별사용량 테아블을 기반으로 고객별 사용금액을 추출하는 SQL으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j93-1.png,,"SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B ON (A. 고객ID = B.고객ID) BETWEEN JOIN 시간대구간 C GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;","SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B ON (A.고객ID = B.고객ID) INNER JOIN 시간대구간 C ON B.사용시간대 BETWEEN C.시작시간대 AND C.종료시간대 GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;","SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B INNER JOIN 시간대구간 C ON (A.고객ID = B.고객ID AND B.시용시간대 BETWEEN C.시작시간대 AND C.종료시간대) GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;","SELECT A.고객ID, A.고객명, SUM(B.사용량 * C. 단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B ON (A.고객ID = B.고객ID) INNER JOIN 시간대구간 C ON (B.사용시간대〈= C.시작시간대 AND B.사용시간대〉= C.종료시간대) GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;","정답: 2
해설: None"
50,아래 결과를 출력하기 위해 빈칸에 들어갈 문장으로 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j653-1.png,,"SELECT 고객.고객번호, 상품.상품명 FROM 고객, 상품 ON 고객.포인트 >= 상품.최소포인트(+);","SELECT 고객.고객번호, 상품.상품명 FROM 고객 JOIN 상품 ON 고객.포인트 BETWEEN 상품.최소포인트 AND 상품.최대포인트;","SELECT 고객.고객번호, 상품.상품명 FROM 고객 INNER JOIN 상품 ON 고객.포인트 <= 상품.최대포인트;","SELECT 고객.고객번호, 상품.상품명 FROM 고객 INNER JOIN 상품 ON 고객.포인트 >= 상품.최소포인트;","정답: 2
해설: 결과표를 보면 고객이 보유한 포인트에 맞춰서 상품을 출력한 것을 알 수 있다. 따라서 고객이 보유한 포인트가 상품 테이블의 최소포인트와 최대포인트 사이에 있는 조건을 갖는 쿼리는 3번이다."
