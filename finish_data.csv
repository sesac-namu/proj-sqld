,category,tag,title,content_img,content_text,choices_1,choices_2,choices_3,choices_4,commentary,answer_number
0,2과목,정규화,다음 중 아래 '일자별매각물건' 엔터티에 대한 설명으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j34-1.png,,2차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:1 관계가 될 수 있다.,2차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:M 관계가 될 수 있다.,1차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:1 관계가 될 수 있다.,1차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:M 관계가 될 수 있다.,,2
1,2과목,ER 모델링,다음의 ERD에 대한 설명으로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j481-1.png,,의사가 없이 진료할 수 있다.,진료는 반드시 의사가 해야 한다.,한 개의 상급종합병원에는 여러 명의 의사가 근무한다.,상급종합병원에는 의사가 근무하지 않을 수가 있다.,상급종합병원에는 한 명의 혹은 여러 명의 의사가 근무하고 모델링으로는 의사가 없을 수도 있다. 진료는 의사만 할 수 있고 의사는 진료를 하지 않을 수도 있다.,1
2,2과목,집합 연산자,다음 중 SQL문을 가장 잘 설명하고 있는 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j345-1.png,"SELECT A.* FROM MytestA A, MytestB B WHERE A.MANAGER_ID = B.EMPLOYEE_ID AND B.SALARY >= ANY A.SALARY;",어떤 상사보다도 연봉이 낮은 부하 직원,어떤 상사보다도 연봉이 높은 부하 직원,어떤 부하 직원보다도 연봉이 낮은 상사,어떤 부하 직원보다도 연봉이 높은 상사,"A테이블의 매니저 아이디가 B테이블의 직원 아이디이므로 A가 부하직원, B가 상사라고 볼 수 있다. 그러므로 상단의 SQL문은 어떤 부하직원보다도 연봉이 높은 상사의 데이터를 조회하는 SQL문이라 할 수 있다.",4
3,2과목,그룹 함수,다음 주어진 SQL문의 빈칸에 그룹 함수를 쓰시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j359-1.png,"SELECT COL1, COL2, SUM(COL3) FROM Mytest GROUP BY ( );","GROUPING SETS(COL1,(COL2,COL1))","GROUPING SETS(COL1,(COL2,COL3))","GROUPING SETS(COL1,(COL2,COL3))","GROUPING SETS(COL1,(COL1,COL2))",,4
4,2과목,트랜잭션 관리,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j617-1.png,"INSERT INTO TAB1 VALUES(5, 'E', 3); COMMIT; UPDATE TAB1 SET COL2 = 3 WHERE NO = 2; SAVEPOINT SAVE1; INSERT INTO TAB1 VALUES(6, 'F', 5); DELETE TAB1 WHERE NO = 4; ROLLBACK TO SAVE1; UPDATE TAB1 SET COL2 = 2 WHERE NO = 1; ROLLBACK; COMMIT; SELECT SUM(COL2) FROM TAB1;",13,12,11,8,"첫 INSERT문장은 COMMIT했기 때문에 영구 저장된다. 그 이후 UPDATE, INSERT, DELETE를 차례대로 하지만 SAVE1 지점으로 롤백하므로 INSERT와 DELETE는 실행 취소된다. 첫 UPDATE문장과 마지막 UPDATE문장은 모두 롤백되어 결과적으로는 첫 INSERT문장만 실행된다. 따라서 남은 행의 SUM(COL2) 결과는 11이다.",3
5,2과목,JOIN,아래와 같은 두개의 테이블이 있을 때 아래의 SQL 결과 건수를 알맞게 나열한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j301-1.png,SELECT * FROM MytestA A INNER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A LEFT OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A RIGHT OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A FULL OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A CROSS JOIN MytestB B;,"2, 4, 3, 7, 12","2, 3, 4, 5, 12","2, 4, 5, 8, 12","2, 4, 3, 5, 12","-INNER JOIN은 B와 C가 같기 때문에 2건이다. -LEFT OUTER JOIN은 같은 것 2건과 D,E까지 포함해서 4건이 된다. -RIGHT OUTER JOIN은 같은 것 2건과 MytestB의 A까지 조회되어서 3건이 된다. -FULL OUTER JOIN은 같은 것 2건과 MytestA의 2건, MytestB의 1건 포함해서 5건이 된다. -CROSS JOIN은 MytestA의 4개의 행과 MytestB의 3개의 행을 곱해서 4*3=12건이다.",4
6,2과목,JOIN,다음 SQL문에서 ( )에 들어갈 알맞은 명령어는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j244-1.png,,CROSS JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,FULL OUTER JOIN,DEPT 테이블에 있는 40번이 조회되고 EMP테이블은 NULL로 조회되므로 RIGHT OUTER JOIN이다.,2
7,2과목,집합 연산자,다음 중 SQL의 결과가 다른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j410-1.png,,SELECT * FROM Mytest WHERE COL1 <= 200 AND COL2 >= 200;,SELECT * FROM Mytest WHERE 1=1 AND 200 BETWEEN COL1 AND COL2,SELECT * FROM Mytset WHERE 1=1 AND ( CODE = 'A001' AND 200 BETWEEN COL1 AND COL2) OR ( CODE = 'B001' AND 200 BETWEEN COL1 AND COL2);,"SELECT * FROM Mytest WHERE 1=1 AND CODE IN ('A001','B001') AND COL1 BETWEEN 200 AND 400;","④번 보기는 200<=A<=400, 200<=B<=400의 의미이고 ①,②,③ 번 보기는 모두 COL1<=200 && COL2>=200의 의미이다.",4
8,2과목,단일행 함수,다음 쿼리의 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j587-1.png,"SELECT SUM(DECODE(SIGN(SAL-4000), 1, 1, 0)) FROM TAB1;",3,2,1,0,"SAL > 4000 이면 SAL - 4000 은 양수이므로 SIGN 을 취한 값이 1 이 리턴된다. DECODE 문을 해석하면 결국 SAL 이 4000 보다 큰 경우 1 을, 그렇지 않은 경우 0 을 리턴하므로 최종 출력값은 2 이다.",2
9,2과목,계층형 질의,아래 실행 결과를 출력하는 SQL로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j709-1.png,"SELECT 사원번호, 이름, LEVEL FROM 사원 WHERE 지역 = '경기' START WITH 상위관리자코드 IS NULL CONNECT BY 상위관리자코드 = PRIOR 사원번호;",,,,,WHERE절은 출력 대상을 결정하기 때문에 서울 지역인 홍길동은 출력하지 않는다.,4
10,2과목,서브쿼리,다음 과일 테이블에 대한 SQL문 내의 비교조건을 해석한 것으로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j248-1.png,,"""19=ALL(SELECT 과일코드 FROM 과일)"" 거짓이다.","""15<ALL(SELECT 과일코드 FROM 과일)""은 참이다.","""19<ANY(SELECT 과일코드 FROM 과일)""은 거짓이다.","""21 NOT IN (SELECT 과일코드 FROM 과일)""은 참이다.","ALL은 전부 일치하는 것만 출력하는 것으로 AND라고 생각하면 되고 ANY는 OR로 생각하면 된다. 그러므로 보기②번은 15보다 큰 것이 모두 일치해야 하는데 과일 테이블에 있는 15, 키위는 값이 크지 않고 같다.",2
11,2과목,집계 함수,아래 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j641-1.png,SELECT COUNT(COL1) AS RESULT FROM TAB1 WHERE COL2 >= 30 GROUP BY COL1;,,,,,WHERE절의 비교 연산 결과 COL2의 30과 40만 해당되고 그에 해당하는 COL1은 모두 NULL이다. GROUP BY에 의해 COL1이 NULL인 한 그룹이 생성되지만 NULL은 COUNT하지 않기 때문에 0이 출력된다.,2
12,2과목,서브쿼리,다음 쿼리의 수행 결과로 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j702-1.png,DELETE FROM TAB1 WHERE CODE IN (SELECT CODE FROM TAB2 WHERE STATUS = 'OPEN'); SELECT SUM(FARE) FROM TAB1;,800,600,400,100,"TAB2의 STATUS가 OPEN인 CODE는 0002와 0004이므로 TAB1에서 이들을 삭제하면 AAA,BBB만 남는다. 이들의 FARE 총합은 600이다.",2
13,2과목,윈도우 함수,다음의 실행 결과를 조회하는 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j381-1.png,,"SELECT NTITLE() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) RN, DEPTNO, SAL FROM LIMBEST.EMP;","SELECT DENSE_RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) RN, DEPTNO, SAL FROM LIMBEST.EMP;","SELECT RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) RN, DEPTNO, SAL FROM LIMBEST.EMP;","SELECT ROW_NUM() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) RN, DEPTNO, SAL FROM LIMBEST.EMP;",SAL 값이 동일하면 동일한 등수가 부여 되므로 RANK() 함수이다.,3
14,2과목,집합 연산자,다음 주어진 테이블에 대해서 아래의 SQL문을 수행하였을 때의 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j379-1.png,SELECT Count(*) FROM( SELECT DISTINCT COL1 FROM mytesta UNION ALL SELECT COL1 FRM mytestb );,11,12,10,4,"1번째 테이블에서 10,20,25,30,50,60이 반환되고 2번째 테이블에서 10,20,30,40,50이 반환되기 때문에 총 행 수는 11이 된다.",1
15,2과목,그룹 함수,아래와 같이 설비와 에너지사용 테이블을 이용하여 결과를 나타내려할 때 SQL으로 가장 적절한 것을 2개 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j127-1.png,,"SELECT A.설비ID, B.에너지코드, SUM(B.사용량) AS 사용량합계 FROM 설비 A INNER JOIN 에너지사용량 B ON (A.설비ID = B.설비ID) GROUP BY GROUPING SETS((A.설비ID), (B 에너지코드), (A.설비ID, B.에너지코드)) ORDER BY A.설비ID, B.에너지코드;","SELECT A.설비ID, B.에너지코드, SUM(B.사용량) AS 사용량합계 FROM 설비 A INNER JOIN 에너지사용량 B ON (A.설비ID = B.설비ID) GROUP BY GROUPING SETS((A.설비ID), (B.에너지코드), (A.설비ID, B.에너지코드),0) ORDER BY A.설비ID, B.에너지코드;","SELECT A.설비ID, B.에너지코드, SUM(B.사용량) AS 사용량합계 FROM 설비 A INNER JOIN 에너지사용량 B ON (A.설비ID = B.설비ID) GROUP BY CUBE (A.설비ID, B.에너지코드) ORDER BY A.설비ID, B.에너지코드;","SELECT A.설비ID, B.에너지코드, SUM(B.사용량) AS 사용량합계 FROM 설비 A INNER JOIN 에너지사용량 B ON (A.설비ID = B.설비ID) GROUP BY CUBE ((A.설비ID), (B.에너지코드), (A.설비ID, B.에너지코드)) ORDER BY A.설비ID, B.에너지코드;","SQL의 결과를 보면 설비ID와 에너지코드의 모든 조합에 대하여 사용량합계를 추출하고 있다. CUBE 함수는 인수로 나열된 항목의 가능한 모든 조합에 대하여 GROUPING을 수행한다. 또한 GROUPING SETS은 사용자가 원하는 다양한 조합을 인수로 사용할 수 있다. 위 문제에서 ③번은 CUBE를 사용하였 으므로 CUBE절에 나열된 컬럼의 모든 조합 즉, ((설비ID), (에너지코드), (설비ID, 에너지코드))에 대해 SUB TOTAL을 만들게 된다. ②번은 GROUPING SETS를 활용하여 ③번의 모든 조합을 직접 기술 하였다.","2,3"
16,2과목,그룹 함수,다음 중 Mytest 테이블에서 주어진 결과를 반환하는 SQL문으로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j323-1.png,,"SELECT DNAME, SUM(SAL) FROM Mytest GROUP BY ROLLUP(DNAME, YEAR, (DNAME, YEAR));","SELECT DNAME, SUM(SAL) FROM Mytest GROUP BY ROLLUP((DNAME, YEAR));","SELECT DNAME, SUM(SAL) FROM Mytest GROUP BY ROLLUP(DNAME, (DNAME, YEAR));","SELECT DNAME, SUM(SAL) FROM Mytest GROUP BY ROLLUP((DNAME, DNAME), NULL);",,3
17,2과목,집계 함수,다음 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j642-1.png,"SELECT COL1 AS C1, SUM(COL2) AS C2 FROM TAB1 GROUP BY COL1 HAVING SUM(COL2) >= 400;",,,,,"GROUP BY 후 SUM(COL2) 연산 결과 (10, 300), (20, 400), (30, 500), (NULL, 600) 그룹이 출력된다. 이들 중 HAVING 조건에 만족하는 그룹은 (20, 400), (30, 500), (NULL, 600) 이다.",3
18,2과목,DML,"아래 7개의 SQL 문장이 성공적으로 수행되었다고 할 때, A, B, C 세 개의 SQL 문장을 차례대로 실행하면 A와 C의 SELECT 문장 수행결과는 각각 무엇인가?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j51-1.png,,"3,3","3,2","3,1","3,NULL",,3
19,2과목,DML,"다음 주어진 데이터에 대해서 LIKE문을 사용하여 결괏값에 ""_""가 들어간 문자열을 찾는 SQL문으로 올바른 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j547-1.png,,SELECT * FROM test31 WHERE username LIKE '%_%' ESCAPE '_',SELECT * FROM test31 WHERE username LIKE '%@_%' ESCAPE '@',SELECT * FROM test31 WHERE username LIKE '%#_%',SELECT * FROM test31 WHERE username LIKE '%H',SELECT문에서 LIKE 연산으로 '%'나 '_'가 들어간 문자를 검색하기 위해서는 ESCAPE 명령어를 사용할 수 있다. 즉 '_'나 '%' 앞에 ESCAPE로 특수문자를 지정하면 검색할 수 있다.,2
20,2과목,정규화,다음 중 아래 '일재고' 엔터티에 대한 설명으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j36-1.png,,2차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:1 관계가 될 수 있다.,2차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:M 관계가 될 수 있다.,1차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:1 관계가 될 수 있다.,1차 정규화가 필요한 엔터티로서 매각기일과 일자별매각물건으로 1:M 관계가 될 수 있다.,,4
21,2과목,ER 모델링,다음 주어진 ERD 관계에 대한 설명으로 옳은 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j271-1.png,,그룹 계정에 여러 명의 사용자가 반드시 속해야 한다.,그룹 계정에 사용자 계정이 없을 수 있다.,한 명의 사용자는 여러 개의 그룹에 속해야 한다.,그룹마스터는 여러 개의 동일한 그룹ID를 가질 수 있다.,그룹 계정과 사용자 계정 간의 관계는 Optional 관계이므로 그룹 계정에 사용자가 없을 수 있다.,2
22,2과목,윈도우 함수,다음 주어진 테이블이 아래의 결과와 같이 반환되도록 SQL문의 빈칸에 들어갈 것으로 알맞은 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j450-1.png,"SELECT ( ) OVER(ORDER BY SAL DESC) AS RANK, NAME, DEPTNAME, POSITION, SAL FROM TEST44;",NTILE(),ROW_NUMBER(),DENSE_RANK(),RANK(),RANK() 함수는 동일한 점수면 같은 등수를 부여한다.,4
23,2과목,집계 함수,다음 주어진 테이블에 대해서 아래와 같은 결과값이 반환되도록 아래 SQL문의 빈칸에 들어갈 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j204-1.png,,"min(COL1), max(COL2), max(COL1)","max(COL1), min(COL2), sum(COL1)","max(COL1), min(COL2), sum(COL2)","max(COL2), min(COL2), sum(COL1)","A 속성은 COL1의 최댓값, B속성은 COL2의 최솟값, C속성은 COL1 속성의 합이다.",2
24,2과목,그룹 함수,아래 SQL의 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j656-1.png,"SELECT PRODUCT_NO, GOGAK_NO, SUM(QTY) AS TOTAL_QTY FROM JUMUN GROUP BY GROUPING SETS(PRODUCT_NO, GOGAK_NO, ());",,,,,"GROUPING SETS(PRODUCT_NO, GOGAK_NO, ())에서 PRODUCT_NO별 SUM(QTY) 결과, GOGAK_NO별 SUM(QTY)연산 결과가 출력된 것과 ()으로 인해 SUM(QTY)의 전체 총 합이 출력된 것을 찾는 문제이다.",4
25,2과목,DML,다음의 SQL문이 반환하는 결괏값은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j297-1.png,"select * from Mytest order by COL1 desc, COL2 desc, COL3 desc;",,,,,"해당 SQL문은 주어진 테이블인 Mytest에서 CO1, COL2, COL3 속성 순서대로 내림차순 정렬을 수행한다. (1,null,1)은 COL1 desc에 의해 먼저 정렬되므로 마지막 행에 위치한다. COL1을 정렬해서 값이 동일한 행은 COL2 desc를 수행하는데, COL2 열도 동일한 행이 있으므로 그 행들에 대해 COL3 desc를 수행한다.",2
26,2과목,집합 연산자,다음 주어진 테이블에 대해서 아래와 같은 SQL문을 수행하였을 때 반환되는 ROW 값의 수는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j277-1.png,select * from A1 union select * from B1 minus select * from C1;,4,3,2,1,"select * from A union select * from B를 실행하면 1,2,3,4,5가 반환된다. 해당 결과에 MINUS 조인을 하면 4,5가 빠지기 때문에 최종적으로 1,2,3 이 된다.",2
27,2과목,윈도우 함수,"다음 SQL문을 실행하여 나오는 결과의 빈칸 (ㄱ),(ㄴ)을 작성하시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j354-1.png,"SELECT NTILE2, COUNT(*) AS CNT FROM( SELECT COL1, COL2, COL3, NTILE(3) OVER(ORDER BY COL3) AS NTILE2 FROM Mytest ) GROUP BY NTILE2;","ㄱ : 3, ㄴ : 2","ㄱ : 1, ㄴ : 3","ㄱ : 2, ㄴ : 3","ㄱ : 3, ㄴ : 1","주어진 테이블에서 COL3 속성의 값 7개를 2,2,2로 균등하게 3등분하고 남은 값을 앞에서부터 순차적으로 할당하므로 3,2,2개씩 파티션이 분할된다. 그러면 NTILE2에서는 각각 분할된 파티션별 번호인 1,2,3이 할당되고 CNT에서는 각각에 분할된 파티션별 행의 수가 카운트 되어 3,2,2가 반환된다.",2
28,2과목,그룹 함수,아래의 결괏값을 보고 SQL문의 빈칸에 들어 갈 수 있는 내용을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j205-1.png,"SELECT DEPTNO, JOB, SUM(SAL) FROM SQLD_73 GROUP BY ( );","CUBE(DEPTNO, JOB)","DEPTNO, JOB","GROUPING SETS(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","주어진 결괏값을 보면 1.DEPTNO별 합계, 2.DEPTNO, JOB별 합계, 3.전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다.",4
29,2과목,집계 함수,아래와 같은 테이블 데이터가 있다. SQL에 대한 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j649-1.png,SELECT SUM(T1.COL2) FROM TAB1 T1 WHERE T1.COL2 = (SELECT MAX(COL2) FROM TAB1 T2 WHERE T1.COL1 = T2.COL1);,100,90,,에러,"서브쿼리 조건절은 TAB1의 각 행의 COL1을 확인하여 같은 값을 갖는 행들 중 COL2의 최대값과 일치하는 행을 찾아 COL2의 총 합을 묻는 질의절이다. 즉, COL1별 COL2 값이 최대인 행들의 COL2의 총 합을 리턴하는 문장이므로 A그룹에서는 30,30, B그룹에서는 40이 리턴되어 총 100이 출력된다.",1
30,2과목,그룹 함수,다음 주어진 두 개의 테이블에 대해서 아래와 같은 결괏값이 반환되도록 아래의 SQL문의 빈칸에 들어갈 값을 적으시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j556-1.png,"SELECT b.grade, a.StudentNo, SUM(b.grade) FROM TEST44_1 a, TEST44_2 b GROUP by ( );","GROUPING SETS(a.studentno, (b.grade, a.studentno));","GROUPING SETS(b.grade, (b.grade, a.studentno));","GROUPING SETS(b.grade, (a.studentno, b.grade));","GROUPING SETS(b.grade, (a.studentno));","결괏값을 보면 1.b.Grade, a.StudentNo에 대한 집계, 2.b.grade에 대한 집계가 있고 전체 집계는 없다.",2
31,2과목,DML,다음 문장의 수행 후 TAB2의 조회 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j718-1.png,ALTER TABLE TAB2 ADD FOREIGN KEY(CLASS_NO) REFERENCES TAB1(NO) ON DELETE SET NULL; DELETE FROM TAB1 WHERE NAME = 'C';,,,,,ON DELETE SET NULL 옵션에 의해 TAB1 데이터 삭제 시 자식 데이터의 외래키 컬럼은 NULL로 수정된다.,2
32,2과목,윈도우 함수,다음 테이블에 대한 매출 누적을 구하는 SQL문을 작성하시오.(윈도우 함수 사용),https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j217-1.png,,"SELECT 영업사원, 판매월, sum(매출) from group by 영업사원, 판매월;","SELECT 영업사원, 판매월, sum(매출) over (partition by 판매월 range between unbounded preceding and current row) 누적매출 from 매출;","SELECT 영업사원, 판매월, sum(매출) over (partition by 영업사원 order by 판매월 range between unbounded preceding) 누적매출 from 매출;","SELECT 영업사원, 판매월, sum(매출) over (partition by 영업사원 order by 판매월 range between unbounded preceding and current row) 누적매출 from 매출;","Select 영업사원, 판매월, sum(매출) over (partition by 영업사원 order by 판매월 range between unbounded preceding and current row) 누적매출 from 매출; 영업사원별 누적 매출이므로 ""partition by 영업사원""을 사용해야 한다. 그리고 unbounded preceding와 current row는 시작부터 현재행까지를 의미한다.",4
33,2과목,계층형 질의,다음 주어진 테이블에서 아래와 같은 결과가 반환되도록 SQL문의 빈칸에 들어갈 올바른 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j196-1.png,,"(ㄱ) 남성의류 IS NULL, (ㄴ) 여성의류 = 남성의류;","(ㄱ) 여성의류 IS NULL, (ㄴ) 남성의류 = 여성의류;","(ㄱ) 여성의류, (ㄴ) 여성의류 = 남성의류;","(ㄱ) 남성의류, (ㄴ) 남성의류 = 여성의류;","결괏값에서 남성의류 속성값이 NULL부터 시작하므로 ㄱ 보기에는 남성의류 IS NULL이 와야 한다. 남성의류를 상위계층, 여성의류를 하위계층으로 하며 각 남성의류별 여성의류값이 계층적으로 조회되므로 ㄴ 보기에는 여성의류 = 남성의류가 와야 한다.",1
34,2과목,DML,다음 주어진 테이블에서 아래의 SQL문의 결과값으로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j422-1.png,SELECT COUNT(*) FROM limbest.emp WHERE JOB = 'CLERK' OR (ENAME LIKE 'T%' AND SAL >= 3000);,8건,7건,6건,5건,"ENAME은 모두 ""T""로 시작한다. 따라서 SAL이 3000이상인 사람이 3건이고 JOB이 ""CLERK""은 4건이다. 따라서 총 7건이 조회된다.",2
35,2과목,윈도우 함수,다음 빈칸에 들어갈 문장으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j662-1.png,,"PIVOT (판매량 FOR 구분 FOR (Q1, Q2))","PIVOT (판매량 FOR 구분 IN (Q1, Q2))","UNPIVOT (판매량 FOR 구분 FOR (Q1, Q2))","UNPIVOT (판매량 FOR 구분 IN (Q1, Q2))",WIDE -> LONG 데이터로 변환하는 과정이므로 UNPIVOT이 적절하다. UNPIVOT은 IN으로 LONG 데이터로 변환할 대상을 지정한다.,4
36,2과목,집계 함수,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j654-1.png,SELECT SUM(COL1) FROM TAB1 T1 WHERE COL3 >= (SELECT AVG(COL3) FROM TAB2 T2 WHERE T2.COL2 = T1.COL2);,23,9,0,,"T2.COL2 값의 그룹별로 COL3의 평균보다 T1.COL3의 값이 큰 행을 찾고, 이들의 T1.COL1의 총 합을 구하는 질의절이다. T2에서 COL2의 값이 A인 그룹의 AVG(COL3)은 20이므로 T1에서 A그룹이면서 COL3의 값이 20보다 크거나 같은 대상을 찾으면 0건이 출력된다. 마찬가지로 T2에서 B그룹의AVG(COL3)을 구하면 20이고, T1의 B그룹중 COL3 의 값이 20보다 크거나 같은 행은 COL1의 값이 4,5인 행이므로 최종 결과는 9가 리턴된다.",2
37,2과목,JOIN,다음 중 아래의 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j113-1.png,,3,2,1,0,"WHERE 절의 단일행 서브쿼리인 (SELECT D FROM DEPT WHERE E = 'i') 에 의해서 DEPT 테이블의 D 컬럼 값이 x인 행이 선택되고, D = (SELECT D FROM DEPT WHERE E = 'i') 조건에 의해 EMP 테이블의 (A=1, B=a), (A=2, B=a) 인 2건이 출력된다. 출력된 결과가 모두 UNIQUE하기 때문에 DISTINCT 연산자는 결과 건수에 영향을 주지 않는다.",2
38,2과목,집계 함수,다음 중 아래와 같은 테이블 A에 대해서 SQL을 수행하였을 때의 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j80-1.png,,,,,,,3
39,2과목,집계 함수,다음 중 아래 SQL의 실행결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j81-1.png,,,,,,,3
40,2과목,,다음 주어진 테이블에 대해서 아래의 SQL문을 수행하였을 때의 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j507-1.png,SELECT CASE WHEN SUM (COL1 + COL2) IS NULL THEN 0 ELSE SUM(COL1 + COL2) END AS 합계 FROM TEST32;,25,22,12,,,2
41,2과목,,다음 중 SELECT COL1 + COL3 FROM TAB_A; 의 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j64-1.png,,50 NULL NULL,150, 80 10 60,,,1
42,2과목,ER 모델링,다음 중 ERD에 대한 설명으로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j365-1.png,,주문일자는 고객이 주문을 한 일자로 배송이 완료된 후에 갱신되지 않는다.,주문과 제품의 관계에서 하나의 제품에는 하나의 주문만이 존재한다.,배송지는 여러 개의 주문을 배송할 수 있으며 배송지가 없을 수도 있다.,"고객번호가 없으면 주문을 할 수 없으며, 한 명의 고객은 여러 개의 주문을 할 수 있고 주문을 하지 않을 수도 있다.",ERD만 보고 답을 해야 하기 때문에 하나의 제품에 여러 개의 주문이 관계된다.,2
43,2과목,집합 연산자,"테이블이 아래와 같을 때, 다음 집합연산자 수행 결과로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j655-1.png,"SELECT * FROM (SELECT COL1, COL2 FROM TAB1 UNION SELECT COL1, COL2 FROM TAB2) MINUS SELECT COL1, COL2 FROM TAB3;",,,,,먼저 TAB1과 TAB2의 UNION 결과는 아래와 같다. 이들 중 TAB3의 결과를 빼면 3번 결과가 같다.,3
44,2과목,윈도우 함수,아래 SQL 문장 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j755-1.png,"SELECT EMPNO, ENAME, DEPTNO, SAL, LAG(SAL, 2, 0) OVER(PARTITION BY DEPTNO ORDER BY SAL) LAG_VALUE FROM EMP;",,,,,같은 DEPTNO내에서 SAL이 낮은 순서대로 이전 이전 값을 가져오는 문장이다. 가져올 값이 없을 경우 0으로 리턴 한다.,3
45,2과목,윈도우 함수,"아래 데이터 모델에서 활동점수가 높은 고객을 게임상품ID별로 10등까지 선별하여 사은행사를 진행하려고 한다. 다음 SQL 중 가장 적절한 것은? (단, 활동점수가 동일한 고객은 동일등수로 한다. 아래 결과 예제 참조)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j132-1.png,,"SELECT 게임상품ID, 고객ID, 활동점수, 순위 FROM (SELECT RANK() OVER(PARTITION BY 게임상품ID ORDER BY 활동점수 DESC) AS 순위 ,고객ID,게임상품ID, 활동점수 FROM 고객활동)","SELECT 게임상품ID, 고객ID, 활동점수, 순위 FROM (SELECT RANK() OVER(ORDER BY 활동점수 DESC) AS 순위 ,고객ID, 게임상품ID, 활동점수 FROM 고객활동) WHERE 순위 <= 10;","SELECT 게임상품ID, 고객ID, 활동점수, 순위 FROM (SELECT DENSE_RANK() OVER(PARTITION BY 게임상품ID ORDER BY 활동점수 DESC) AS 순위 ,고객ID, 게임상품ID, 활동점수 FROM 고객활동) WHERE 순위〈= 10;","SELECT 게임상품ID, 고객ID, 활동점수, 순위 FROM (SELECT DENSE_RANK() OVER(ORDER BY 활동점수 DESC) AS 순위 .고객ID, 게임상품ID, 활동점수 FROM 고객활동) WHERE 순위 <= 10;","게임상품별로 고객 목록을 추출하기위해서는 OVER절에 ""PARTITION BY 게임상품ID”를 적용하여 게임상품별 활동점수로 순위가 추출될 수 있도록 하여야 한다. RANK WINDOW 함수는 OVER절의 ORDER BY에 대한 결과에 따라 동일한 값을 동일한 등수로 처리 함과 동시에 중간 순위를 비우는 반면, DENSE RANK WINDOW 함수는 중간 순위를 비우지 않는다.",1
46,2과목,집계 함수,다음의 SQL문을 실행한 결과를 쓰시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j358-1.png,"SELECT SUM(CASE WHEN COL1 ='A' THEN 1 END) AS SUM1, SUM(CASE WHEN COL3 < 20000 THEN 1 END) AS SUM2 FROM Mytest;","4,8","3,7","2,6","1,5","SUM1은 COL1 ='A'조건을 만족하는 1,2,3행을 각각 1로 되돌리고 합계를 계산하기 때문에 3이 된다. COL2 < 20000 조건은 모든 행이 만족하고 1을 되돌리므로 합계는 7이 된다.",2
47,2과목,JOIN,다음 출력 결과를 얻기 위한 SQL 문장으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j794-1.png,,"SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.EMPNO = E2.MGR(+) ORDER BY E1.EMPNO;","SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.EMPNO = E2.MGR ORDER BY E1.EMPNO;","SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO(+) ORDER BY E1.EMPNO;","SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;","SELECT절을 보면 E2.ENAME이 매니저이름이다. 따라서 E1의 MGR(매니저번호)을 갖는 E2에서의 EMPNO가 E1 사 원의 매니저라고 볼 수 있다. 또한, 매니저가 없는 MARTIN도 출력을 하기 위해서는 LEFT OUTER JOIN이 필요하므 로 오라클 표준으로 E1의 반대쪽 컬럼에 (+) 기호를 붙여주면 된다.",3
48,2과목,집계 함수,다음 주어진 테이블에 대해서 아래의 SQL문을 수행한 행수로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j513-1.png,"SELECT COUNT(COL1), COUNT(COL2) FROM ( SELECT DISTINCT COL1, COL2 FROM TEST40 );","3,3","2,2","2,1","1,2","DISTINCT 명령어로 중복된 COL1, COL2값은 제외되어 COL1, COL2이 (조조,1), (조조,2),(조조,3)이 된다.",1
49,2과목,계층형 질의,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j761-1.png,"SELECT SYS_CONNECT_BY_PATH(DNAME, '-') FROM DEPARTMENT WHERE DEPTNO = 103 START WITH PART IS NULL CONNECT BY PART = PRIOR DEPTNO ;",-컴퓨터정보학부,-소프트웨어공학과-컴퓨터정보학부,-컴퓨터정보학부-소프트웨어공학과,-소프트웨어공학과,최상위 학과인 컴퓨터정보학부와 인문사회학부로부터 시작하여 하위 학과들을 연결한 후 루트노드로부터의 연결과 정을 '-'로 이어서 출력하는 과정이다. DEPTNO가 103번인 소프트웨어공학과의 상위학과는 컴퓨터정보학부이다.,3
50,2과목,윈도우 함수,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j608-1.png,"SELECT 주문번호, 일자, SUM(주문금액) OVER(ORDER BY 일자) AS 주문금액, DENSE_RANK() OVER(PARTITION BY 지점 ORDER BY 주문금액) AS 순위 FROM 주문내역;",,,,,"SUM의 경우 ORDER BY 사용 시 ORDER BY 컬럼 순서대로 누적 합을 계산하는데, 이때 범위는 RANGE가 기본이다. RANGE란 ORDER BY 절에 명시된 컬럼의 값이 같을 경우 하나의 그룹으로 묶어서 누적 합을 계산하는 범위를 말한다. 따라서 2024.01.02 값이 두 개이므로 각각 1000과 2000이 먼저 3000으로 결합되어 두 번째와 세 번째 행의 누적 합이 둘 다 4000이 된다. DENSE_RANK의 경우 동순위 발생 뒤 순위가 연속적으로 출력되므로 주문번호가 3인 행의 순위는 2위가 된다.",2
51,2과목,JOIN,"아래와 같은 테이블 TAB1, TAB2가 있을 때 아래 SQL의 결과 건수를 알맞게 나열한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j209-1.png,,"2,4,3,7,12","2,3,4,5,12","2,4,5,3,12","2,4,3,5,12","TAB1 테이블에는 행이 4개, TAB2 테이블에는 행이 3개가 있다. KEY 칼럼을 사용해서 INNER JOIN을 하면 같은 것만 찾는다. 따라서 TAB1와 TAB2 테이블의 KEY 칼럼에서 'B'와 'C'가 같기 때문에 2개의 행이 출력된다.",4
52,2과목,집합 연산자,"다음 중 아래에서 테이블 T1, T2에 대한 가, 나 두 개의 쿼리 결과 조회되는 행의 수로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j105-1.png,,"가: 3개, 나: 5개","가: 3개, 나: 3개","가: 5개, 나: 5개","가: 5개, 나: 3개","(가) SELECT A, B, C FROM R1 UNION ALL SELECT A, B, C FROM R2; (중복 레코드 유지, 정렬 안함) (나)SELECT A, B, C FROM R2 UNION SELECT A, B, C FROM R2; (중복 레코드 제거함, 정렬 발생)",4
53,2과목,집합 연산자,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j703-1.png,SELECT SUM(COL2) FROM TAB1 WHERE COL2 < ANY(SELECT FARE FROM TAB2);,1000,600,300,100,"ANY는 작다와 만나면 값들 중 최댓값을 리턴한다. 따라서, 메인쿼리 WHERE절은 COL2 < 350 이 되므로 A, B, C들의 COL2의 총 합은 600이 된다.",2
54,2과목,,다음 중 아래 데이터를 가지고 있는 EMP_Q 테이블에서 세개의 SQL 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j74-1.png,,"0,에러 발생, NULL","에러 발생, 에러 발생, NULL","0, 에러 발생, 에러 발생","0, NULL, NULL",,1
55,2과목,ER 모델링,다음의 ERD에 대한 설명으로 가장 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j404-1.png,,"학생 엔터티의 기본키는 학번이고 이름,나이,주소는 속성이다.",학생과 과목 엔터티를 조인 시에 카텐시안 곱이 발생하여 2명의 학생이 2개의 과목과 조인하면 2개의 행이 조회된다.,"학생과 과목 간의 관계에서 수강 신청이라는 엔터티를 추가해서 M:N을 1:N, N:1로 해소해야 한다.",한 명의 학생은 여러 개의 과목과 매핑된다.,M:N 관계는 카텐시안 곱이 발생하고 2개 행과 2개의 행을 조인하면 2*2 = 4개의 행이 조회된다.,2
56,2과목,ER 모델링,다음 중 아래 ERD에 대한 설명으로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j488-1.png,,"주문, 상품은 비식별 관계로 부모가 없어도 자식이 생길 수 있다.",주문은 상품이 없을 수 있다.,주문은 상품 1개 이상 가질 수 있다.,상품은 주문을 하나 이상 반드시 가져야 한다.,상품은 주문을 한 개 이상 반드시 가져야 하는 것이 아니라 안 가질 수도 있다.,4
57,2과목,JOIN,다음 결과는 2개의 테이블을 어떤 join으로 진행한 것인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j241-1.png,,Full Outer Join,Left Outer Join,Right Outer Join,Natural Join,위의 결과를 보면 EMPNO와 DEPTNO 각각에 서로 없는 것이 있다. 그래서 FULL OUTER JOIN이 된다.,1
58,2과목,계층형 질의,다음은 계층형 쿼리를 수행하는 SQL문이다. ( )에 해당되는 것으로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j279-1.png,SELECT * FROM Mytest START WITH ( ㄱ ) IS NULL CONNECT BY PRIOR ( ㄴ ) AND today BETWEEN '2017-01-01' AND '2022-12-31' ORDER SIBLINGS BY empid;,(ㄱ) mgrid (ㄴ) mgrid = empid,(ㄱ) mgrid (ㄴ) empid = mgrid,(ㄱ) empid (ㄴ) mgrid = empid,(ㄱ) empid (ㄴ) empid = mgrid,mgrid가 NULL인 값을 시작해서 empid로 조회를 전개하는 순방향 조회를 하고 있다. 순방향 전개를 하면서 empid로 정렬한다.,2
59,2과목,집계 함수,다음 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j690-1.png,SELECT COUNT(COL1) RESULT FROM TAB1 WHERE COL3 < 100 GROUP BY COL1; SELECT COUNT(COL1) RESULT FROM TAB1 WHERE COL1 IS NOT NULL GROUP BY COL1 HAVING SUM(COL2) > 500;,,,,,"첫 번째 문장은 조건에 만족하는 COL1값이 NULL이므로 NULL 그룹이 리턴된다. 따라서 COUNT를 하면 0이 출력되며, 두 번째 문장은 HAVING 조건에 만족하는 그룹이 없으므로 공집합이 출력되어 COUNT 결과가 NULL이 된다.",2
60,2과목,JOIN,다음 중 아래 테이블들을대상으로 SQL 문장을 수행한 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j95-1.png,,,,,,,4
61,2과목,윈도우 함수,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j757-1.png,"SELECT RATIO_TO_REPORT(COL2) OVER() AS C1, CUME_DIST() OVER(ORDER BY COL2) AS C2, ROUND(PERCENT_RANK() OVER(ORDER BY COL2),2) AS C3 FROM TAB1;",,,,,"RATIO_TO_REPORT는 총 합 기준 COL2의 값의 크기에 대한 차지 비율을 출력, CUME_DIST는 COL2 순서대로 각 행의 상대적 누적 위치 출력, PERCENT_RANK는 COL2 순서대로 각 행의 누적 분위수(0~1 사이)를 출력한다.",4
62,2과목,집계 함수,다음 출력 결과를 갖도록 하는 빈칸의 문장으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j707-1.png,"SELECT EMPNO, ENAME, DEPTNO, SAL, SUM(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL ____________________) AS RESULT FROM EMP;",ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING,ROWS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING,RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING,RANGE BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING,"누적합의 범위가 각 행마다 이전행과 현재행, 다음행을 연산하고 있으므로(JONES 기준 1100 + 2975 + 3000 = 7075) 1 PRECEDING AND 1 FOLLOWING 이며, SAL이 같은 SCOTT과 FORD의 누적합이 각각 다르게 계산되었으므로 ROWS가 적절하다.",1
63,2과목,DML,다음의 테이블이 있을 경우 SQL을 수행하였을 때 출력결과를 순서대로 나열한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j429-1.png,SELECT CASE WHEN C1=1 THEN 10 WHEN C1=2 THEN 20 ELSE C1 END FROM Mytest;,"1,2,30","10,20,30","10,20,3","1,2,3",CASE 문의 조건문에 따라서 1은 10으로 2는 20으로 입력된다.,3
64,2과목,계층형 질의,다음 중 아래와 같은 사원 테이블에 대해서 SQL을 수행하였을 때의 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j109-1.png,,,,,,"CONNECT BY 절에 작성된 조건절은 WHERE 절에 작성된 조건절과 다르다. START WITH 절에서 필터링된 시작 데이터는 결과목록에 포함되어지며, 이후 CONNECT BY 절에 의해 필터링 된다. 그러 므로 매니저 사원번호가 NULL인 데이터는 결과목록에 포함되며, 이후 리커시브 조인에 의해 입사일자가 필터링 된다.",4
65,2과목,집계 함수,아래의 테이블에 대해서 주어진 SQL문을 수행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j550-1.png,"SELECT A.jumin as ""주문"", B.custrank as ""고객등급"" FROM (SELECT jumun, SUM(price) AS Total FROM test34_1 GROUP BY jumun) A, test34_2 B WHERE A.Total BETWEEN B.minprice AND B.maxprice;",,,,,"먼저 FROM절에 있는 inline view의 실행 결과는 20, 7500과 10, 5000의 합계가 조회된다. 그리고 test34_2의 BETWEEN구로 조회하면 10번 VIP가 조회된다.",2
66,2과목,집계 함수,다음 주어진 테이블에서 아래와 같은 결괏값을 반환하는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j199-1.png,,"select count(case when 반=1 then 1 end) as ""결괏값"" count(case when 반=2 then 1 end) as b, count(case when 반=3 then 1 end) as c from SQLD_67;","select 반, count(distinct 이름) AS ""결괏값"" FROM SQLD_67 group by 반;","select 반, count(1) AS ""결괏값"" FROM SQLD_67 group by 반;","select 반, count(*) AS ""결괏값"" FROM SQLD_67 group by 반;",② 번에서 주어진 테이블을 '반'속성별로 그룹화한 다음 각 '반' 속성별 행의 수를 count하는데 distinct 인자로 중복되는 이름값은 제외하고 count를 수행하여 결괏값과 같이 반환된다.,2
67,2과목,집계 함수,다음의 SQL문을 실행한 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j343-1.png,"SELECT SUM(A.N1) FROM MytestA A, MytestB B WHERE A.V1 <> B.V1;",9,12,32,10,,2
68,2과목,집계 함수,다음 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j751-1.png,"SELECT SUM(E2.SAL) AS RESULT FROM EMP E1, EMP E2 WHERE E1.HIREDATE >= E2.HIREDATE GROUP BY E1.ENAME;",,,,,"셀프조인을 통해 각 행마다 입사일이 작거나 같은 모든 행을 출력하는 쿼리로, 각 행마다의 누적 급여 총 합을 출력 하게 된다.",2
69,2과목,,다음의 예에서 결괏값이 다른 하나는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j250-1.png,,SELECT count(고객) FROM SQLD_13 WHERE 거래내역 IS NULL;,SELECT NULL*NULL FROM SQLD_13;,SELECT NULL*3 FROM SQLD_13;,SELECT NULL*2 FROM SQLD_13;,②③④ 번은 모두 SELECT NULL FROM SQLD_13; 과 같은 SQL문으로 모두 NULL을 반환하는데 ①번은 거래내역이 NULL인 고객의 수를 구하는 SQL문으로 결괏값 2를 반환한다.,1
70,2과목,JOIN,"다음 ERD를 보고, 고객의 성별로 서비스 이용횟수와 이용금액의 총합을 출력하는 SQL로 적절하지 않은 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j605-1.png,,"SELECT 고객.성별, COUNT((SELECT 서비스번호 FROM 서비스 WHERE 서비스구매.서비스번호 = 서비스.서비스번호)) AS CNT, SUM((SELECT 가격 FROM 서비스 WHERE 서비스구매.서비스번호 = 서비스.서비스번호)) AS SUM_PRICE FROM 고객 INNER JOIN 서비스구매 ON 고객.고객번호= 서비스구매.고객번호 GROUP BY 고객.성별;","SELECT 고객.성별, COUNT(I.SNO) AS CNT, SUM(I.가격) AS SUM_PRICE FROM 고객 INNER JOIN (SELECT 서비스구매.고객번호 AS GNO, 서비스.서비스번호 AS SNO, 서비스.가격 FROM 서비스구매 INNER JOIN 서비스 ON 서비스구매.서비스번호 = 서비스.서비스번호) I ON 고객.고객번호= I.GNO GROUP BY 고객.성별;","SELECT 고객.성별, COUNT(고객.고객번호) AS CNT, SUM(서비스.가격) AS SUM_PRICE FROM 고객 LEFT OUTER JOIN 서비스구매 ON 고객.고객번호= 서비스구매.고객번호 LEFT OUTER JOIN 서비스 ON 서비스구매.서비스번호 = 서비스.서비스번호 GROUP BY 고객.성별;"," SELECT 고객.성별, COUNT(서비스.서비스번호) AS CNT, SUM(서비스.가격) AS SUM_PRICE FROM 고객, 서비스구매, 서비스 WHERE 고객.고객번호= 서비스구매.고객번호 AND 서비스구매.서비스번호 = 서비스.서비스번호 GROUP BY 고객.성별;","고객과 서비스 구매 관계에서 고객은 필수, 서비스 구매는 선택적 관계이므로 LEFT OUTER JOIN을 하면 서비스 구매를 하지 않은 고객의 서비스 구매 정보가 NULL로 출력된다. 따라서 이때, 고객의 성별로 서비스 구매나 서비스 테이블의 컬럼을 COUNT할 경우 NULL은 세지 않기 때문에 정상적으로 구매를 한 고객 수가 리턴될 텐데 2번의 경우 고객 테이블의 고객 번호를 세기 때문에 성별 고객 수가 출력된다.",3
71,2과목,집계 함수,다음 보기의 결괏값을 얻기 위한 SQL문을 작성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j298-1.png,"SELECT ( ) AS A, ( ) AS B, ( ) AS C from Mytest","max(COL1), max(COL2), max(COL1)","max(COL1), min(COL2), sum(COL2)","max(COL1), min(COL2), sum(COL1)","max(COL2), min(COL2), sum(COL1)","A 속성은 COL1의 최댓값, B 속성은 COL2의 최솟값, C 속성은 COL1 속성의 합이다.",3
72,2과목,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j595-1.png,SELECT COUNT(*) AS RESULT FROM TAB1 WHERE COL1 = 200 GROUP BY COL1; SELECT SUM(COL2) AS RESULT FROM TAB1 WHERE COL1 = 100; SELECT COUNT(COL1) AS RESULT FROM TAB1 WHERE COL3 = 400;,,,,,"첫 번째 문장은 COL1 = 200 조건에 만족하는 값이 없고, 공집합을 GROUP BY 하면 아무것도 출력되지 않는다. 따라서 공집합에 대한 COUNT 결과는 0 이 아닌 공집합이 출력되므로 컬럼명만 출력되는 형태로 리턴된다. 두 번째 문장은 첫 번째 행에 대한 SUM(COL2)를 출력하게 되는데, 첫 번째 행의 COL2 값이 NULL 이므로 NULL 이 출력된다. NULL 로만 구성된 데이터의 SUM, AVG, MIN, MAX 등의 결과는 NULL 이 리턴되며 COUNT 만 0 으로 출력된다. 따라서 세 번째 문장의 출력값은 0 이 된다.",1
73,2과목,집계 함수,다음 문제에 주어진 결괏값을 반환하는 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j289-1.png,,"SELECT COUNT(CASE WHEN CLASS ='A' THEN 1 END) AS ""Result"" COUNT(CASE WHEN CLASS ='B' THEN 1 END) AS B, COUNT(CASE WHEN CLASS ='C' THEN 1 END) AS C FROM Mytest;","SELECT CLASS, count(1) AS ""Result"" FROM Mytest GROUP BY CLASS;","SELECT CLASS, count(distinct NAME) AS ""Result"" FROM mytest GROUP BY CLASS;","SELECT CLASS, count(*) AS ""Result"" FROM Mytest GROUP BY CLASS;",③번 보기에서 주어진 테이블을 'CLASS' 속성별로 그룹화한 다음 각 'CLASS' 속성별 행의 수를 count하는데 DISTINCT 인자로 중복되는 NAME 값은 제외하고 count를 수행하여 결괏값이 반환된다.,3
74,2과목,JOIN,다음의 ( )에 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j521-1.png,,CROSS JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,SELF JOIN,5개의 행이 총 25개의 행으로 증가하였으므로 5*5=25의 CROSS JOIN을 수행한 것이다.,1
75,2과목,트랜잭션 관리,"테이블 A에 대해 아래와 같은 SQL을 수행하였을 때 테이블 A의 ID '001'에 해당하는 최종 VAL의 값이 ORACLE에서는 200, SQL Server에서는 100이 되었다. 다음 설명 중 가장 부적절한 것은? (단, AUTO COMMIT은 FALSE로 설정되어 있다)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j61-1.png,,"SQL Server에서는 ROLLBACK 실행으로 인하여 UPDATE가 취소되 었으며, 최종적으로 B 테이블은 생성되지 않았다.","ORACLE에서는 CREATE TABLE 문장 수행에 의해 VAL 값은 200이 되었지만, ROLLBACK 실행으로 인하여 최종적으로 B 테이블은 생성 되지 않았다.",SQL Server에서는 ROLLBACK 문장에 의해 UPDATE가 취소되어 VAL 값은 100이 되었다.,"ORACLE에서는 CREATE TABLE 문장을 수행한 후, 묵시적으로 COMMIT이 수행 되어 VAL 값은 200이 되었다.",,2
76,2과목,ER 모델링,아래의 IE 표기법에서 고객 엔터티의 고객번호와 계좌마스터의 고객번호는 어떤 식별자에 해당되는가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j361-1.png,,"단일 식별자, 복합 식별자","단일 식별자, 인조 식별자","내부 식별자, 외부 식별자","본질 식별자, 복합 식별자","내부 식별자란, 엔터티 내부에서 스스로 생성되는 식별자이고 외부 식별자는 다른 엔터티의 관계로 인하여 만들어지는 식별자이다.",3
77,2과목,,다음 중 아래 각각 3개의 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j76-1.png,,"10, 10, 10","10, 20, 20","20, 10, 10","20, 20, 20",,2
78,2과목,,"어느 기업의 직원 테0|블(EMP)이 직급(GRADE) 별로 사원 500명, 대리 100명, 과장 30명, 차장 10명, 부장 5명, 직급이 정해지지 않은 (NULL) 사람 25명으로 구성되어 았을 때, 다음 중 SQL문을 SQL1)부터 SQL3)까지 순차적으로 실행한 결과 건수를 순서대로 나열한 것으로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j77-1.png,,"670, 40, 6","645, 15, 6","645, 40, 5","670, 15, 5",,2
79,2과목,서브쿼리,릴레이션 'employee'와 'department'에서 다음 SQL 질의문의 수행 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j215-1.png,"SELECT e.dno, d.dname, e.ename, e.score FROM employee e, department d WHERE e.dno = d.dno and (e.dno, score) IN (SELECT dno, max(score) FROM employee GROUP BY dno);","{(100,영업,Hong,80), (100,영업,Lee,90),(200,개발,Kim,90),(200,개발,Kim,95),(600,null,Hong,65)}","{(100,영업,Lee,90)}","{(100,영업,Lee,90),(200,개발,Kim,95)}","{(100,영업,Lee,90),(200,개발,Kim,90),(300,서비스,Hong,65)}","서브쿼리만 실행하면 DNO와 MAX(SCORE) 값이 {100,90},{300,65},{200,95} 이다. IN 문을 사용해서 조인을 하므로 {(100,영업,Lee,90),(200,개발,Kim,95),(300,서비스,Hong,65)}가 조회된다.",4
80,2과목,DML,다음 주어진 테이블에서 아래의 SQL문을 수행하였을 때의 결괏값으로 올바른 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j203-1.png,,,,,,"해당 SQL문은 주어진 테이블인 SQLD_71에서 COL1, COL2, COL3 속성 순서대로 내림차순 정렬을 수행한다. 그래서 먼저 COL1에 대해서 내림차순 정렬을 수행하고 같은 COL1 값에 대해서는 COL2의 내림차순 정렬을 수행하고 같은 COL2 값에 대해서는 COL3을 기준으로 내림차순 정렬한다.",2
81,2과목,윈도우 함수,다음의 PREV_SAL은 어떤 윈도우 함수를 사용해야 하는가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j247-1.png,,LAST_VALUE,NTILE,LAG,LEAD,LAG() 윈도우 함수는 이전 행의 몇 번째 행 값을 가지고 올 수 있다.,3
82,2과목,서브쿼리,다음 SQL문의 실행 결과로 올바른 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j206-1.png,"SELECT DISTINCT DEPARTMENT_ID FROM HR.EMPLOYEES A WHERE A.DEPARTMENT_ID <= ALL (30,50);","10,20,30,40,50","10,20,30,40","10,20,30","10,20",ALL 연산자는 서브쿼리 값 모두가 조건에 만족하면 True를 반환한다.,3
83,2과목,계층형 질의,다음 중 아래의 TEST10 테이블에 대해서 SQL문을 수행하였을 때의 결과 건수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j533-1.png,"SELECT LPAD('**', (LEVEL-1)*2, ' ')|| EMPNO AS EMP, NAME FROM TEST10 WHERE EMPNO <> 3 START WITH EMPNO = 3 CONNECT BY EMPNO = PRIOR MANAGER;",3,2,1,0,위의 SQL에서 WHERE 조건에 의하여 EMPNO 3번은 조회에서 제외된다. 그리고 EMPNO가 3번으로 시작하여 계층형 조회를 한다. 따라서 EMPNO 1번과 2번 2개의 행이 조회된다.,2
84,2과목,집계 함수,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j742-1.png,"SELECT COL2, SUM(COL3) AS C1, MIN(COL3) AS C2, MAX(COL3) AS C3 FROM TAB1 WHERE COL1 > 100 GROUP BY COL2;",,,,,"COL1 > 100 조건에 만족하는 값은 COL1이 200, 300, 400, 500, 300인 행이다. 이들을 COL2에 의해 그룹핑을 하면 A, B, NULL그룹이 리턴되며, NULL일 때의 SUM(COL3), MIN(COL3)은 모두 20이 리턴된다.",4
85,2과목,JOIN,SQL의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j648-1.png,SELECT COUNT(TAB1.NO) FROM TAB1 LEFT OUTER JOIN TAB2 ON TAB1.NO = TAB2.NO; SELECT COUNT(DISTINCT TAB1.CODE) FROM TAB1 RIGHT OUTER JOIN TAB2 ON TAB1.NO = TAB2.NO;,"9, 3","9, 2","7, 3","7, 2","LEFT OUTER JOIN의 결과 TAB1의 NO값이 1, 2, 4, 4, 6, 7, 3인 총 7개의 행이 나오게 되고, RIGHT OUTER JOIN의 결과로 TAB1의 CODE값이 A, B, B, B, NULL, NULL, NULL이 출력되어 DISTINCT 수는 총 2건이다.(NULL은 세지 않는다)",4
86,2과목,JOIN,다음 SQL 구문의 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j646-1.png,"SELECT COUNT(TAB1.COL1) FROM TAB1, TAB2 WHERE TAB1.COL2 = TAB2.COL2(+);",5,4,3,2,"(+) 가 붙은 반대편 테이블이 기준이 되는 테이블로 TAB1 테이블을 기준 테이블로 LEFT OUTER JOIN이 수행된다. 즉, 조인 조건이 일치하지 않아도 TAB1은 생략되서는 안되므로 INNER JOIN의 결과에 TAB1의 COL2가 NULL, C인 경우 추가적으로 출력되므로 총 5건이 나온다.",1
87,2과목,DML,다음 주어진 테이블에 대해서 아래의 SQL문을 실행하였을 때 결과 행의 수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j548-1.png,"SELECT * FROM TEST32 WHERE (COL1,COL2) IN (10000,'ABC'));",3,2,1,,"보기의 SQL문은 COL1, COL2가 각각 10000, 'ABC'인 행만을 조회하는 SQL문으로 1번째 행만 조회된다.",3
88,2과목,집합 연산자,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j741-1.png,"SELECT COUNT(COL1) FROM TAB1 WHERE COL2 NOT BETWEEN 2000 AND 3000 AND COL3 NOT IN (10, 20);",2,1,0,,"2000과 3000사이 값이 아니면 2000미만, 3000초과가 된다. 이들 중 COL3이 10, 20과 일치하지 않는 행은 존재하지 않는다. 따라서 COUNT 결과는 0이다. 조건에 만족하지 않더라도 COUNT는 NULL이 아닌 0을 리턴한다.",3
89,2과목,집합 연산자,다음 중 SQL에서 실행 결과가 같은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j349-1.png,"(1) SELECT A ID, B.ID FROM MytestA A FULL OUTER JOIN MytestB B ON A.ID = B.ID (2) SELECT A ID, B.ID FROM MytestA A LEFT OUTER JOIN MytestB B ON A.ID = B.ID UNION SELECT A ID, B.ID FROM MytestA A RIGHT OUTER JOIN MytestB B ON A.ID = B.ID (3) SELECT A ID, B.ID FROM MytestA A, MytestB B WHERE A.ID = B.ID UNION ALL SELECT A.ID, NULL FROM MytestA A WHERE NOT EXISTS (SELECT 1 FROM MytestB B WHERE A.ID = B.ID) UNION ALL SELECT NULL, B.ID FROM MytestB B WHERE NOT EXISTS (SELECT 1 FROM MytestA A WHERE B.ID = A.ID)","1,2,3","2,3","1,3","1,2","보기 3개 모두 FULL OUTER JOIN과 동일한 결과를 반환한다. 즉, 교집합과 MytestA 및 MytestB의 차집합 모두가 조회된다.",1
90,2과목,집계 함수,다음 주어진 테이블들에 대해서 아래의 SQL문을 수행하였을 때 결과의 행수로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j510-1.png,"SELECT COUNT(*) ROWCNT FROM test36_1 a,test36_2 b WHERE a.ename LIKE b.condition;",6,4,3,0,,3
91,2과목,계층형 질의,다음과 같은 데이터 상황에서 계층형 질의절을 완성하기 위해 필요한 표현식은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j760-1.png,SELECT * FROM EMP START WITH EMPNO = '0001' CONNECT BY MGR = PRIOR EMPNO;,ORDER SIBLINGS BY,NOCYCLE,SYS_CONNECT_BY_PATH,CONNECT_BY_ROOT,위 데이터는 SMITH와 ALLEN이 서로 순환구조를 가지기 때문에 출력이 불가하다. 따라서 출력을 원할 경우 CONNECT BY 뒤에 NOCYCLE 옵션을 전달해야 한다.,2
92,2과목,DML,다음의 정렬 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j743-1.png,"SELECT ID FROM TAB1 ORDER BY CASE WHEN ID > 'B' THEN 'A' ELSE ID END, ID;",,,,,"문자 B보다 큰 ID는 BI와 BAA이다. 따라서 ID 는 CASE문에 의해 순서대로 AA, ABC, A, B, A 변환되어 두번째 정렬 기준인 ID 값과 함께 정렬된다. 문자 정렬은 왼쪽부터 비교하여 값이 같을 때까지 비교하여 더 큰 값이 큰 문자열이 되므로 최종 정렬 결과는 정렬 결과는 A(BAA), A(BI), AA, ABC, B 가 된다.",2
93,2과목,JOIN,"아래의 EMP 테이블과 DEPT 테이블에서 밑줄 친 속성은 주키이며 EMP.C는 DEPT와 연결된 외래키이다. EMP 테이블과 DEPT 테이블을 LEFT, FULL, RIGHT 외부조인(outer join)하면 생성되는 결과 건수로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j97-1.png,,"3건,4건,5건","3건,4건,4건","4건,5건,3건","3건,5건,4건",,4
94,2과목,,"다음 중 아래와 같은 문장으로 ,학생테이블을 생성한 후,유효한 튜플(Tuple) 들을 삽입하였다. SQL 1, SQL 2 문장의 실행 결과로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j48-1.png,,"SQL1, SQL2 문장의 실행 결과는 다를 수 있으며, 그 이유는 학번 속성(Attribute)에 널(Null) 값이 존재할 수 있기 때문이다.","SQL1, SQL2 문장의 실행 결과는 항상 같다.","SQL1, SQL2 문장의 실행 결과는 항상 다르다.","SQL1, SQL2 문장의 실행 결과는 다를 수 있으며, 그 이유는 장학금 속성(Attribute)에 널(Null)값이 존재할 수 있기 때문이다.",,2
95,2과목,서브쿼리,다음 서브쿼리 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j700-1.png,"SELECT SUM(SAL) FROM EMPLOYEES WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMPLOYEES GROUP BY DEPTNO);",7500,4500,3000,1500,"다중컬럼 서브쿼리를 사용하여 각 부서별로 최대급여를 받는 직원들의 급여 총합을 출력하고 있다. 10번 부서는 1500, 20번 부서는 3000이지만 FORD와 MILLER 둘 다 출력되므로 총 합은 7500이다.",1
96,2과목,윈도우 함수,"다음의 SQL문을 실행했을 때 아래 결과가 조회되도록 (ㄱ), (ㄴ)에 들어갈 숫자를 고르시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j353-1.png,"SELECT COL1, COL2, COL3, LEAD(COL3, (ㄱ), (ㄴ)) OVER(PARTITION BY COL1 ORDER BY COL3 ) AS Result FROM Mytest","ㄱ : 1, ㄴ : 4","ㄱ : 1, ㄴ : 9","ㄱ : 2, ㄴ : 4","ㄱ : 2, ㄴ : 9","COL3 값에서 두 번째 다음값이 Result 값으로 출력되니 (ㄱ)에는 숫자 2가 와야 하고, 현재 COL3값의 두번째 다음값이 해당 파티션내에서 존재하지 않을 경우에는 기본값으로 9를 출력하니 (ㄴ)에는 숫자 9가 와야한다.",4
97,2과목,,다음 보기의 SQL문을 실행 했을 때 결괏값이 다른 하나는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j294-1.png,,"select NVL(a.COL1,-1) as data from Mytest a;","select DECODE(a.COL1, null,-1,a.col1) as data from Mytest a;",select case when a.COL1 is null then -1 else 0 end as data from Mytest a;,select case a.COL1 when null then -1 else 0 end as data from Mytest a;,"나머지 보기는 모두 COL1 값이 NULL일 때 -1을 반환하는데 ④번 보기만 COL1값이 NULL일 때 0 을 반환한다. 즉, CASE문으로 NULL을 비교할 때 알수 없음이 된다.",4
98,2과목,JOIN,다음은 Oracle 데이터베이스에서 사용하는 Outer Join의 예제이다. 빈칸을 채워 Oracle의 Outer Join을 표준 ANSI SQL로 변경하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j305-1.png,,CROSS JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,FULL OUTER JOIN,,3
99,2과목,JOIN,이래는 어느 회사의 정산 데이터 모델의 일부이며 고객이 서비스를 사용한 시간대에 따라 차등 단가를 적용하려고 한다. 다음 중 시간대별사용량 테아블을 기반으로 고객별 사용금액을 추출하는 SQL으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j93-1.png,,"SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B ON (A. 고객ID = B.고객ID) BETWEEN JOIN 시간대구간 C GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;","SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B ON (A.고객ID = B.고객ID) INNER JOIN 시간대구간 C ON B.사용시간대 BETWEEN C.시작시간대 AND C.종료시간대 GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;","SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B INNER JOIN 시간대구간 C ON (A.고객ID = B.고객ID AND B.시용시간대 BETWEEN C.시작시간대 AND C.종료시간대) GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;","SELECT A.고객ID, A.고객명, SUM(B.사용량 * C. 단가) AS 사용금액 FROM 고객 A INNER JOIN 시간대별사용량 B ON (A.고객ID = B.고객ID) INNER JOIN 시간대구간 C ON (B.사용시간대〈= C.시작시간대 AND B.사용시간대〉= C.종료시간대) GROUP BY A.고객ID, A.고객명 ORDER BY A.고객ID, A.고객명;",,2
100,2과목,JOIN,다음 SQL 구문의 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j645-1.png,SELECT COUNT(A.COL2) FROM TAB1 A JOIN TAB2 B ON A.COL2 = B.COL2;,3,2,1,0,"NULL 끼리는 동등비교 조건에 참으로 리턴되지 않는다. TAB1의 COL2값이 A인 경우 TAB2의 1건, B인 경우 2건, C의 경우 조건에 만족하는 값이 없으므로 INNER JOIN에서는 생략된다. 따라서 총 3건이 출력된다.",1
101,2과목,,다음 주어진 테이블에서 SELECT문을 수행하였을 때 결괏값으로 다른 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j201-1.png,,"select nvl(A.COL1,-1) as C4 from A;","select decode(A.COL1, null, -1, A, COL1) as C3 from A;",select case when A.COL1 is null then -1 else 0 end as C2 from A;,"select case A,COL1 when null then -1 else 0 end as C1 from A;",나머지 보기는 모두 COL1 값이 NULL일 때 -1을 반환하는데 ④번 보기만 COL1 값이 NULL일 때 0을 반환한다. null은 어떤 값과 비교하면 알수없음이므로 is null을 사용해야 한다.,4
102,2과목,집합 연산자,다음의 SQL문 중에서 결과가 동일한 하나의 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j470-1.png,"select * from kpipool where (subkpi, mainkpi) in((20,10),(0,30));","select * from kpipool where (subkpi, mainkpi) in ((20,30),(30,40));","select * from kpipool where (subkpi, mainkpi) in ((10,20),(20,30));","select * from kpipool where subkpi in (20,10);",select * from kpipool where subkpi = 20;,"④번의 SQL문 subkpi가 20번인 행을 조회한다. 그리고 문제에서 제시한 SQL문도 in구로 (20,10)을 사용했으므로 똑같이 subkpi가 20인 행이 조회된다.",4
103,2과목,JOIN,아래 결과를 출력하기 위해 빈칸에 들어갈 문장으로 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j653-1.png,,"SELECT 고객.고객번호, 상품.상품명 FROM 고객, 상품 ON 고객.포인트 >= 상품.최소포인트(+);","SELECT 고객.고객번호, 상품.상품명 FROM 고객 JOIN 상품 ON 고객.포인트 BETWEEN 상품.최소포인트 AND 상품.최대포인트;","SELECT 고객.고객번호, 상품.상품명 FROM 고객 INNER JOIN 상품 ON 고객.포인트 <= 상품.최대포인트;","SELECT 고객.고객번호, 상품.상품명 FROM 고객 INNER JOIN 상품 ON 고객.포인트 >= 상품.최소포인트;",결과표를 보면 고객이 보유한 포인트에 맞춰서 상품을 출력한 것을 알 수 있다. 따라서 고객이 보유한 포인트가 상품 테이블의 최소포인트와 최대포인트 사이에 있는 조건을 갖는 쿼리는 3번이다.,2
104,2과목,JOIN,아래는 어느 회사의 생산설비를 위한 데이터 모델의 일부에 대한 설명으로 가장 적절한 것을 2개 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j91-1.png,,"SELECT C.컨텐츠 ID, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A.고객ID = #custId# AND A.고객ID = B.고객ID) INNER JOIN 컨텐츠 C ON (B.컨텐츠 D = C.컨텐츠ID) WHERE B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD') AND NOT EXISTS (SELECT X.컨텐츠ID FROM 비선호컨텐츠 X WHERE X. 고객ID = B. 고객ID AND X. 컨텐츠ID = B. 컨텐츠ID;","SELECT C.컨텐츠 D, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A.고객ID = B.고객ID) INNER JOIN 컨텐츠 C ON (B.컨텐츠D = C.컨텐츠ID) LEFT OUTER JOIN 비선호컨텐츠 D ON (B.고객ID = D.고객ID AND B.컨텐츠ID = D.컨텐츠ID) WHERE A. 고객ID = #custId# AND B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD') AND D.컨텐츠ID IS NULL;","SELECT C.컨텐츠ID, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A.고객lD = #custId# AND A.고객ID = B.고객ID) INNER JOIN 컨텐츠 C ON (B.컨텐츠ID = C.컨텐츠ID) RIGHT OUTER JOIN 비선호컨텐츠 D ON (B.고객ID = D.고객ID AND B.컨텐츠ID = D.컨텐츠ID) WHERE B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD') AND B.컨텐츠ID IS NOT NULL;","SELECT C.컨텐츠ID, C.컨텐츠명 FROM 고객 A INNER JOIN 추천컨텐츠 B ON (A. 고객ID = B. 고객ID) INNER JOIN 컨텐츠 C ON (B. 컨텐츠 D = C. 컨텐츠 D) WHERE A. 고객ID = #custld# AND B. 추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD') AND NOT EXISTS (SELECT X.컨텐츠ID FROM 비선호컨텐츠 X WHERE X.고객ID = B.고객ID);",,"3,4"
105,2과목,집계 함수,아래 SQL에 대한 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j750-1.png,"SELECT SUM(TAB2.COL2) FROM TAB1, TAB2 WHERE TAB1.COL2 = TAB2.COL1;",900,800,700,600,"A는 100, 200을 B는 300, C는 300을 리턴한다. 따라서 총 합은 900 이다.",1
106,2과목,집계 함수,다음 SQL 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j591-1.png,SELECT COUNT(CODE) FROM TAB1 WHERE CODE LIKE '_1%' OR CODE LIKE '%A%';,8,7,5,4,"_1%' 조건은 두 번째 값이 1 인 문자열을 나타내므로 A1C1, B1A0, C1A1, D1B2 총 4 개이고, '%A%' 조건은 A 를 포함하는 문자열이므로 A1C1, A2C2, B1A0, C1A1 총 4 개이다. OR 조건은 두 집합의 합집합(중복값은 한 번만)이므로 총 8 개에서 두 조건을 모두 만족하는 A1C1, B1A0, C1A1 을 제외하면 총 5 개이다.",3
107,2과목,,다음 주어진 테이블에서 아래의 SQL문을 수행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j539-1.png,SELECT SUM(COL1+COL2+COL3+COL4) FROM test23; SELECT SUM(COL1) + SUM(COL2) + SUM(COL3) + SUM(COL4) FROM tset23;,"Null, Null","50, 240","Null, 240","50, Null","첫 번째 SQL문의 첫 번째 행인(10,10,10,20)은 NULL 값이 없으므로 합계 50이 조회된다. 그리고 두 번째 SQL문에서는 240의 합계가 조회된다. 즉, SUM 집계함수에서 NULL은 자동으로 제외한다.",2
108,2과목,ER 모델링,다음 주어진 그림에 해당하는 ERD 표기법으로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j489-1.png,,IDEFIX,IE Notation,IE,Barker,"ERD 표기법 중 IE 표기법은 관계의 1:N 관계에서 N쪽에 새발을 표시하고 선택, 필수 참여 관계에서 선택 참여에 O 필수 참여에 | 로 표시한다.",3
109,2과목,윈도우 함수,주어진 테이블에 대해서 아래와 같이 결과가 반환되도록 주어진 SQL문의 빈칸을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j517-1.png,"SELECT ( ) OVER(ORDER BY sal desc) as rank, name, deptname, position, sal FROM test44;",NTILE(),ROW_NUMBER(),DENSE_RANK(),RANK(),위의 결괏값에 동일한 RANK가 없으므로 ROW_NUMBER()가 되어야 한다.,2
110,2과목,집계 함수,다음 수행 결과를 차례대로 나열한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j799-1.png,"SELECT COUNT(*) C1, COUNT(COL1) C2, SUM(COL2) C3 , SUM(COL1+COL2+COL3) C4 FROM TAB1;","3, 2, NULL, NULL","3, 2, 2, NULL","3, 2, 2, 0","0, 2, 2, 0",COUNT(*)는 모든 컬럼의 값이 NULL일 때만 제외한다. COL1+COL2+COL3은 각 행마다 NULL을 포함하므로 모든 행이 값이 NULL이 된다.,2
111,2과목,JOIN,다음 두 테이블의 NATURAL JOIN을 수행한 결과의 출력 건수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j795-1.png,,5,4,3,2,"NATURAL JOIN은 컬럼명이 같은 컬럼끼리 값이 같은 조인을 완성한다. 따라서 양쪽 테이블의 COL2의 값이 같은 대상끼리 연결되는데, TAB1의 COL2가 10인 경우 1개, 20인 경우 2개, 30인 경우는 생략되며, NULL은 같다고 볼 수 없으므로 생략된다. 따라서 최종 출력되는 건수는 1 + 2+ 1 = 4건이다.",2
112,2과목,DML,아래와 같은 SQL문에 대해 삽입이 성공하는 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j53-1.png,,"4,5","3,4","2,3","1,2",,1
113,2과목,그룹 함수,다음 중 월별매출 테이블을 대상으로 아래 SQL을 수행한 결과인 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j129-1.png,,,,,,"GROUPPING SETS 함수는 표시된 인수들에 대한 개별 집계를 구하는 기능을 하며, 위의 SQL은 (상품ID, 월)별 집계 데이터를 출력한다. 각 보기별 SQL은 아래와 같다. ① GROUPING SETS에 (월, 상품ID) 별, 월별로 집계되었다. SELECT 상품ID, 월, SUM(매출액) AS 매출액 FROM 월별매출 WHERE 월 BETWEEN '2014.10' AND '2014.12' GROUP BY GROUPING SETS((월, 상품ID), 월); ② GROUPING SETS에 월별, 상품ID별과 전체가 각각 집계되었다. SELECT 상품ID, 월, SUM(매출액) AS 매출액 FROM 월별매출 WHERE 월 BETWEEN '2014.10' AND '2014.12' GROUP BY GROUPING SETS(월, 상품ID, ()); ④ GROUPING SETS에 괄호를 사용하지 않아 월별과 상품ID별로 각각 집계되었다. SELECT 상품ID, 월, SUM(매출액) AS 매출액 FROM 월별매출; WHERE 월 BETWEEN '2014.10' AND '2014.12' GROUP BY GROUPING SETS (월, 상품ID);",3
114,2과목,JOIN,아래 결괏값은 주어진 2개 테이블을 특정 JOIN하여 나타난 결과이다. 어떤 조인인지 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j477-1.png,SELECT * FROM SQLD27 ( ) SQLD27_2 ON SQLD27.COL1 = SQLD27_2.COL1;,INNER JOIN,FULL OUTER JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,주어진 두 개의 테이블에서는 같은 COL1 값을 갖는 튜플을 조회하고 우측 테이블에만 있는 값들이 추가로 조회되므로 RIGHT OUTER JOIN이다.,3
115,2과목,JOIN,다음 보기의 SQL을 실행하면 총 12개의 행이 조회된다. ( )에 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j303-1.png,SELECT * FROM MytestA ( ) MytestB;,RIGHT OUTER JOIN,CROSS JOIN,LEFT OUTER JOIN,INNER JOIN,"CROSS JOIN은 MytestA 테이블이 4행, MytestB 테이블이 3행이므로 4*3=12가 된다.",2
116,2과목,집합 연산자,다음 중 SQL 실행 결과로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j434-1.png,,,,,,MytestB 테이블에는 NULL 값이 존재한다. 따라서 NULL을 NOT IN으로 조회하면 모든 조건이 FALSE가 되어서 0건이 조회된다.,3
117,2과목,집계 함수,다음 중 주어진 테이블을 수행하였을 때 결괏값이 다른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j495-1.png,,SELECT COUNT(*) FROM TEST16 WHERE MemberID IS NOT NULL;,"SELECT COUNT (NULLIF(MemberID, NULL)) FROM TEST16;",SELECT COUNT(MemberID) FROM TEST16;,SELECT COUNT(1) FROM TEST16;,보기 ④번은 6개를 반환하고 나머지는 모두 4개를 반환한다.,4
118,2과목,그룹 함수,다음 중 주어진 테이블에서 SQL문의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j461-1.png,SELECT ID FROM test29 GROUP BY ID HAVING COUNT(*) = 2 ORDER BY (CASE WHEN ID = 1000 THEN 0 ELSE ID END);,,,,,"CASE문으로 ID가 1000인 것은 0 으로 변경하고 나머지는 ID값으로 ASC(오름차순) 한다. 단, COUNT 함수로 2건만 조회된다. 따라서 3000, 9999의 값이 2건이라서 3000, 9999만 조회된다.",4
119,2과목,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j593-1.png,SELECT SUM(COL2) + SUM(COL3) FROM TAB1; SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 > 0; SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 IS NOT NULL; SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 IS NULL;,"1000, NULL, 400, 600","1000, 100, 400, 600","500, NULL, 400, 600","500, 100, 400, 600","SUM(COL2)는 NULL 만 제외하고 총합을 리턴하므로 500 이 출력된다. 하지만 2 번 지문의 경우 COL1 > 0 조건에 만족하는 행은 첫 번째 행 하나이므로 SUM(COL2) + SUM(COL3) = NULL + 100 이 되며, 이때는 NULL 이 리턴된다.",1
120,2과목,윈도우 함수,다음 중 추천내역 테이블에서 아래와 같은 SQL을 수행하였을 때의 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j133-1.png,,,,,,"ROW_NUMBER 함수는 ORDER BY절에 의해 정렬된 데이터에 동일 값이 존재하더라도 유일한 순위를 부여하는 함수로서 데이터 그룹 내에 유일한 순위를 추출할 때 사용할 수 있는 함수이다. 문제의 SQL은 추천경로별(PARTITION BY 추천경로)로 추천점수가 가장 높은 (ORDER BY 추천점수 DESC) 데이터를 한건씩만 출력하지만, ①은 추천경로별로 추천점수가 가장 낮은 데이터를 각 한건씩 출력하였으며, ③은 전체에서 추천점수가 가장 높은 데이터 한건만을 출력하였고 ④은 전체 데이터를 그대로 출력하였다.",2
121,2과목,집계 함수,아래는 어느 회사의 광고에 대한 데이터 모델이다. 다음 중 광고매체 ID별 최초로 게시한 광고명과 광고시작일자를 출력하기 위하여 아래 (ㄱ) 에 들어갈 SQL로 옳은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j78-1.png,,"SELECT MIN (광고매체ID) AS 광고매체ID, MIN(광고시작일자) AS 광고시작일자 FROM 광고게시","SELECT MIN (광고매체ID) AS 광고매체ID, MIN(광고시작일자) AS 광고시작일자 FROM 광고게시 GROUP BY 광고ID","SELECT 광고매체ID, MIN(광고시작일자) AS 광고시작일자 FROM 광고게시 GROUP BY 광고매체ID","SELECT D. 광고매체ID, MIN(D. 광고시작일자) AS 광고시작일자 FROM 광고게시 D WHERE D.광고매체ID = C.광고매체ID GROUP BY D.광고매체ID",,3
122,2과목,계층형 질의,Mytest 테이블에 대해서 SQL문을 실행햇을 때 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j352-1.png,SELECT * FROM Mytest START WITH MGRID IS NULL CONNECT BY PRIOR EMPID = MGRID AND today BETWEEN '2017-01-01' AND '2022-12-31' ORDER SIBLINGS BY EMPID;,,,,,MGRID가 NULL인 값에서 시작해서 EMPID로 조회를 전개하는 순방향 조회를 하고 있다. 순방향 전개를 하면서 EMPID로 정렬한다.,4
123,2과목,그룹 함수,아래 SQL에서 출력되는 ROWS의 개수를 구하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j401-1.png,"SELECT DNAME, JOB, COUNT(*) ""Total EMP"", SUM(SAL) ""Total Sal"" FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY CUBE(DNAME,JOB);",20건,18건,14건,10건,"두 개의 테이블을 조인하면 14개의 행이 나오게 된다. 이를 CUBE로 집계를 하면 전체합계 1건, JOB별 집계 5건, DEPTNO별 집계 3건, DEPTNO에서의 JOB별 집계가 3건씩 9건으로 총 18건이 출력된다.",2
124,2과목,그룹 함수,다음의 SQL문 실행 결과로 조회되는 행의 개수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j432-1.png,"SELECT COUNT(*) FROM( SELECT COUNT(*) FROM Mytest GROUP BY ROLLUP(DATA1), DATA2);",8,6,4,3,총 행 수는 8개 조회된다.,1
125,2과목,집계 함수,다음 sutdent 테이블을 이용하여 아래의 SQL을 수행하였을 때 실행 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j234-1.png,SELECT count(*) FROM student GROUP BY department HAVING count(*) > 2;,3,2,1,0,"SELECT문을 보면 department로 GROUP BY한다. 그러면 총 3개의 그룹이 만들어진다. computer, physics, math이다. 3개의 그룹 중에서 개수가 2개 초과인 것을 조회하기 위해서 ""HAVING count(*) >2"" 문을 사용했다. 따라서 2개 초과인 것은 math이고 math는 총 3개가 있으므로 3이 된다.",1
126,2과목,JOIN,아래와 같은 데이터 모델에서 ORACLE을 기준으로 SQL을 작성하였다. 그러나 SQL Server에서도 동일한 결과를 보장할 수 있도록 ANSI 구문으로 SQL을 변경하려고 한다. 다음 중 아래의 SQL을 ANSI 표준 구문으로 변경한 것으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j99-1.png,,"SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A RIGHT OUTER JOIN 게시글 B ON (A.게시판ID = B.게시판ID AND A.사용여부 = 'Y' AND B.삭제여부 = 'N') GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;","SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A LEFT OUTER JOIN 게시글 B ON (A.게시판ID = B.게시판ID) WHERE A.사용여부 = 'Y' AND B.삭제여부 = 'N' GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;","SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A LEFT OUTER JOIN 게시글 B ON(A.게시판ID = B.게시판ID AND A.사용여부 = 'Y') WHERE B. 삭제여부 = 'N' GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;","SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A LEFT OUTER JOIN 게시글 B ON (A.게시판ID = B.게시판ID AND B.삭제여부 = 'N') WHERE A.사용여부 = 'Y' GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;",,4
127,2과목,집계 함수,다음 출력 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j748-1.png,"SELECT COL1, COL2, (SELECT COL2 FROM TAB2 WHERE TAB1.COL2 = TAB2.COL1) AS RESULT1, (SELECT MAX(COL2) FROM TAB3 WHERE TAB1.COL1 = TAB3.COL1) AS RESULT2 FROM TAB1;",,,,,"RESULT1은 TAB2의 COL1의 값이 TAB2의 COL1과 같은 행의 COL2값을 리턴한다. 하지만 TAB1의 COL2가 NULL 인 경우 조건에 일치하지 않아도 생략되지 않고 NULL로 출력되는데, 이는 메인쿼리의 WHERE절이 정의되지 않아 전체 행이 출력되기 때문이다. 마찬가지로 RESULT2도 TAB1의 COL1이 D인 경우 TAB1.COL1 = TAB3.COL1 조건에 일치하지 않지만 NULL로 출력된다.",2
128,2과목,그룹 함수,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j191-1.png,,부서별 합계를 계산할 때 NULL값을 만나면 0으로 치환한다.,"NVL(SAL, 0)문에서 NVL은 NULL에 대한 합계오류를 예방한다.",DEPTNO 10의 합계는 3000이고 20의 합계는 500이다.,SELECT문에 WHERE 조건이 없으므로 연산에 참여하는 총 행 수는 5개이다.,그룹 함수를 사용하는 경우 NULL 값은 연산에서 제외된다. 그래서 NVL 함수를 사용하는 것은 합계 오류 예방과는 전혀 관계가 없다.,2
129,,,"두 개 릴레이션 Student와 Department가 있을 때, 질의문 ""SELECT * FROM Students, Department d WHERE s.dept > 100;""을 수행하려고 한다. 이 질의 수행으로 생성되는 결과 릴레이션의 차수와 카디널리티는 각각 얼마인가?( 단, 릴레이션 Student의 애트리뷰트 '소속(dept)'은 릴레이션 Department의 애트리뷰트 '코드(dno)'를 외부키로 참조한다)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j233-1.png,,"차수=8, 카디널리티=3","차수=8, 카디널리티=9","차수=5, 카디널리티=2","차수=5, 카디널리티=3","차수와 카디널리티를 구하는 문제로 차수는 결과 릴레이션의 칼럼 수이다. 그래서 student와 dept 테이블을 조인하여 모든 칼럼을 출력하기 때문에 각각 student 테이블에서 5개, dept 테이블에서 3개, 총 8개의 칼럼을 가지게 된다.",2
130,,,주어진 데이터에 대해서 아래의 SQL문을 수행하였을 때의 결괏값이 아래의 결과와 같을 때 빈칸에 들어갈 값을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j561-1.png,,"3,3","2,2","3,2","2,3","NTILE(3)는 데이터 3등분 한다. 그리고 각 등분에 대해서 COUNT를 계산하므로 3,2가 된다.",3
131,,,함수의 실행 결과 중 다른 하나는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j586-1.png,,"ISNULL(COMM, 100)","COALESCE(COMM, 100)","NULLIF(COMM, 100)","NVL(COMM, 100)","NVL, COALESCE, ISNULL 모두 널을 만나면 그 다음 인수 값을 리턴하는 널 치환 함수이다. NULLIF(COMM, 100)은COMM 값과 100이 같으면 NULL을, 다르면 COMM 값을 리턴하므로 NULL, 500이 출력된다.",3
132,,,다음 주어진 테이블에 대해서 아래의 SQL문의 실행 결과로 가장 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j459-1.png,"SELECT ID, AGE FROM test20 ORDER BY (CASE WHEN ID = 10 OR ID=13 THEN 1 ELSE 2 END), AGE DESC",,,,,"CASE 문을 사용해서 정렬의 순서를 변경했고 그래서 ID가 13, 10번이 가장 먼저 조회된다. 즉, 10과 13번이 먼저 조회되고 AGE로 DESC이므로 13의 AGE가 50이라서 가장먼저 조회된다.",4
133,,,다음 중 [사원] 테이블에 대하여 아래와같은 SQL을 수행하였을 때 예상되는 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j135-1.png,,,,,,,4
134,,,다음 중 잘못된 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j427-1.png,,"SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal IN (SELECT SAL from Limbest.emp where DEPTNO = 10);","SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal >= ANY(30,40,50,60,70);","SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal <= ANY(30,40,50,60,70);","SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal <= (SELECT MAX(sal) FROM Limbest.emp GROUP BY DEPTNO);","문제의 핵심은 Sub Query 시에 다중행 서브쿼리르 묻고 있는 것이다. 보기 ④번은 서브쿼리로 여러 개의 행이 되돌아 오기 때문에 ALL, ANY, IN 함수를 사용해야 한다.",4
135,,,아래와 같은 테이블에 데이터가 있다. 각 SQL에 대한 결괏값이 잘못된 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j207-1.png,,,,,,NOT 조건이므로 NULL 연산이 Unknown으로 처리되어 True로 반환되는 현상이 나타난다.,3
136,,,"다음에 주어진 두 개의 테이블에 대해서 ""SQL1""의 실행 결과와 동일한 ""SQL2"" 문을 완성하시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j311-1.png,,SELECT 1 FROM MytestB b WHERE a.col1=b.col1 AND a.col2=b.col2 AND b.col1 < 1400,SELECT 1 FROM MytestB b WHERE a.col1=b.col1 AND a.col2=b.col2 AND b.col1 > 1400,SELECT 1 FROM MytestB b WHERE a.col1=b.col1 AND a.col2=b.col2 AND b.col3 < 1400,SELECT 1 FROM MytestB b WHERE a.col1=b.col1 AND a.col2=b.col2 AND b.col3 > 1400,EXISTS 구문의 뒤의 조건에 일치하는 경우 해당 a테이블의 행을 출력한다.,4
137,,,"아래 데이터 모델과 같이 고객과 주문 테이블이 생성되어 았으며, 고객과 주문 테이블에 입력되어 있는 데이터는 아래 표와 같다. 이 때 FK_001이라는 제약 조건을 아래 SQL과 같이 설정하였다. 다음 중 오류 없이 정상적으로 수행되는 SQL을 2개 고르시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j55-1.png,,DELETE FROM 고객 WHERE 고객ID = 'C002';,"DELETE FROM 주문 WHERE 주문번호 IN ('0001', '0002');","INSERT INTO 주문 VALUES ('0005', 'C003', '2013-12-28');","INSERT INTO 고객 VALUES ('C003', '강감찬',2014-01-01');",,"2,4"
138,,,다음 WINDOW FUNCTION이 포함된 SQL문의 실행 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j334-1.png,"SELECT MGR, ENAME, SAL, SUM(SAL) OVER (PARTITION BY MGR ORDER BY HIREDATE ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS MGR_SUM FROM Mytest;","4500, 7500, 7500, 3000, 4500, 4500, 5000, 8500, 8500","4500, 7500, 5500, 3000, 4500, 2500, 5000, 8500, 5500","2000, 4500, 7500, 2000, 3000, 4500, 3000, 5000, 8500","2000, 2500, 3000, 2000, 1000, 1500, 3000, 2000, 3500",위의 Mytest 테이블에서 MGR 속성별로 파티션을 분할했을 때 각각의 파티션 내에서 HIREDATE 속성값 기준으로 오름차순 정렬하고 그때 같은 파티션 내에서 현재 행을 기준으로 바로 이전 행부터 바로 다음 행까지의 급여의 합계를 계산하여 MGR_SUM 속성값으로 조회한다.,2
139,,,다음은 Oracle 데이터베이스에서 사용하는 Outer Join의 예제이다. 빈칸을 채워 Oracle의 Outer Join을 표준 ANSI SQL로 변경하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j304-1.png,,CROSS JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,FULL OUTER JOIN,"Oracle OUTER JOIN에서 (+)가 왼쪽 테이블 옆에 위치해 있으므로 우측 테이블에서는 조인을 수행하지 않는 테이블의 행들은 그대로 유지되며, 좌측 테이블에서는 조인을 수행하지 않는 테이블의 행들은 null값으로 추가되는 Rights OUTER JOIN이 수행된다.",2
140,,,"EMP 테이블 7788번 사원의 SAL 값이 현재 1000인 상황에서 아래 TX1, TX2 두 개의 트랜잭션이 동시에 수행되었다. 양쪽 트랜잭션이 모두 완료된 시점에 7788번 사원의 SAL 값은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j262-1.png,,1300,1200,1100,1000,TX2의 update 문은 배타적 lock 때문에 대기했다가 TX1 트랜잭션이 commit 한 후에 처리를 계속 한다. TX1에 의해 1100으로 바뀐 값을 읽어 200을 더하므로 최종 결과는 1300이 된다.,1
141,,,아래의 상품 마스터 테이블에 대한 상품ID '001'의 최종 상품명은 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j559-1.png,BEGIN TRANSACTION; SAVE TRANSACTION SP1; UPDATE 상품마스터 SET 상품명 = 'LG-TV' WHERE 상품ID ='001'; SAVE TRANSACTION SP2; UPDATE 상품마스터 SET 상품명 = '평면-TV' WHERE 상품ID = '001'; ROLLBACK TRANSACTION SP2; COMMIT;,없음,TV,평면-TV,LG-TV,"ROLLBACK TRANSACTION SP2 문장에 의해 UPDATE 상품 SET 상품명 = '평면-TV' WHERE 상품ID = '001'이 ROLLBACK 되었고, 첫 번째 UPDATE 문장만 유효한 상태에서 COMMIT 되었으므로 첫 번째 UPDATE한 내역만 반영된다. 그러므로 LG-TV가 된다.",4
142,,,아래와 같은 테이블이 있다. 다음 SQL 실행 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j602-1.png,"SELECT COUNT(DEPTNO) FROM EMPLOYEES WHERE DEPTNO <= ALL(SELECT DEPTNO FROM EMPLOYEES WHERE HIREDATE >= TO_DATE('2020/02', 'YYYY/MM'));",5,4,3,2,"서브쿼리 결과가 먼저 실행되어 2020년 2월 1일보다 입사일이 큰 행의 DEPTNO(30, 40, 50)가 출력되고 ALL이 작다와 결합되어 이들 중 30보다 작거나 같은 조건으로 전달된다. 따라서 DEPTNO가 10, 20, 30인 EMPNO의 수는 총 3개이다.",3
143,,,다음 SQL 구문의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j597-1.png,SELECT SAL FROM TAB1 ORDER BY TO_CHAR(SAL);,2500 1300 800 300,300 1300 800 2500,300 800 1300 2500,1300 2500 300 800,"TO_CHAR에 의해 SAL 값이 문자로 변환되며, 문자 값의 대소 비교는 값의 왼쪽부터 비교하므로 왼쪽 값이 가장 작은 값의 크기가 제일 작다. 따라서 1300 < 2500 < 300 < 800 순이 되며, 오름차순 정렬은 1300, 2500, 300, 800 순서로 배치된다.",4
144,,,다음 ERD를 보고 고객별로 가장 최근에 구매한 상품명을 출력하는 SQL로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j701-1.png,,"SELECT C.이름, G.구매일, P.상품명 FROM 고객 C, 구매 G, 상품 P WHERE G.상품번호 = P.상품번호 AND C.고객번호 = G.고객번호;","SELECT C.이름, G.구매일, P.상품명 FROM 고객 C, 구매 G, 상품 P, (SELECT 고객번호, MIN(구매일) 최근구매일 FROM 구매 GROUP BY 고객번호) I WHERE G.고객번호 = I.고객번호 AND G.구매일 = I.최근구매일 AND G.상품번호 = P.상품번호 AND C.고객번호 = G.고객번호;","SELECT G.고객번호, G.구매일, P.상품명 FROM 고객 G, 상품 P, (SELECT 고객번호, MAX(구매일) 최근구매일 FROM 구매 GROUP BY 고객번호) I WHERE G.고객번호 = I.고객번호 AND G.상품번호 = P.상품번호;","SELECT G.고객번호, G.구매일, P.상품명 FROM 구매 G, 상품 P, (SELECT 고객번호, MAX(구매일) 최근구매일 FROM 구매 GROUP BY 고객번호) I WHERE G.고객번호 = I.고객번호 AND G.구매일 = I.최근구매일 AND G.상품번호 = P.상품번호;","먼저 구매테이블을 통해 고객별 최근 구매일을 파악한 뒤(인라인뷰), 해당 고객과 구매일에 구매한 상품번호를 파악하기 위해 다시 구매테이블과 조인이 필요하다. 그 뒤 상품테이블과 조인하여 해당 상품의 상품명을 알아내면 된다.",4
145,,,다음 보기의 SELECT문을 실행했을 때 그 결과가 다른 하나는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j288-1.png,,"SELECT MIN(nvl(CNT,5)) FROM Mytest;","SELECT AVG(nvl(CNT,0)) FROM Mytest;","SELECT SUM(nvl(CNT,0))/4 FROM Mytest;","SELECT COUNT(nvl(CNT,0)) FROM Mytest;","①,③,④ 번 보기는 결괏값 5를 반환하고 ②번 보기만 결괏값 4를 반환한다.",2
146,,,아래의 테이블들에 대해서 SQL문을 수행하였을 때의 결과 값은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j545-1.png,SELECT COUNT(*) FROM TEST29_1 A WHERE A.COL NOT IN(SELECT COL FROM TEST29_2);,6,3,1,0,NOT IN 안에 NULL이 들어가면 아무것도 출력되지 않는다. 이 때 COUNT는 0을 출력하게 된다.,4
147,,,다음 주어진 테이블에 대해서 아래와 같은 SQL문을 수행하였을 때 반환되는 ROW 값의 수는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j195-1.png,,4,3,2,1,"주어진 SQL문 앞에 UNION 연산을 수행하면 1,2,3,4,5,가 반환되고 이어서 minus를 수행하면 1,3,4,5가 반환된다.",1
148,,,주어진 테이블에 대해서 아래의 SQL문을 수행한 결과로 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j491-1.png,select count(*) from TEST11 where COL3 <> 3 start with COL3 = 4 connect by COL1 = prior COL2;,3,2,1,0,,1
149,,,다음 중 아래 테이블에 대한 이상현상을 설명한 것 중 가장 적절하지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j367-1.png,,삭제 이상 : 장비의 고객정보가 삭제되면 A카드 상품의 정보도 삭제된다.,갱신 이상 : 노트북의 가격을 업데이트 할 경우 관우의 노트북만 업데이트하면 된다.,갱신 이상 : 스마트폰의 정보를 업데이트할 경우 유비의 스마트폰만 업데이트하면 된다.,삽입 이상 : 상품을 주문하지 않은 고객의 정보를 삽입할 수 없다.,스마트폰의 정보를 업데이트할 경우 유비뿐 아니라 관우의 정보도 같이 업데이트해야 한다.,3
150,,,"SQL SERVER에 구축된 TEAMSCORE 테이블에서 WINCNT가 가장 높은 4위까지 조회한다. 단, WINCNT에 동일한 순위 팀이 있으면 같이 조회하는 SQL문으로 올바른 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j329-1.png,,"SELECT TOP(4) WITH TIES TEAMNAME, WINCNT FROM TEAMSCORE ORDER BY WINCNT DESC;","SELECT TEAMNAME, WINCNT FROM TEAMSCORE WHERE ROWNUM <= 4 ORDER BY WINCNT DESC;","SELECT TOP(4) TEAMNAME, WINCNT FROM TEAMSCORE;","SELECT TOP(4) TEAMNAME, WINCNT FROM TEAMSCORE ORDER BY WINCNT ASC;",②번의 ROWNUM은 ORACLE 데이터베이스에서 사용하는 것이고 SQL SERVER는 TOP구를 사용한다. TOP구에 WITH TIES를 같이 사용하면 동일한 데이터가 있을 때 함께 조회된다.,1
151,,,다음의 SQL문을 실행했을 때 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j380-1.png,SELECT * FROM MytestA a left outer join MytestB b on a.col1 = b.col1;,,,,,①번 보기는 INNER JOIN ②번 보기는 FULL OUTER JOIN ③번 보기는 RIGHT OUTER JOIN ④번 보기는 LEFT OUTER JOIN이다.,4
152,,,다음 SQL의 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j636-1.png,"SELECT TO_CHAR(TO_DATE(SUBSTR(JUMIN, 1, 6), 'RRMMDD'), 'YYYY-MM-DD') FROM TAB1;",2075-10-23 0:00:00,1975-10-23 0:00:00,2075-10-23,1975-10-23,"주민번호의 앞 6자리를 사용하여 날짜변환 시 RR 포맷을 사용하면 두 자리 연도가 1~49 사이면 2000년대를, 50~99이면 1900년도의 4자리 연도로 출력, YY를 사용하면 2000년대를 출력한다.",4
153,,,"아래 ERD를 참고하여, 다음 SQL을 작성하였을 때 이들 중 실행 결과가 다른 하나는?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j650-1.png,,SELECT C.CUSTOMER_ID FROM CUSTOMERS C WHERE C.WEDDING_TYPE = 'Y' AND C.GENDER = 'F' AND TRUNC((SYSDATE - BIRTHDAY)/365) BETWEEN 40 AND 50 AND EXISTS (SELECT 'X' FROM ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID);,SELECT C.CUSTOMER_ID FROM CUSTOMERS C WHERE C.WEDDING_TYPE = 'Y' AND C.GENDER = 'F' AND TRUNC((SYSDATE - BIRTHDAY)/365) BETWEEN 40 AND 50 AND C.CUSTOMER_ID IN (SELECT O.CUSTOMER_ID FROM ORDERS O);,"SELECT C.CUSTOMER_ID FROM CUSTOMERS C, (SELECT O.CUSTOMER_ID, COUNT(O.PROMOTION_ID) AS ORD_CNT FROM ORDERS O GROUP BY O.CUSTOMER_ID HAVING COUNT(O.PROMOTION_ID) >= 1) I WHERE C.CUSTOMER_ID = I.CUSTOMER_ID AND C.WEDDING_TYPE = 'Y' AND C.GENDER = 'F' AND TRUNC((SYSDATE - BIRTHDAY)/365) BETWEEN 40 AND 50;","SELECT DISTINCT C.CUSTOMER_ID FROM CUSTOMERS C, ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID AND C.WEDDING_TYPE = 'Y' AND C.GENDER = 'F' AND TRUNC((SYSDATE - BIRTHDAY)/365) BETWEEN 40 AND 50;","2번 보기를 제외한 모든 지문은 기혼 40대 여성 중 구매이력이 있는 고객의 고객아이디를 출력하는 문장이다. 실제 구매이력은 ORDERS에 있기 때문에 ORDERS의 CUSTOMER_ID 값에 존재하는지를 확인하여 구매자의 고객번호를 특정할 수 있다. 이는 INNER JOIN, IN, EXISTS 연산자로 구현 가능한데, 2번 보기의 경우 인라인 뷰의 결과 PROMOTION_ID 가 1 이상인 상품을 구매한 고객 아이디만 특정하기 때문에 전체 상품 구매를 기준으로 출력하는 다른 보기와는 결과값이 다르게 출력된다.",3
154,,,다음 주어진 테이블에 대해서 아래와 같은 결과값이 나오도록 SQL문의 빈칸에 들어갈 수 있는 내용을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j531-1.png,"SELECT DEPTNO, JOB, SUM(SAL) FROM T_TEST GROUP BY ( );","CUBE(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","GROUPING SETS(DEPTNO, JOB)","DEPTNO, JOB","집계결과는 DEPTNO별 합계, JOB별 합계, DEPTNO 및 JOB별 합계, 전체합계가 조회되고 Rollup이 와야 한다.",2
155,,,다음 주어진 테이블에서 아래의 SQL문을 수행하였을 때의 결과가 RESULT와 같을 때 SQL문의 빈칸으로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j375-1.png,"SELECT DNMAE,JOB,SUM(SAL) FROM Mytest GROUP BY ( )",CUBE(JOB),GROUPING SETS(JOB),"ROLLUP(DNAME,JOB)","CUBE(DNAME,JOB)","결괏값을 보면 1.DNAME, JOB별 소계 2.DNAME별 소계 3.JOB별 소계 4.전체 집계 등 모든 조합 가능한 소계와 집계가 조회되었으므로 빈칸에 들어갈 그룹 함수는 CUBE이다.",4
156,,,다음의 SQL문을 실행한 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j377-1.png,SELECT COUNT(C1) FROM Mytest,4,3,2,1,COUNT(C1)은 NULL 값은 제외된다. 따라서 3개가 된다.,2
157,,,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j609-1.png,"SELECT DNAME, FIRST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE1, LAST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE2 FROM TAB1;",,,,,"FIRST_VALUE, LAST_VALUE는 ORDER BY 컬럼 순서대로 범위 내 가장 처음 값과 마지막 값을 리턴하는 함수인데, 이때 기본 범위는 RANGE UNBOUNDED PRECEDING AND CURRENT ROW이다. 따라서 같은 DNAME 내 SAL 순서대로 가장 앞에 있는 이름은 아시아지부의 경우 홍길동, 남유럽지부의 경우 김길동이 된다. 하지만 각 행마다 LAST_VALUE를 구할 때 범위가 처음부터 현재 행까지만 고려해서 마지막 값을 리턴하기 때문에 항상 현재 행의 값이 마지막 값이 되므로 각 행의 값이 리턴된다.",1
158,,,자재발주 테이블에 SQL을 수행하여 아래와 같은 결과를 얻었다. 다음 중 (ㄱ)에 들어갈 문장으로 옳은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j128-1.png,,"GROUP BY GROUPING SETS (자재번호, (발주처ID, 발주일자))","GROUP BY GROUPING SETS (자재번호, 발주처ID, 발주일자)","GROUP BY CUBE (자재번호, 발주처ID, 발주일자)","GROUP BY CUBE (자재번호, (발주처ID, 발주일자))","집계 그룹 함수에는 ROLLUP, CUBE, GROUPING SETS 함수가 있다.문제의 결과 데이터는 (자재번호별) SUB TOTAL과 (자재번호, 발주처별) SUB TOTAL을 출력하고 있다. GROUPING SETS 함수를 사용하여 입력된 인수들에 대한 개별 집계를 구할 수 있으며, CUBE 함수의 경우는 나열된 모든 인수의 결합 가능한 집계가 출력 된다.그러므로 위의 문제에서는 GROUP BY GROUPING SETS(자재번호, (발주체D, 발주일자)) 가 되어야 한다.",1
159,,,아래와 같은 데이터 모델어서 데이터를 조작히려고 한다. 다음 중 오류가 발생하는 SQL 문장인 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j54-1.png,,UPDATE BOARD SET BOARD_ID = 200 WHERE BOARD_ID = '100';,UPDATE BOARD SET USE_YN = 'N' WHERE BOARD_ID = '1';,"INSERT INTO BOARD (BOARD_ID, BOARD_NM, USE_YN, BOARD_DESC) VALUES ('100', 'FAQ', 'Y', 'FAQ 게시판');","INSERT INTO BOARD VALUES (1, 'Q&A', 'Y', SYSDATE, 'Q&A 게시판');",,3
160,,,다음 주어진 테이블에 대해서 아래의 SQL문을 실행하였을 때의 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j498-1.png,"SELECT C1, C2, CASE WHEN C2 <= 100 THEN 'B' WHEN C2 <= 300 THEN 'A' ELSE 'S' END GRADE FROM test19 ORDER BY C2;",,,,,"C2 값으로 오름차순 정렬하고 CASE문으로 B,A,S 등급을 부여한다. 전체등급이 300점을 넘는 등급이 없기 때문에 S등급은 없고 C1의 6번만 A등급을 받는다.",4
161,,,다음 SQL의 실행 결과를 얻기 위한 빈칸에 들어갈 값으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j711-1.png,"SELECT * FROM TAB1 UNPIVOT (_____ FOR _____ IN (""2023"", ""2024""));","판매량, 판매량","성별, 판매량","성별, 연도","판매량, 연도","첫 번째 밑줄은 10, 20, 30, 40 값이 쌓여 하나의 컬럼을 이룰 때 컬럼명을 나타내는 자리이므로 판매량, 두 번째 밑줄은 2023, 2024를 넣을 컬럼명을 의미하므로 연도가 적절하다.",4
162,,,다음 SQL 중 실행 결과가 다른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j588-1.png,,"SELECT CASE SUBSTR(JUMIN, 7, 1) WHEN '1' THEN '남자' ELSE '여자' END FROM TAB1;","SELECT CASE SUBSTR(JUMIN, 7, 1) WHEN 1 THEN '남자' ELSE '여자' END FROM TAB1;","SELECT CASE WHEN SUBSTR(JUMIN, 7, 1) = 1 THEN '남자' ELSE '여자' END FROM TAB1;","SELECT DECODE(SUBSTR(JUMIN, 7, 1), '1', '남자', '여자') FROM TAB1;",CASE 문 축약형 문법(비교 대상이 CASE 와 WHEN 사이에 있는)은 반드시 비교 대상과 비교 상수의 데이터 타입이 일치해야 한다. SUBSTR 결과는 항상 문자로 출력되므로 숫자 상수와 비교하는 3 번 지문은 에러가 발생하여 출력되지 않는다.,2
163,,,"부서와 사원 테이블을 생성하는 SQL 문장을 수행한 후 튜플 삽입으로 두 테이블의 상태가 다음과 같을 때, 테이블 연산 수행에 대한 설명으로 올바르지 않은 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j249-1.png,,"부서 테이블에 (1,'연구부') 튜플을 삽입한다면 참조 무결성 제약조건을 위배한다.","사원 테이블에 (14,'김유신',0) 튜플을 삽입한다면 참조 무결성 제약조건을 위배한다.","사원 테이블에 (13,'강감찬','A1') 튜플을 삽입한다면 도메인 무결성 제약조건을 위배한다.","부서 테이블에서 (2,'영업부') 튜플을 삭제한다면 참조 무결성 제약조건을 위배한다.","부서 테이블은 마스터 테이블이므로 사원 테이블에 없는 부서번호 등을 자유롭게 입력할 수 있다. 따라서 부서 테이블에 (1,""연구부"")을 입력하는 것은 참조 무결성 위배가 아니다. 단, 부서테이블에 부서번호 칼럼은 PRIMARY KEY이므로 중복값이 입력되면 안된다. 즉, 이미 부서번호가 1인 대상이 있으므로, 무결성 제약 조건에 위배된다.",1
164,,,다음 주어진 테이블에서 아래의 SQL문과 다른 값을 반환하는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j198-1.png,,select * from SQLD_66 where (COL1 = 'x' or COL1 ='가') and (COL2 ='y' or COL2 ='나');,"select * from SQLD_66 where not (COL1, COL2) in (('A', 'B'),('다','라'),('a', 'b'),('1', '2'));",select * from SQLD_66 where not (COL1 ='x' and COL2 = 'y') or (COL1 ='가' and COL2 ='나');,select * from SQLD_66 where not (COL1 ='x' and COL2 = '가') or (COL1 ='y' and COL2 ='나');,"위의 SQL문은 COL1과 COL2 값을 각각 (x,y), (가,나)를 갖는 행들이 반환되지만 ④번은 COL1과 COL2 값으로 각각 (x,가), (y,나) 값을 갖는 행들이 반환한다.",4
165,,,"{학번, 과목번호}는 결정자이면서 기본키이고 {성적, 지도교수명, 학과명}은 종속자이다. 속성 중 과목번호가 결정자이고 {지도교수명, 학과명}이 과목번호에만 함수적 종속성을 가진다면 이는 몇 차 정규형에 속하고 몇 차정규화의 대상인가?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j160-1.png,,보이스-코드 정규화-4차정규화 대상,3차정규형-보이스-코드 정규화 대상,1차정규형-2차정규화 대상,2차정규형-3차정규화 대상,결정자 중 일부 속성에만 함수 종속성을 가지고 있는 것은 2차정규형을 위반한 사례에 해당한다.,3
166,,,다음은 ABC 증권회사의 데이터베이스 모델링이다. 모델링은 고객과 계좌 간의 관계를 표현한 것이다. 보기 중에서 그 설명이 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j446-1.png,,한 명의 고객에게 하나의 고객등급만 부여된다.,고객마스터와 계좌마스터의 관계는 식별 관계이다.,계좌번호는 전체 고객마다 유일한 번호가 부여된다.,계좌를 개설하지 않은 고객은 ABC증권회사의 고객이 될 수가 없다.,"계좌마스터의 기본키가 계좌번호와 고객번호이므로 전체 고객에게 유일한 번호가 할당되는 것은 아니다. 즉, 고객별 유일한 계좌번호가 된다.",3
167,,,다음 SQL의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j84-1.png,,,,,,,3
168,,,주어진 테이블에 대해서 아래의 SQL문을 수행하였을 때의 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j512-1.png,SELECT COUNT(*) FROM TEST39 GROUP BY COL1 HAVING COUNT(*)>2;,6,5,3,,"COL1 칼럼으로 GROUP BY를 할 경우 행 수가 2건 보다 많은 것은 4,5,6행이다.",3
169,,,다음 SQL의 실행 결과로 맞는 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j89-1.png,,6,4,2,0,,2
170,,,다음 결과를 출력하는 SQL 문으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j789-1.png,,"SELECT COUNT(DECODE(COL2, 10, 'O', 'X')) AS CNT10, COUNT(DECODE(COL2, 20, 'O', 'X')) AS CNT20 FROM TAB1;","SELECT SUM(DECODE(COL2, 10, 'O', 'X')) AS CNT10, SUM(DECODE(COL2, 20, 'O', 'X')) AS CNT20 FROM TAB1;","SELECT COUNT(DECODE(COL2, 10, 1, 0)) AS CNT10, COUNT(DECODE(COL2, 20, 1, 0)) AS CNT20 FROM TAB1;","SELECT SUM(DECODE(COL2, 10, 1, 0)) AS CNT10, SUM(DECODE(COL2, 20, 1, 0)) AS CNT20 FROM TAB1;","특정 대상의 수를 세려면 COUNT는 세고자 하는 값이 어떤 값이든 존재(1이나 'X' 등)하면 되고, 반대로 세지 않을 값은 반드시 NULL이어야 한다. SUM은 세고자 하는 값이 1이고, 나머지는 NULL이거나 0이면 된다. 따라서 해당 조 건에 만족하는 문장은 1번이다.",4
171,,,다음의 ERD는 교차 엔터티를 보여주고 있다. 교차 엔터티로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j464-1.png,,"학생, 과목",수강,과목,학생,교차 엔터티는 M:N 관계를 해소하기 위해서 사용되는 엔터티와 학생과 과목 간의 M:N 관계를 해소하기 위해서 수강이라는 교차 엔터티가 사용되었다.,2
172,,,아래 SQL 중 수행이 정상적이지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j606-1.png,,"(SELECT TO_CHAR(EMPNO) AS EMPNO, ENAME, SAL FROM EMP UNION SELECT EMPLOYEE_ID AS EMPNO, NAME, SALARY FROM EMPLOYEES) ORDER BY EMPNO;","SELECT TO_CHAR(EMPNO) AS EMPNO, ENAME, SAL FROM EMP UNION SELECT EMPLOYEE_ID, NAME, SALARY FROM EMPLOYEES ORDER BY EMPNO;","SELECT ENAME, SAL FROM EMP MINUS SELECT NAME, SALARY FROM EMPLOYEES;","SELECT DEPTNO, SUM(SAL) AS SUM_SAL FROM EMP GROUP BY DEPTNO UNION ALL SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;","4번 보기의 경우 DEPTNO와 DEPARTMENT_ID 컬럼의 데이터 유형이 다르기 때문에 에러가 발생한다. 1, 2번 보기의 경우 집합 연산 결과에 정렬을 하는 구문이므로 정상적으로 수행된다.",4
173,,,다음 중 실행이 불가능한 SQL을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j619-1.png,,"INSERT INTO TAB1 VALUES(1000, 1234.5, '100', ' ');","INSERT INTO TAB1 VALUES(1000, 123.456, '2024-01-01', NULL);","INSERT INTO TAB1 VALUES(1000, 123.45, '100', 'ABC');","INSERT INTO TAB1 VALUES(1000, 12.345, 100, 'ABC');","NUMBER(5,2) 타입은 총 5자리 중 2자리를 소수점 자리로 사용하므로 정수 자리는 최대 3자리만 삽입 가능하다. 또한, 소수점 자리는 세 자리 이상 삽입은 가능하나 입력되는 것은 둘째 자리까지만 입력된다.",1
174,,,"(SQL Server) 다음 중 아래의 SQL과 동일한결과를 추출하는 SQL은?(단, 테이블 TAB1, TAB2의 PK 컬럼은 A, B 이다.)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j100-1.png,,"SELECT TAB1.A, TAB1.B FROM TAB1 WHERE NOT EXISTS (SELECT 'X' FROM TAB2 WHERE TAB1.A = TAB2.A AND TAB1.B = TAB2.B);","SELECT TAB2.A, TAB2.B FROM TAB1, TAB2 WHERE TAB1.A = TAB2.A AND TAB1.B = TAB2.B","SELECT TAB1.A, TAB1.B FROM TAB1 WHERE TAB1.A NOT IN (SELECT TAB2.A FROM TAB2) AND TAB1.B NOT IN (SELECT TAB2.B FROM TAB2);","SELECT TAB2.A, TAB2.B FROM TAB1, TAB2 WHERE TAB1.A〈〉TAB2.A AND TAB1.B〈〉TAB2.B",,1
175,,,다음 SQL문의 ( )를 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j435-1.png,,"ㄱ: RANK(), ㄴ: DENSE_RANK()","ㄱ: DENSE_RANK(), ㄴ: ROW_NUMBER()","ㄱ : ROW_NUMBER(), ㄴ : RANK()","ㄱ : RANK(), ㄴ : ROW_NUMBER()",첫 번째 실행 결과는 급여가 동일하므로 같은 등수가 조회되었다. 따라서 RANK() 함수이다. 두 번째 실행 결과는 급여가 동일하지만 유일한 등수가 부여되었다. 따라서 ROW_NUMBER() 함수이다.,4
176,,,다음 주어진 테이블에서 해당 SQL문을 실행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j496-1.png,"SELECT * FROM SQLD5 WHERE COL1 IN (1,2,NULL);",,,,,"NULL은 비교에서 애초에 제외되어 IN 연산자 안에 NULL이 있어도 비교 연산을 수행하지 않는다. 주어진 테이블의 COL1 속성값 1,2값을 갖는 튜플만 조회된다.",4
177,,,다음 문장이 차례대로 수행된 이후의 데이터 값으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j667-1.png,"ALTER TABLE TAB1 ADD COL4 CHAR(5); ALTER TABLE TAB1 MODIFY COL4 DEFAULT 'AAA'; INSERT INTO TAB1 VALUES(4, 'D', 40, NULL); INSERT INTO TAB1(COL1, COL2, COL3) VALUES(5,'E',50);",,,,,"COL4 컬럼 추가 시, 기존 세 개의 행의 값은 NULL이 삽입된다. 그 이후 DEFAULT 값을 변경해도 이전에 삽입된 행은 반영되지 않고, 이후 삽입되는 행에 대해 적용된다. COL3에 DEFAULT 값이 설정되어 있다 하더라도 NULL을 직접 입력하면 NULL이 삽입되며, 마지막 INSERT 문장처럼 COL3의 값이 아예 입력되지 않을 경우만 DEFAULT VAULE로 삽입된다.",2
178,,,다음은 ABC기업에 대한 데이터베이스 모델링이다. 설명 중 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j532-1.png,,제품마스터에서 주문일자를 조회하기 위해서는 WHERE의 조건이 최소 4개이상이다.,제품마스터와 제품생산은 비식별 관계이다.,제품마스터와 주문이력을 조인하면 카텐시안 곱이 발생한다.,제품코드에 대한 배송지 정보는 제품마스터 테이블이 주문이력을 직접 조인하면 된다.,제품마스터와 주문이력을 직접 조인하면 조인키가 없으므로 카텐시안 곱이 발생한다.,3
179,,,주어진 테이블에서 해당 SQL문을 수행 시 결과값으로 조회되는 테이블은 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j473-1.png,"SELECT C2, SUM(C3) FROM SQLD_01 GROUP BY C2 HAVING COUNT(*) >= 2;",,,,,주어진 테이블에서 C2 칼럼으로 그룹화 했을 때 C2 칼럼별 튜플의 수가 2개 이상인 C2칼럼에 대해서 C3의 합계를 계산한다.,3
180,,,다음 중 Mytest 테이블에서 부서코드 400부터 상위 부서를 찾는 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j280-1.png,,Select 상위부서코드 from Mytest where 부서코드 = 400 start with 상위부서코드 = 0 connect by prior 부서코드 = 상위부서코드;,Select 상위부서코드 from Mytest where 부서코드 = 400 start with 부서코드 = 50 connect by prior 부서코드 = 상위부서코드;,Select 상위부서코드 from Mytest where 부서코드 = 400 start with 상위부서코드 = 0 connect by prior 상위부서코드 = 부서코드;,Select 상위부서코드 from Mytest where 부서코드 = 400 start with 부서코드 = 50 connect by prior 상위부서코드 = 부서코드;,상위부서코드 0부터 시작하여 계층적으로 조회하는데 이때 where 조건으로 부서코드 = 400에 대한 상위부서코드 값을 찾을 수 있다. 계층 쿼리는 START WITH - CONNECT BY 로 전개가 완료된 후에 WHERE 등의 필터링이 실행된다.,1
181,,,"Oracle 환경에서 주어진 테이블을 아래의 결과와 같이 정렬하고자 할 때, SQL문의 빈칸에 들어갈 값을 고르시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j557-1.png,"SELECT C1,C2 FROM SQLD_02 ORDER BY C1,C2 DESC ( );",NULL LAST,NULLS LAST,NULL IS LAST,IS NULL,NULLS LAST는 NULL 값을 마지막에 정렬시키는 것이다.,2
182,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j710-1.png,"SELECT DEPTNO, DNAME, LEVEL, CONNECT_BY_ROOT(DNAME) AS ROOT FROM DEPARTMENT START WITH PART IS NULL CONNECT BY PRIOR PART = DEPTNO;",,,,,"PRIOR의 위치가 PART에 있으므로 가장 최상위 학과(PART IS NULL)를 먼저 출력하고, 두 행의 PART를 DEPTNO 로 갖는 행을 찾지만 해당 행이 없으므로 최상위 학과인 공과대학과 인문대학만 출력된다.",3
183,,,다음 SQL 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j616-1.png,UPDATE EMPLOYEE E1 SET SAL = (SELECT MAX(SAL) FROM EMPLOYEE E2 WHERE E1.DNAME = E2.DNAME) WHERE SAL <= (SELECT AVG(SAL) FROM EMPLOYEE);,,,,,"전체 평균(4000)보다 급여가 낮은 직원들의 급여만 수정되므로 김길동 두 명의 급여는 수정되지 않는다. SET절은 각 행의 급여 수정 시 부서명을 확인하여 서브쿼리에서 해당 부서의 최대 급여를 찾아 수정하는 구문이다. 따라서 아시아지부는 모두 3000으로, 남유럽지부는 8000으로 수정된다.",2
184,,,"BSC는 기업의 성과를 균형있게 관리하는 성과관리 시스템이다. BSC는 KPI를 사용해서 기업을 평가하는데 KPI는 상위, 중위, 하위 등의 KPI로 세분화 된다. 다음의 KPIPOOL 테이블에서 특정 하나의 값에 대한 자신의 상위 KPI를 검색하는 SQL문으로 올바른 것은?(이때, 자신의 KPI는 SUBKPI이고, 상위 KPI는 MAINKPI이다.)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j469-1.png,,Select * from kpipool where subkpi = 30 start with mainkpi = 0 connect by prior subkpi = mainkpi;,Select * from kpipool start with mainkpi = 100 connect by prior subkpi = mainkpi;,Select * from kpipool where subkpi = 30 start with mainkpi = 0 connect by prior mainkpi = subkpi;,Select * from kpipool start with mainkpi = 0 connect by prior subkpi = mainkpi;,mainkpi가 0부터 출발하여 subkpi를 탐색한다. 그리고 subkpi가 30이면 출력시킨다. 이 때 subkpi 30에 대한 mainkpi 20번이 같이 출력된다.,1
185,,,다음 중 아래와 같이 수강지도 엔터티를 만들었을 때 이에 해당하는 정규형과 정규화의 대상으로 가장 바르게 짝지어진 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j37-1.png,,보이스코드정규형 - 4차 정규화 대상,3차 정규형 - 보이스코드 정규화대상,2차 정규형 - 3차 정규화 대상,1차 정규형 - 2차 정규화 대상,,4
186,,,다음 주어진 테이블에서 해당 SQL문을 실행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j546-1.png,"SELECT * FROM SQLD5 WHERE COL1 IN(1,2,NULL);",,,,,"NULL은 비교에서 애초에 제외되어 IN()연산자 안에 NULL이 있어도 비교연산을 수행하지 않는다. 주어진 테이블의 COL1 속성값 1,2값을 갖는 튜플만 조회된다.",4
187,,,다음 주어진 테이블에서 집계 함수를 수행하였을 때 결괏값으로 다른 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j538-1.png,,"select avg(nvl(usercount, 1)) -0.5 from test21;","select avg(nvl(usercount, 0)) from test21;","select sum(nvl(usercount, 0)) / 4 from test21;","select count(nvl(usercount, 0)) from test21;",④번은 count를 계산하는 것으로 총 4개의 행이 있으므로 4가 나온다.,4
188,,,다음 테이블에 대해서 주어진 SQL문을 수행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j392-1.png,"SELECT A.JUMIN, B.CUSTRANK FROM (SELECT JUMUN, SUM(price) AS TOTAL, FROM T_ORDER GROUP BY JUMUN) A, T_CUST B WHERE 1=1 AND A.TOTAL BETWEEN B.MINPRICE AND B.MAXPRICE;",,,,,위의 SQL문은 1번째 테이블에서 주문자별로 grouping 하였을 때 각 주문자별로 주문금액의 합계를 계산하고 그 값이 두 번째 테이블의 실적범위에 해당하는 곳에서 고객등급과 주문자 정보를 조회한다.,4
189,,,다음 SQL 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j651-1.png,"SELECT E1.EMPNO, E1.ENAME, E1.HIREDATE, COUNT(E2.EMPNO) AS CNT FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.HIREDATE > E2.HIREDATE GROUP BY E1.EMPNO, E1.ENAME, E1.HIREDATE ORDER BY E1.HIREDATE;",,,,,"셀프조인을 사용하여 EMP에서의 각 직원별로 입사일이 빠른 직원의 수를 계산하는 질의절이다. 이 때, LEFT OUTER JOIN을 수행하였기 때문에 입사일이 가장 빠른 SMITH의 경우도 CNT가 0으로 출력된다.",3
190,,,다음의 JOIN 결과를 보고 빈칸에 들어갈 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j558-1.png,SELECT * FROM TEST46_1 ( ) TEST46_2 ON TEST46_1.COL1 = TEST46_2.COL1;,CROSS JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,SELF JOIN,"결과 테이블을 보면 TEST46_1 테이블에만 있는 3번행(COL1, COL2)만 조회되고 TEST46_2 테이블에는 3번행이 없으므로 NULL로 조회되었다. 따라서 LEFT OUTER JOIN을 실행한 것이다.",3
191,,,"아래 SQL 수행 결과로 가장 적절한 것은? (단, DBMS는 오라클)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j695-1.png,"SELECT ENAME, DEPTNO, SAL FROM EMP ORDER BY DEPTNO, SAL DESC;",,,,,"DEPTNO가 작은순서대로, DEPTNO가 같은 경우 SAL이 큰 순서대로 정렬하여 출력한다. NULL이 마지막에 출력되는게 기본 순서이지만DESC로 내림차순 정렬하면 NULL이 젤 먼저 출력된다.",2
192,,,다음의 주어진 ERD에서 실행했을 때 오류가 발생하는 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j480-1.png,,"INSERT INTO 주문 VALUES ('O002', 'C002', 'YYY');",UPDATE 주문 SET 고객ID = NULL WHERE 주문ID = 'O001';,"INSERT INTO 주문 VALUES ('O001', 'C001', 'XXX');","INSERT INTO 고객 VALUES ('C001', 'AAA');",④번 지문은 문법 오류로 2개의 칼럼만 입력하려면 테이블명 뒤에 칼럼명을 포함시켜야 한다.,4
193,,,"다음 중 아래 TBL1, TBL2 테이블에 대해 SQL을 수행한 결과인 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j104-1.png,,,,,,집합 연산자는 SQL에서 위에 정의된 연산자가 먼저 수행된다. 그러므로 UNION이 나중에 수행되므로 결과적으로 중복 데이터가 모두 제거되어 ④과 같은 결과가 도출된다. 만일 UNION과 UNION ALL의 순서를 바꾼다면 ③과 같은 결과가 도출된다,4
194,,,다음 보기의 SQL문을 실행했을 때의 결괏값은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j307-1.png,SELECT SUM(SCORE) / COUNT(NO) FROM Mytest,400,300,200,100,"COUNT(칼럼명)으로 조회를 하는 경우는 NULL 값이 제외된다. 따라서 3이 된다. 즉, 합계 1200/3=400이다.",1
195,,,다음 중 사원엔터티에서 식별자의 특성에 해당하지 않는것은 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j25-1.png,,인조식별자,내부식별자,단일식별자,주식별자,,1
196,,,"아래의 영화 데이터베이스 테이블의 일부에서 밑줄 친 속성들은 테이블의 기본키이며 출연료가 8888 상인 영화명, 배우명, 출연료를 구하는 SQL로 가장 적절한것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j87-1.png,,"SELECT 영화.영화명, 배우.배우명, 출연료 FROM 배우, 영화, 출연 WHERE 출연료 >= 8888 AND 출연.영화번호 = 영화.영화번호 AND 출연.배우번호 = 배우.배우번호;","SELECT 영화명, 배우명, 출연료 FROM 배우, 영화, 출연 WHERE 출연료 >= 8888 AND 영화번호 = 영화.영화번호 AND 배우번호 = 배우.배우번호;","SELECT 영화.영화명, 배우.배우명,출연료 FROM 영화, 배우, 출연 WHERE 출연.출연료〉8888 AND 출연.영화번호 = 영화.영화번호 AND 영화.영화번호 = 배우. 배우번호;","SELECT 출연.영화명, 영화.배우명, 출연.출연료 FROM 배우, 영화, 출연 WHERE 출연료〉= 8888 AND 출연.영화번호 = 영화.영화번호 AND 출연.배우번호 = 배우.배우번호;",,1
197,,,다음 중 아래와 같은 테이블에서 SQL을 실행할 때 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j131-1.png,,,,,,"위의 SQL은 고객별 매출액과 매출 순위를 구하되 동일 순위일 경우 중간 순위를 비워둔 데이터를 추출한다. 순위를 구하는 함수로는 RANK, DENSE_RANK, ROW_NUMBER 함수가 있다. RANK WINDOW FUNCTION은 동일 값에 대해서는 동일 순위를 부여하고 중간 순위는 비워 두지만, DENSE_RANK 함수는 동일 순위를 부여하되 중간 순위를 비우지 않는다. ROW_NUMBER 함수는 동일 값에 대해서도 유일한 순위를 부여한다.",4
198,,,주어진 테이블에 대해서 아래와 같은 결괏값을 반환하는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j494-1.png,,"SELECT COUNT(CASE WHEN BAN=1 THEN 1 END) AS Result, COUNT(CASE WHEN BAN=2 THEN 1 END) AS B, COUNT(CASE WHEN BAN=3 THEN 1 END) AS C FROM TEST15;","SELECT BAN, COUNT(DISTINCT NAME) AS RESULT FROM TEST15 GROUP BY BAN;","SELECT BAN, COUNT(1) AS RESULT FROM TEST15 GROUP BY BAN;","SELECT BAN, COUNT(*) AS RESULT FROM TEST15 GROUP BY BAN;",②번 보기는 BAN칼럼으로 그룹핑하고 DISTINCT를 사용해서 중복된 이름을 제거하고 카운팅한다.,2
199,,,다음의 SQL문을 실행했을 때 그 결과가 다른 하나는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j415-1.png,"SELECT NVL(COL2,COL3) AS 금액A, COALESCE(COL2,COL3) AS 금액B, NULLIF(COL2,COL3) AS 금액C, CASE WHEN COL2 IS NOT NULL THEN COL2 ELSE COL3 END AS 금액D FROM Mytest",금액D,금액C,금액B,금액A,"②번 보기에서의 연산자인 NULLIF는 COL2와 COL3이 동일하면 NULL을, 동일하지 않으면 COL2를 반환하는데 3번째 행에서 COL2, COL3 값이 다르므로 해당 행에서의 COL2 값인 NULL 값을 반환한다.",2
200,,,다음 SQL문의 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j659-1.png,SELECT * FROM 고객 ORDER BY 포인트 DESC OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY;,,,,,고객 테이블에서 포인트가 높은 순서대로 정렬을 한 후 2개의 행을 건너 뛰고 3번째부터 2개의 행을 뽑는다.,4
201,,,다음 주어진 ERD 관계에 대한 설명으로 옳지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j527-1.png,,GROUP 릴레이션은 여러 명의 UserID를 가질 수 있다.,GROUP 릴레이션은 한 명의 UserID도 없을 수 있다.,GROUP 릴레이션과 ACCOUNT 릴레이션은 식별 관계를 가진다.,하나의 UserID는 여러 개의 GroupID를 가질 수 없다.,"GROUP 릴레이션과 ACCOUNT 릴레이션의 관계는 식별 관계이다. 즉, GROUP 릴레이션의 GroupID가 ACCOUNT 릴레이션의 기본키로 사용되지 않았다.",3
202,,,아래의 ERD에서 3차정규형을 만족할 때 엔터티의 개수는 몇 개가 되는가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j474-1.png,,4개,3개,2개,1개,,2
203,,,아래와 같이 월별매출 테이블에 데이터가 입력되어 있다. 다음 중 2014년 11월 부터 2015년 03월까지의 매출금액 합계를 출력하는 SQL 문장으로 옳은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j67-1.png,,SELECT SUM(매출금액) AS 매출금액합계 FROM 월별매출 WHERE 년 = '2014' AND 월 BETWEEN '11' AND '12' OR 년 = '2015' AND 월 BETWEEN '01' AND '03';,SELECT SUM(매출금액) AS 매출금액합계 FROM 월별매출 WHERE (\년 = '2014' OR 년 = '2015') AND (월 BETWEEN '01' AND '03' OR 월 BETWEEN '11' AND '12');,"SELECT SUM(매출금액) AS 매출금액합계 FROM 월별매출 WHERE 년 IN ('2014', '2015') AND 월 IN ('11', '12', '03', '04', '05');",SELECT SUM(매출금액) AS 매출금액합계 FROM 월별매출 WHERE 년 BETWEEN '2014' AND '2015' AND 월 BETWEEN '03' AND '12';,,1
204,,,다음 중 아래의 ERD를 참조하여 아래 SQL과 동일한 결과를 출력하는 SQL로 가장 부적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j116-1.png,,"SELECT A.회원번호, A.회원명 FROM 회원 A, 동의항목 B WHERE A.회원번호 = B.회원번호 AND B.동의여부 = 'N' GROUP BY A.회원번호, A.회원명 ORDER BY A.회원번호;","SELECT A.회원번호, A.회원명 FROM 회원 A WHERE 0 < (SELECT COUNT(*) FROM 동의항목 B WHERE B.동의여부 = 'N') ORDER BY A. 회원번호;","SELECT A.회원번호, A.회원명 FROM 회원 A WHERE A. 회원번호 IN (SELECT B.회원번호 FROM 동의항목 B WHERE B. 동의여부 = 'N') ORDER BY A. 회원번호;","SELECT A.회원번호, A.회원명 FROM 회원 A WHERE EXISTS (SELECT 1 FROM 동의항목 B WHERE A.회원번호 = B.회원번호 AND B. 동의여부 = 'N') ORDER BY A. 회원번호;",위의 SQL은 약관항목 중 단 하나라도 동의를 하지 않은 회원을 구하는 SQL이다. HAVING 절에서 동의여부가 N인 데이터가 한 건이라도 존재하는 데이터를 추출한다. ①는 HAVING절로 처리되던 조건을 WHERE절에 위치시켜 더 간편하게 Join으로 처리하였다. 또한 회원과 동의항목은 1:N 관계이므로 JOIN된 결과는 N건으로 발생됨에 따라 GROUP BY를 추가하여 중복을 제거 하였다. ②의 회원 테이블과 동의항목 테이블간에 회원번호 컬럼으로 연관 서브쿼리로 처리되어야 정상적으로 처리할 수 있다. ③는 동의항목 테이블에서 동의여부가 N인 한 건이라도 존재하는 회원을 추출하여 회원테이블과 IN 연산을 수행한다. ④은 회원 테이블과 동의항목 테이블의 회원번호 컬럼으로 연관 서브쿼리를 수행하여 동의여부 컬럼의 값이 N인 데이터가 한 건이라도 존재하면 회원 데이터를 출력하게 된다.,2
205,,,다음 중 아래의 테이블에서 SQL을 실행할 때 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j124-1.png,"[SQL] SELECT CASE WHEN GROUPING(A.서비스ID) = 0 THEN A.서비스ID ELSE '합계', END AS 서비스ID ,CASE WHEN GROUPING (B.가입일자) = 0 THEN NVL (B.가입일자, '-') ELSE '소계' END AS 가입일자 ,COUNT (B. 회원번호) AS 가입건수 FROM 서비스 A LEFT OUTER JOIN 서비스가입 B ON (A.서비스ID = B. 서비스ID AND B.가입일자 BETWEEN '2013-01-01' AND '2013-01-31') GROUP BY ROLLUP (A.서비스ID, B.가입일자);",execute 'TRUNCATE TABLE DEPT';,execute immediate 'TRUNCATE TABLE DEPT';,DELETE FROM DEPT;,TRUNCATE TABLE DEPT;,ROLLUP은 계층 구조를 가진 SUB TOTAL을 생성하는 함수로 나열된 컬럼의 순서가 변경되면 수행 결과도 변경된다. 위의 SQL문장은 서비스ID에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수 를 구하되 Outer Join을 수행하였으므로 가입내역이 없는 서비스ID(004)에 대해서도 SUB TOTAL을 출력하고 있다. ④은 서비스ID 에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수를 구한 것은 맞으나 LEFT OUTER JOIN이 아닌 INNER JOIN에 대한 결과로 서비스ID 004가 출력되지 않았다.,2
206,,,아래 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j612-1.png,"SELECT E.*, LEVEL FROM 사원 E START WITH 매니저사원번호 IS NULL CONNECT BY PRIOR 사원번호 = 매니저사원번호 AND EXTRACT(MONTH FROM 입사일자) >= 7 ORDER SIBLINGS BY 이름;",,,,,"매니저 사원번호가 NULL인 지점을 시작으로 레벨 1을 부여, 나사장의 사원번호를 매니저 사원번호로 가지면서 하반기 입사자인 행을 찾아 레벨 2를 부여한다. 이렇게 연결된 행으로부터 CONNECT 절의 조건을 만족하는 행을 계속 이어 나간다. 이때, START WITH 절은 CONNECT BY에 있는 조건에 따라 생략되지 않기 때문에 나사장이 상반기 입사자라도 출력된다.",3
207,,,"다음 중 RANK, DENSE_RANK, ROW_NUMBER 결과로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j657-1.png,"SELECT NO, RANK() OVER(ORDER BY JUMSU DESC) AS RANK1, DENSE_RANK() OVER(ORDER BY JUMSU DESC) AS RANK2, ROW_NUMBER() OVER(ORDER BY JUMSU DESC) AS RANK3 FROM STUDENT;",,,,,"RANK는 동점일 경우 같은 등수로 표시하고 다음 순위는 동점인 순위의 수만큼 밀리므로 12245가 출력되지만 DENSE_RANK는 동점일 경우 동순위를 부여 뒤, 다음 순위가 바로 이어지므로 12234가 리턴된다. ROW_NUMER는 동점일 경우를 인정하지 않고 순서대로 나열하므로 12345가 최종 출력된다.",3
208,,,다음의 SQL문 실행 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j431-1.png,"SELECT COUNT(DATA1), COUNT(DATA2) FROM (SELECT DISTINCT DATA1, DATA2 FROM Mytest);","1,1","2,2","2,1","1,3","인라인 뷰에 있는 DISTINCT구는 중복을 제거하기 때문에 1,A 와 1,B 두개의 행이 조회된다. 따라서 행 수를 계산하는 COUNT는 2,2가 조회된다.",2
209,,,아래 ERD에 대한 설명으로 가장 적절하지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j574-1.png,,하나의 서비스 구매 이력은 고객 정보가 없을 수 있다.,하나의 서비스 구매는 반드시 한 명의 고객에 의해 주문된다.,한 명의 고객은 서비스를 구매하지 않을 수 있다,한 명의 고객은 여러 개의 서비스를 구매할 수 있다.,"고객과 서비스 구매의 관계의 차수는 1 이므로 하나의 고객이 여러 서비스를 구매할 수 있다. 또한 고객 -> 서비스 구매는 선택적 관계이므로 어떤 고객은 서비스를 구매하지 않아도 되지만, 반대는 필수적 관계이므로 서비스 구매는 구매한 고객이 반드시 정의되어야 한다.",1
210,,,다음 주어진 ERD 관계에 대한 설명으로 옳은 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j166-1.png,,계정은 반드시 계정 그룹을 가져야 한다.,계정 그룹은 사용자를 반드시 가져야 한다.,계정 그룹은 다수의 사용자를 가질 수 없다.,계정은 다수의 계정 그룹을 가질 수 있다.,-ERD 관계에서 계정 그룹은 다수의 계정을 포함할 수도 있고 안 할 수도 있다. -계정은 반드시 단 하나의 계정 그룹에 소속되어야 한다.,1
211,,,"다음 보기에서 One to One, One to Many를 표현하고 있다. ERD에서 표현하고 있는 두 엔터티 간의 관계에서 수행되는 인스턴스의 수를 무엇이라고 하나?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j403-1.png,,관계 분류,관계 선택사양,관계 차수,관계명,"카디날리티는 두 개의 엔터티에서 관계에 참여하는 수이다. 1:1, 1:N, M:N이 있다. 카디날리티의 계산은 선택도 * 전체 레코드 수이다.",3
212,,,아래의 SQL의 출력 결과 중 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j604-1.png,SELECT COUNT(*) FROM TAB1 WHERE EXISTS (SELECT 1 FROM TAB2 WHERE TAB2.COL1 = 'A');,3,1,0,,서브쿼리 결과가 항상 거짓이므로 조건에 만족하는 행이 없다. 이 경우 COUNT는 NULL이 아닌 0을 리턴한다.,3
213,,,다음 ERD로 작성한 SQL문에서 오류가 발생하는 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j552-1.png,,SELECT SUM(주문금액) FROM 일자별주문내역 WHERE EXISTS(SELECT * FROM 고객마스터 UNION ALL SELECT * FROM 일자별주문내역) GROUP BY 회원번호,"SELECT SUM(일자별주문내역,주문금액) FROM 고객마스터, 일자별주문내역 WHERE 고객.회원번호 = 일자별주문내역,회원번호 GROUP BY 회원번호","SELECT SUM(일자별주문내역,주문금액) FROM 일자별주문내역 FULL OUTER JOIN 고객마스터 on 고객.회원번호 = 일자별주문이력.회원번호 GROUP BY 회원번호;",SELECT (SELECT SUM(주문금액) FROM 일자별주문내역) FROM 고객마스터 GROUP BY 회원번호;,UNION 및 UNION ALL구를 사용할 때 나오는 SQL문은 칼럼 수와 데이터 타입이 완전 일치해야 한다. 하지만 ①번은 고객마스터와 일자별주문내역에 나오는 칼럼의 수가 일치하지 않는다.,1
214,,,"아래와 같은 테이블 TAB1, TAB2가 있을 때 아래의 SQL의 결과 건수를 알맞게 나열한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j600-1.png,SELECT * FROM TAB1 A INNER JOIN TAB2 B ON (A.KEY1 = B.KEY2) SELECT * FROM TAB1 A LEFT OUTER JOIN TAB2 B ON (A.KEY1 = B.KEY2) SELECT * FROM TAB1 A FULL OUTER JOIN TAB2 B ON (A.KEY1 = B.KEY2) SELECT * FROM TAB1 A CROSS JOIN TAB2 B SELECT * FROM TAB1 A NATURAL JOIN TAB2 B,3 6 8 12 4,3 5 6 16 3,2 5 6 16 4,2 4 6 8 3,"INNER JOIN은 값이 같으면 모두 출력되므로 TAB1의 KEY1의 값이 BB인 경우 2건, CC와 DD는 일치하는 값이 없으므로 생략, EE는 한 건이 출력되어 총 3건이 리턴된다. LEFT OUTER JOIN은 TAB1의 KEY1의 값이 모두 출력돼야 하므로 앞의 INNER JOIN 결과에 CC와 DD가 추가적으로 리턴되어 총 5건이 된다. FULL OUTER JOIN은 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과의 합집합(중복 값은 한 번만 출력)이므로 총 6건이며 CROSS JOIN의 경우는 모든 발생 가능한 조합이므로 4X4, 16건이 리턴된다. NATURAL JOIN에 의해 COL1, COL2 값이 같은 값만 출력되며 이때 NULL은 같다고 볼 수 없기 때문에 제외되어 총 3건이 출력된다.",2
215,,,아래 SQL 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j599-1.png,"SELECT COUNT(*) FROM TAB1, TAB2 WHERE NAME LIKE RULE_NAME;",3,2,1,0,"TAB1을 RULE_NAME에 매핑되는 규칙으로 TAB2에 조인을 수행했기 때문에, 각 행마다 LIKE 조건이 일치하면 TAB2 값이 출력된다. 즉, SCOTT은 %O%와, FORD는 %O%와 F% 둘 다 매핑되어 행이 두 개로 출력된다. 따라서 총 행의 수는 3건이 리턴된다.",1
216,,,아래와 같은 테이블 데이터가 있다. 각 SQL에 대한 결과값이 잘못된 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j601-1.png,,,,,,"1번. NOT EXISTS 연산자는 반대로 서브쿼리 결과가 거짓이면 출력된다. 따라서 NULL끼리 같은 조건은 항상 거짓이므로 TAB1의 V1이 NULL인 경우와 C가 최종 리턴된다. 2번. EXISTS 연산자는 서브쿼리 결과가 참이면 메인 쿼리 결과가 리턴된다. 따라서 TAB1의 각 행마다 A.V1 = B.V1이 만족하면 TAB1 결과가 출력되므로 V1이 A, B인 행이 선택된다. 3번. NOT IN 연산자는 서브쿼 리 결과에 NULL이 포함될 경우 전체가 거짓이 되므로 아무것도 출력되지 않는다. V1 NOT IN ('A', NULL, 'B', 'C') => NOT (V1 = 'A' OR V1 = NULL OR V1 = 'C') => V1 != 'A' AND V1 != NULL AND V1 != 'C' V1 != NULL은 거짓이므로 이 조건으로 인해 전체 조건이 거짓이 된다. 4번. NULL은 IN 연산자에 의해 출력되지 않기 때문에 V1이 A, B인 경우만 리턴된다.",3
217,,,아래의 SQL 의 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j598-1.png,"SELECT SUM(A.COL1) FROM TAB1 A, TAB2 B WHERE A.COL2 <> B.COL2;",30,12,10,8,"NULL은 같지 않다에 참이 리턴되지 않는다. 따라서 TAB1 기준 COL2가 A인 경우는 1개, NULL인 경우 0개, B인 경우 1개, C인 경우 2개가 리턴된다. 따라서 이들의 COL1에 대한 총 합은 12가 된다.",2
218,,,다음 출력 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j615-1.png,"SELECT COUNT(COL1) FROM TAB1 WHERE REGEXP_LIKE(COL1, '[XY-]+Z?');",5,4,3,2,"[XY-]는 X 또는 Y 또는 -와 같다. 따라서 X, Y, - 중 하나가 여러 번 반복되면서 그 뒤에 Z값이 오거나 오지 않는 문자열 배열을 갖는 행은 전체이므로 총 5개가 출력된다.",1
219,,,두 개의 테이블에 대해서 UNION ALL을 실행 했을 때 조회되는 행 수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j341-1.png,"SELECT DISTINCT COL1, COL2 FROM MytestA UNION ALL SELECT COL1, COL2 FROM MytestB;",7,4,5,2,"첫 번째 테이블에서 DISTINCT로 중복된 행이 제외되어 (1,2),(1,3) 두개의 행만 남고 두번 째 테이블과 UNION ALL로 중복을 포함하여 합쳐져 (1,2),(1,3),(1,2),(1,4),(1,5) 5개의 행이 조회된다.",3
220,,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j790-1.png,SELECT COUNT(ENAME) FROM EMP WHERE ENAME NOT LIKE '_L%E%';,4,3,2,1,"두 번째 글자가 L이면서 그 뒤에 E를 하나 포함하는 이름을 제외하면 SMITH, KING, CLARK 가 출력된다.",2
221,,,주어진 테이블에 대해서 아래와 같이 결괏값이 반환되도록 아래의 SQL문 빈칸에 들어갈 윈도우 함수를 적으시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j562-1.png,"SELECT ENAME, SAL, ( ) as SM_CNT FROM SQLD_11;",COUNT(*) OVER(ORDER BY CNT RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 0 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),MAX(SAL) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),"먼저 위의 SQLD_11 테이블에서 결과값과 같이 반환되도록 'SAL' 속성을 기준으로 정렬을 수행하고, 각각의 행에서의 SAL 속성값을 기준으로 -50에서 +100범위 사이에 포함되는 SAL값을 가지는 모든 행의 수를 COUNT하여 SIM_CNT 속성값으로 조회한다.",3
222,,,다음과 같은 결괏값을 조회하기 위해서 SQL 문의 ( )에 알맞은 것을 넣으시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j309-1.png,"SELECT ENAME, SAL, ( ) as CNT FROM Mytest;",COUNT(*) OVER(ORDER BY CNT RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 0 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),MAX(SAL) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),"먼저 위의 Mytest 테이블에서 결괏값과 같이 반환되도록 ''SAL"" 속성을 기준으로 정렬을 수행하고 각각의 행에서의 SAL 속성값을 기준으로 -50에서 +150 범위 사이에 포함되는 SAL값을 가지는 모든 행의 수를 COUNT하여 CNT 속성값으로 조회한다.",3
223,,,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j663-1.png,"SELECT REGEXP_REPLACE(COL1, 'A(X|Y)+\.') FROM TAB1;",,,,,A 뒤에 X 또는 Y가 여러 개 오며 그 뒤에 .이 오는 문자열을 찾아 모두 지우는 쿼리문이다.,3
224,,,아래의 결괏값을 보고 SQL문의 빈칸에 들어 갈 수 있는 내용을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j299-1.png,"SELECT DEPTNO, JOB, SUM(SAL) FROM Mytest GROUP BY ( );","CUBE(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","GROUPING SETS(DEPTNO, JOB)","DEPTNO, JOB","주어진 결괏값을 보면 1, DEPTNO별 합계, 2.DEPTNO,JOB별 합계, 3.전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다.",2
225,,,"다음 엔터티를 제 3차 정규화를 수행했을 때 도출되는 엔터티의 수는(도서대출 포함)? (단, 하나의 대출자에 대해 하나의 대출번호로 여러 도서를 대출/반납할 수 있다고 가정)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j576-1.png,,4,3,2,1,"제 3 차 정규화는 이행적 종속을 없애도록 엔터티를 분리하는 것을 말한다. 대출번호 -> 대출자 번호 -> 대출자 명이 성립되므로 대출자 번호와 대출자 명(대출자 직업 포함)을 분리한다. 같은 방식으로 대출 도서 명, 출판사 명, 출판년월, 대표 저자 명을 도서 엔터티로 나누게 되면, 총 도서 대출, 대출자, 대출 도서 3 개의 엔터티로 나눌 수 있다.",2
226,,,아래 테이블 스키마를 참조하여 SQL 문장을 작성하였다. 다음 중 결과가 다른 SQL 문장은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j68-1.png,,"SELECT SVC_ID, COUNT(*) AS CNT FROM SVC_JOIN WHERE TO_DATE('201501', 'YYYYMM') = SVC_END_DATE AND JOIN_YMD| |JOIN_HH = '2014120100' GROUP BY SVC_ID;","SELECT SVC_ID, COUNT(*) AS CNT FROM SVC_JOIN WHERE '201501' = TO_CHAR(SVC_END_DATE, 'YYYYMM') AND JOIN_YMD = '20141201' AND JOIN _HH = '00' GROUP BY SVC_ID;","SELECT SVC_ID, COUNT(*) AS CNT FROM SVC_JOIN WHERE SVC_END_DATE〉= TO_DATE('20150101', 'YYYYMMDD') AND SVC_END_DATE < TO_DATE('20150201', 'YYYYMMDD') AND (JOIN_YMD, JOIN_HH) IN (('20141201', '00')) GROUP BY SVC_ID;","SELECT SVC_ID, COUNT(*) AS CNT FROM SVC_JOIN WHERE SVC_END_DATE >= TO_DATE('20150101000000', 'YYYYMMDDHH24MISS') AND SVC_END_DATE <= TO_DATE('20150131235959', 'YYYYMMDDHH24MISS') AND CONCAT(JOIN_YMD, JOIN_HH) = '2014120100' GROUP BY SVC_ID;",,1
227,,,"주식의 정보를 조회하는 프로그램이 있다. 이 때, 일자(BASE_DATE)와 종가(LAST_JUKA), 전일대비(DEBI_VAL)를 출력하는 SQL문으로 올바른 것을 고르시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j212-1.png,,"SELECT A.BASE_DATE, A.LAST_JUKA, B.LAST_JUKA-A.LAST_JUKA DEBI_VAL FROM (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A)a, (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A WHERE BASE_DATE > '20230104')b WHERE A.ROW1 = B.ROW1 AND A.BASE_DATE > '20230104';","SELECT A.BASE_DATE, A.LAST_JUKA, B.LAST_JUKA-A.LAST_JUKA DEBI_VAL FROM (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A)a, (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A WHERE BASE_DATE > '20230104')b WHERE A.BASE_DATE > '20230104';","SELECT A.BASE_DATE, A.LAST_JUKA, FROM (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A)a, (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A WHERE BASE_DATE > '20230104')b WHERE A.ROW1 = B.ROW1 AND A.BASE_DATE > '20230104';","SELECT A.BASE_DATE, A.LAST_JUKA, B.LAST_JUKA-A.LAST_JUKA DEBI_VAL FROM (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A)a, (SELECT ROWNUM ROW1, BASE_DATE, LAST_JUKA FROM TEST_A WHERE BASE_DATE > '20230104')b WHERE A.ROW1 = B.ROW1;",LAG 및 LEAD 함수를 사용하지 않고 이전 행과 다음 행의 값을 구하는 SQL문이다. 만약 LAG 함수와 LEAD 함수를 사용한다면 좀 더 쉽게 SQL 문을 작성할 수가 있다. LAG 함수는 이전 행의 값을 구하고 LEAD 함수는 다음 행의 값을 구한다.,1
228,,,주어진 테이블에 대해서 아래와 같은 결괏값이 나오도록 SQL 빈칸을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j397-1.png,"SELECT EMPLOYEE_ID, DEPARTMENT_ID, LAST_NAME, SALARY, LAG(SALARY,( )) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY) AS BEFORE_SALARAY FROM EMPLOYEES WHERE EMPLOYEE_ID < 110;",4,3,2,1,"LAG 함수는 이전 행의 값을 반환하는 함수이다. LAG(SALARY, 2)라고 하면 이전 두 번째 행 값을 반환하게 된다.",3
229,,,다음에서 주어진 Mytest 테이블에서 SQL문을 실행했을 때 결괏값과 같은 SQL문은?(단 union은 정렬도 진행하는 것으로 한다),https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j293-1.png,,"select * from (select job_id, max(salary) from Mytest group by salary union all select job_id, min(salary) from Mytest group by salary );","select * from (select job_id, max(salary) from Mytest group by job_id union all select job_id, min(salary) from Mytest group by job_id );","select * from (select job_id, max(salary) from Mytest group by salary union select job_id, min(salary) from Mytest group by salary );","select * from (select job_id, max(salary) from Mytest group by job_id union select job_id, min(salary) from Mytest group by job_id );",결괏값은 주어진 테이블에서 JOB_ID 별로 그룹화하였을 때 각 JOB_ID별 salary의 최댓값과 최솟값이 반환되는 결괏값이다. 그런데 JOB_ID 별 salary 값이 하나의 속성값으로 통일되었으므로 union 연산자를 이용한다.,4
230,,,아래 SQL의 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j640-1.png,SELECT SUM(SAL) FROM TAB1 WHERE NO NOT IN (SELECT NO FROM TAB2 GROUP BY NO);,700,600,,0,NOT IN문의 서브쿼리 결과 중 NULL이 포함되는 경우 데이터가 출력되지 않는다. NULL은 논리적으로 비교할 수 없는 연산이기 때문에 NULL을 비교하는 연산자로 인해 전체조건이 거짓이 된다. 조건에 만족하는 값이 없으므로 SUM 결과는 NULL이 된다.,3
231,,,다음 SQL 중 수행이 불가능 한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j765-1.png,,"INSERT INTO TAB2 (SELECT NO, NAME, JUMIN FROM TAB1);","INSERT INTO TAB1 SELECT NO, NAME, JUMIN, NULL FROM TAB2;","INSERT INTO TAB1(NO, NAME, JUMIN) AS SELECT * FROM TAB2;","INSERT INTO TAB2 SELECT NO, NAME, JUMIN FROM TAB1;",INSERT SELECT 구문에는 AS가 붙지 않는다. 양쪽 테이블의 컬럼수가 다르므로 INSERT 시 적절하게 컬럼수를 맞 춰서 입력해야 한다.,3
232,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j752-1.png,"SELECT NAME, NVL((SELECT FARE FROM PROMOTION P2 WHERE P1.CODE = P2.CODE), 100) PRO_FARE FROM PRODUCT P1;",,,,,"스칼라 서브쿼리는 OUTER JOIN을 수행하지 않아도 연결 조건에 만족하지 않는 행도 출력된다. 즉, D가 출력되는데, NVL로 NULL을 100으로 치환하고 있으므로 D의 PRO_FARE는 100으로 리턴된다.",2
233,,,다음 주어진 테이블에서 아래와 같은 결괏값을 반환하도록 아래의 SQL문의 빈칸에 들어갈 올바른 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j200-1.png,,DENSE_RANK(),ROW_NUMBER(),NTILE(),RANK(),결괏값에서 중복된 등수 2등 다음에 바로 다음 등수인 3이 왔으므로 빈칸에는 DENSE_RANK 가 와야 한다.,1
234,,,아래 SQL에서 출력되는 ROWS의 개수를 구하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j210-1.png,"SELECT DNAME, JOB, COUNT(*) ""Total Emp"", SUM(SAL) ""Total Sal"" FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY CUBE(DNAME,JOB);",20건,18건,14건,10건,DEPTNO로 조인을 하고 DNAME과 JOB으로 CUBE를 실행했다. CUBE는 전체합계와 각 칼럼별로 부분합계를 출력한다. CUBE는 입력된 칼럼들의 모든 조합으로 집계를 출력한다.,2
235,,,다음 SQL문의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j736-1.png,"SELECT DECODE(DEPTNO, 10, DECODE(JOB, 'CLERK', 'A', 'B'), 'C') AS RESULT FROM EMP ORDER BY EMPNO;",,,,,"DEPTNO가 10이면서 JOB이 CLERK인 경우 A, DEPTNO가 10이면서 JOB이 CLERK가 아닌 경우는 B를 리턴하며, DEPTNO가 10이 아닌 경우는 모두 C를 리턴한다.",4
236,,,다음 SQL 수행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j639-1.png,"SELECT COALESCE(COL1, COL2, COL3) RESULT FROM TAB1;",,,,,"COALESCE 함수는 대상들 중 널이 아닌 첫 번째 값을 출력하므로 첫 번째 행부터 10, 10, 20 이 출력된다.",3
237,,,아래 실행 결과를 출력하는 SQL로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j660-1.png,"SELECT 사원번호, 이름, LEVEL FROM 사원 START WITH 사원번호 IN (1006, 1001) CONNECT BY PRIOR 상위관리자코드 = 사원번호;",,,,,"START WITH 조건이 1006과 1001이므로 두 행이 1레벨이 되고, 해당 행의 상위관리자코드를 사원번호로 갖는 행을 찾으면 둘 다 홍길동이 출력된다. 따라서 정답은 3번이 된다.",2
238,,,주어진 데이터에서 아래의 SQL문을 실행한 행의 건수로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j479-1.png,"SELECT COUNT(*) FROM SQLD49, SQLD49_2 WHERE SQLD49.COL1 = SQLD49_2.COL1;",3,4,9,1,INNER JOIN이므로 JOIN조건을 만족하는 행만 가져와서 조건을 수행한다.,3
239,,,다음 중 고객과 주문의 ERD에 대한 설명으로 가장 부적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j7-1.png,,고객에 데이터를 입력할 때는 주문데이터가 존재하는 고객만을 입력할 수 있다.,주문에 데이터를 입력할 때는 반드시 고객데이터가 존재해야 한다.,하나의 주문은 반드시 한 명의 고객에 의해 주문된다,한 명의 고객은 여러 개의 제품을 주문 할 수 있다. 주문은 할 수도 있고 안 할 수도 있다.,,1
240,,,다음 SQL 실행 결과 중 다른 하나는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j610-1.png,,"SELECT 성적 FROM (SELECT 성적, ROWNUM AS RN FROM EXAM ORDER BY 성적 DESC) WHERE RN <= 3;","SELECT 성적 FROM (SELECT 성적, RANK() OVER(ORDER BY 성적 DESC) AS RN FROM EXAM) WHERE RN <= 2;",SELECT TOP(2) WITH TIES 성적 FROM EXAM ORDER BY 성적 DESC;,SELECT 성적 FROM EXAM ORDER BY 성적 DESC FETCH FIRST 3 ROWS ONLY;,"성적이 높은 순서대로 3명을 뽑는 쿼리로 적절한 것은 1, 2, 3번 보기이다. 2번의 경우 WITH TIES를 사용하여 동순위까지 출력하므로 98점과 함께 80점 두 명이 모두 출력된다. 하지만 ROWNUM의 경우 SELECT 절이 ORDER BY 절보다 먼저 수행되므로 SELECT 절에서의 ROWNUM은 ORDER BY 결과를 반영하지 못한다. 따라서 성적이 높은 순서대로 RN의 값이 형성되지 않기 때문에 원하는 결과를 얻을 수 없다.",1
241,,,다음은 WINDOW 함수를 사용해서 순위를 구한 것이다. 다음 중 빈칸의 내용으로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j290-1.png,"SELECT ( ) OVER (ORDER BY 급여 desc) as 순위, 이름, 급여 FROM Mytest;",ROW(),ROW_NUMBER(),DENSE_RANK(),RANK(),결괏값에서 중복된 등수 2등 다음에 바로 다음 등수인 3등이 왔으므로 빈칸에는 DENSE_RANK가 와야 한다.,3
242,,,다음의 SQL문에서 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j475-1.png,,부서별 합계를 계산할 때 NULL 값을 만나면 0으로 치환한다.,DEPTNO 10의 합계는 3000이고 20의 합계는 500이다.,"NVL(SAL, 0)문에서 NVL은 NULL에 대한 합계 오류를 예방한다.",SELECT문에 WHERE 조건이 없으므로 연산에 참여하는 총 행의 수는 2개이다.,해당 쿼리문의 경우 각각 칼럼에 NULL이 있으면 여러개 칼럼을 0으로 치환하는 연산이 수행되기 때문에 비효율적이다. 실무적인 측면에서는 NVL 함수를 바깥에서 1회만 사용할 수 있도록 처리해야 한다.,3
243,,,주어진 테이블에서 중복되는 이름 중 COL1이 제일 작은 것만 반환하는 SQL문을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j386-1.png,,"SELECT MIN(COL1), COL2 FROM Mytest GROUP BY COL1","SELECT MAX(COL1), COL2 FROM Mytest GROUP BY COL1","SELECT MIN(COL1), COL2 FROM Mytest GROUP BY COL2","SELECT MAX(COL1), COL2 FROM Mytest GROUP BY COL2","주어진 테이블에서 NAME별로 그룹을 지었을 때, 각 NAME별 ID의 최솟값을 가지는 행들만 제외하고 모두 삭제하여 1,3,4행만 조회된다.",3
244,,,다음 보기의 결과값과 동일하게 반환하는 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j295-1.png,,select * from Mytest where 회원번호 = 103 order by 주문금액 desc;,select * from Mytest where 회원번호 = 103 order by 주문금액,select * from Mytest where 회원번호 = 103,select * from Mytest where order by 주문금액 asc,위의 결괏값은 주어진 테이블에서 회원번호 = 103에 해당하는 ROW를 먼저 선택한 후 선택된 ROW에 대해서 주문금액을 기준으로 내림차순 정렬한 것이다.,1
245,,,AUTO COMMIT이 FALSE로 설정된 환경에서 다음의 SQL문을 실행했을 때의 결과로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j384-1.png,CREATE TABLE MYTEST_TEMP (COL1 NUMBER(10)); UPDATE MYTEST SET COL1=130 WHERE COL2=10; ROLLBACK;,AUTO COMMIT이 FALSE이므로 UPDATE구는 자동 COMMIT되지 않는다.,ORACLE에서 ROLLBACK을 실행하면 테이블은 생성되지 않는다.,ORACLE에서 ROLLBACK을 수행하면 UPDATE구는 취소된다.,SQL SERVER에서 ROLLBACK을 하는 경우 UPDATE구는 취소된다.,CREATE TABLE 문구와 같은 DDL구는 ROLLBACK으로 취소되지 않는다.,2
246,,,다음의 주어진 테이블에서 아래의 SQL문을 수행하였을 때의 결과가 RESULT와 같을 때 SQL문의 (ㄱ)에 들어갈 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j350-1.png,"SELECT VAL, COUNT(*) AS CNT FROM( SELECT( ㄱ )(4) over (ORDER BY COL1) AS VAL FROM Mytest ) WHERE 1=1 GROUP BY VAL ORDER BY 1;",LAG,RANK,LEAD,NTILE,"NTILE 함수는 expr에 명시된 값만큼 파티션을 균등하게 분할하는 함수로 expr에 명시된 숫자가 4이고 order by가 1이니 오름차순 정렬로 총 4개의 VAL속성값으로 파티션이 분할되며 각 파티션별로 행의 수가 균등하게 분할되어 3,3,2,2의 행의 수로 각각 분할된다.",4
247,,,"다음의 ""Mytest17"" 테이블에서 아래의 SQL문을 수행한 결과로 알맞은 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j372-1.png,SELECT SUM(C1+C2+C3+C4) FROM Mytest7 UNION ALL SELECT SUM(C1) + SUM(C2) + SUM(C3) + SUM(C4) FROM Mytest17;,"NULL, NULL","50, 260","NULL, 260","50, NULL","1번째 경우는 4개의 칼럼(C1,C2,C3,C4)모두 NULL이 아닌 값을 가지는 행에 대해서만 합계가 계산되므로 첫 번째 행에서의 칼럼들의 합계만 계산된다. 2번째 경우는 4개의 칼럼에 대해서 각각의 합계가 계산되고 이후에 각 합계들의 최종적인 합계가 계산된다.",2
248,,,다음 주어진 테이블에 대해서 [결과]와 같이 반환되게 하는 SQL문을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j497-1.png,"SELECT DNAME, JOB, SUM(SAL) FROM TEST18 GROUP BY ( )",CUBE(DNAME),"GROUPING SETS(DNAME,JOB)","ROLLUP(DNAME,JOB)","CUBE(DNAME,JOB)","결괏값을 보면 1.DNAME, JOB별 소계 2.DNMAE 별 소계 3.JOB별 소계 4.전체 집계 등 모든 조합 가능한 소계와 집계가 조회되었으므로 빈칸에 들어갈 그룹 함수는 CUBE이다.",4
249,,,다음 슈퍼타입/서브타입 모델에서 설계 단계에서 변환할 수 있는 테이블의 형태가 아닌 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j163-1.png,,"슈퍼타입(부동산관계자)과 서브타입(부동산전세자, 부동산소유자)을 모두 1:1 관계로 해체하여 개별로 테이블을 만드는 타입","부동산관계자의 일부 속성은 부동산전세자에게, 일부 속성은 부동산소유자에게 할당하여 배치하는 수평 분할 타입","슈퍼타입(부동산관계자)과 서브타입(부동산전세자, 부동산소유자)을 슈퍼+서브타입인 부동산전세자, 부동산소유자 2개 테이블로 만든 타입",전체가 하나의 테이블인 부동산관계자로 통합하는 All in One 타입,논리적인 데이터 모델에서 이용이 되는 슈퍼/서브 타입의 데이터 모델을 성능을 고려한 물리적인 데이터 모델에서 변환하는 방법은 세 가지가 있다.,2
250,,,다음 계층형 쿼리문에 대한 설명으로 옳지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j458-1.png,"SELECT ID, PARENT_ID, NAME, PARENT_NAME FROM SQLD_13 WHERE PARENT_ID NOT IN (3) START WITH PARENT_ID = 0 CONNECT BY PRIOR ID = PARENT_ID ORDER SIBLINGS BY PARENT_ID ASC, ID ASC;",ORDER SIBLINGS BY를 하면 전체 테이블 기준으로 정렬한다.,중복이 생겼을 때 루프를 돌지 않기 위해 NO CYCLE 옵션을 사용할 수 있다.,순방향 전개다.,PARENT_ID가 0이라도 3이 포함되면 전개를 멈춘다.,"④의 경우, 계층쿼리는 일단 START WITH_CONNECT BY로 전개를 수행한 후에 WHERE로 필터링을 한다. 만약 CONNECT BY에 AND 조건을 PARENT_ID != 3 식이었다면 전개 중에 멈추겠지만 WHERE에서 필터링을 하는 것이므로 일단 전개를 완료한 후에 WHERE가 실행되는 것으로 볼 수 있다.",1
251,,,다음 중 아래의 EMP 테이블의 데이터를 참조하여 실행한 SQL의 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j103-1.png,,,,,,"UNION ALL을 사용하는 경우 칼럼 ALIAS는 첫번째 SQL 모듈 기준으로 표시되며, 정렬 기준은 마지막 SQL 모듈에 표시하면 됨.",3
252,,,다음 주어진 테이블에서 부서코드 100의 상위부서코드를 찾는 SQL문을 만들도록 빈칸을 채워 넣으시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j197-1.png,,"ㄱ: WHERE, ㄴ: END WITH, ㄷ : CONNECT BY PRIOR","ㄱ: WHERE, ㄴ: START, ㄷ : CONNECT BY PRIOR","ㄱ: WHERE, ㄴ: START WITH, ㄷ : CONNECT BY PRIOR","ㄱ: WHERE, ㄴ: START , ㄷ : CONNECT BY","부서코드 100부터 시작하여 상위부서코드를 상위계층, 부서코드를 하위계층으로 하여 각 상위부서코드별 부서코드값이 계층적으로 조회되는데 WHERE 조건으로 부서코드 = 100에 대한 상위부서코드값이 조회된다. START WITH 문법으로 상위부서코드가 0인 행부터 전개를 시작한다.",3
253,,,다음 주어진 테이블에 대해서 수행하였을 때의 결괏값으로 잘못된 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j508-1.png,,,,,,"③번은 데이터가 조회되지 않는다. 왜냐하면 ROWNUM은 논리적인 숫자이기 때문에 ""ROWNUM=2""와 같이 조회하면 찾을 수 없다. 만약 ROWNUM=2와 같이 조회하고 싶다면 inline뷰를 사용해서 조회해야 한다.",3
254,,,아래와 같은 결과가 나오도록 (ㄱ)에 알맞은 SQL문을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j460-1.png,"SELECT 회원ID, DENSE_RANK() OVER(ORDER BY (ㄱ) ) AS RANK, 주문금액 FROM SQLD7;",주문금액 1,주문금액 ASC,(주문금액),(주문금액) DESC,결과 테이블은 주문금액이 큰 순서대로 순위를 부여하는 테이블로 주문금액 속성을 내림차순 정렬했을 때의 순위이고 같은 등수 다음에는 바로 다음 등수가 부여되었으므로 DENSE 랭크 함수가 들어가야 한다.,4
255,,,주어진 테이블에서 아래와 같은 결괏값을 반환하는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j202-1.png,,select * from SQLD_70 WHERE 회원번호 = 101;,select * from SQLD_70 WHERE 회원번호 = 101 order by 주문금액;,select * from SQLD_70 WHERE 회원번호 = 101 order by 주문금액 desc;,select * from SQLD_70 order by 주문금액 desc;,위의 결과값은 주어진 SQLD_70 테이블에서 회원번호 =101에 해당하는 ROW들을 먼저 선택한 후 선택된 ROW에 대해서 주문금액을 기준으로 내림차순 정렬한 것이다.,3
256,,,"아래 테이블 T, S, R이 각각 다음과 같이 선언되었다. 다음 중 DELETE FROM T; 를 수행한 후에 테이블 R에 남아있는 데이터로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j45-1.png,,"(1,1)","(2,2)","(1,NULL)과 (2,NULL)","(1,NULL)과 (2,2)",,3
257,,,다음 ERD를 참고하여 모든 회원의 상품 이용횟수와 총 이용가격을 출력하는 SQL로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j744-1.png,,"SELECT 회원.회원번호, COUNT(상품.상품번호), SUM(상품.가격) FROM 회원, 이용내역, 상품 WHERE 회원.회원번호 = 이용내역.회원번호(+) AND 이용내역.상품번호 = 상품.상품번호 GROUP BY 회원.회원번호;"," SELECT 회원.회원번호, COUNT(이용내역.상품번호), SUM(상품.가격) FROM 회원 LEFT OUTER JOIN 이용내역 ON 회원.회원번호 = 이용내역.회원번호 LEFT OUTER JOIN 상품 ON 이용내역.상품번호 = 상품.상품번호 GROUP BY 회원.회원번호;","SELECT 회원.회원번호, COUNT(상품.상품번호), SUM(상품.가격) FROM 회원 LEFT OUTER JOIN 이용내역 ON 회원.회원번호 = 이용내역.회원번호 JOIN 상품 ON 이용내역.상품번호 = 상품.상품번호 GROUP BY 회원.회원번호;","SELECT 회원.회원번호, COUNT(상품.상품번호), SUM(상품.가격) FROM 회원, 이용내역, 상품 WHERE 회원.회원번호 = 이용내역.회원번호 AND 이용내역.상품번호 = 상품.상품번호 GROUP BY 회원.회원번호;","ERD를 보면, 회원과 이용내역은 1대 다 관계이고 회원 -> 이용내역이 선택적 관계이다. 즉, 한 고객이 이용을 하지 않을 수 있기 때문에 상품을 이용하지 않은 고객까지 출력을 원한다면 OUTER JOIN이 수행돼야 한다. 또한 회원 엔 터티 기준으로 이용내역이 선택적 관계이면 상품관계 또한 회원 엔터티 입장에서 선택적이다(이용내역이 없으면 이 용 상품도 없기 때문) 따라서 상품 테이블도 OUTER JOIN이 수행돼야 한다. 따라서 가장 적절한 것은 3번이다. 4번 의 경우 두 번째 조인조건에서 상품.상품번호 뒤에도 (+)를 붙여야 상품 테이블에도 OUTER JOIN이 연산된다.",2
258,,,다음 중 아래 테이블에 대한 관계를 설명한 것으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j366-1.png,,주문은 상품을 하나도 안 가질 수 있다.,"주문 1개는 여러 개의 상품을 가질 수 있으며, 상품 1개는 여러 개의 주문에 속할 수 있다.","상품은 여러 개의 주문에 속할 수 있고, 주문은 하나의 상품만 가질 수 있다.","주문은 여러 개의 상품을 가질 수 있고, 상품은 하나의 주문에만 속할 수 있다.",M : N 관계를 가지고 있는 ERD이다. 하나의 주문은 여러 개의 상품을 가질 수 있고 하나의 상품도 여러 개의 주문을 가질 수가 있다.,2
259,,,다음 주어진 테이블들에 대해서 아래의 SQL문을 수행한 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j466-1.png,SELECT COUNT(DISTINCT COL1) FROM test31_1 WHERE COL3= (SELECT COL3 FROM test31_2 WHERE COL2 = 'A'),4,3,2,1,서브쿼리는 COL2가 'A'인 것을 조회하므로 10이 나온다. 그리고 test31_1 테이블에서 COL3가 10인 것을 조회한다. 그러면 2건이 조회된다. 왜냐하면 DISTINCT는 COL1로 수행하므로 중복된 것이 없다.,3
260,,,주어진 테이블에서 아래의 SQL문과 다른 값을 반환하는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j283-1.png,"SELECT * FROM Mytest WHERE (COL1, COL2) IN (('x','y'),('kk','BB'))",SELECT * FROM Mytest WHERE (COL = 'x' or COL1 = 'KK') and (COL2 = 'y' or COL2 ='BB');,SELECT * FROM Mytest WHERE (COL1 = 'x' and COL2 = 'KK') or (COL1 = 'y' and COL2 ='BB');,SELECT * FROM Mytest WHERE (COL1 = 'x' and COL2 = 'y') or (COL1 = 'KK' and COL2 ='BB');,"SELECT * FROM Mytest WHERE NOT (COL1, COL2) in (('A', 'B'), ('x', 'KK'), ('a','b'),('1','2'), ('y','BB'));","위의 SQL문은 COL1과 COL2값으로 각각 (x,y),(KK,BB)를 갖는 행들이 반환되지만 ②번 보기는 COL1 과 COL2 값으로 각각 (x,KK),(y,BB)값을 갖는 행들이 반환된다.",2
261,,,아래의 SQL문을 수행하였을 때의 결과가 [결과]와 같을 때 이에 대한 설명으로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j421-1.png,"SELECT mgr, empno, ename, LEVEL, CONNECT_BY_ISLEAF, SYS_CONNECT_BY_PATH(ENAME,'-') ""PATH"" FROM limbest.EMP START WITH mgr is null Connect by prior empno = mgr;",LEVEL은 계층의 깊이를 의미하며 TEST1은 최상위 계층이다.,자식에서 부모로 가는 역방향이다.,"CONNECT_BY_ISLEAF는 LEAF이면 1을, 아니면 0을 반환한다.",EMPNO 1000번의 MGR은 NULL 값이다.,위의 계층형 조회는 최상위 계층에서 하위 계층으로 검색하는 정방향 조회이다.,2
262,,,아래 SQL의 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j691-1.png,SELECT SUM(COL2 + COL3) FROM TAB1 WHERE COL1 IS NOT NULL;,33,12,,0,"COL1이 NULL이 아닌 값은 위의 세 행인데, 이들의 COL2+COL3의 값은 순서대로 NULL, 12, NULL이 된다. 따라서 총합은 12가 출력된다.",2
263,,,다음 중 아래와 같은 데이터 상황에서 SQL의 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j98-1.png,,,,,,,3
264,,,주어진 테이블들에 대해서 아래의 SQL문을 수행하였을 때 반환되는 ROW값의 수는 얼마인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j452-1.png,SELECT * FROM TEST1 UNION ALL SELECT * FROM TEST2 MINUS SELECT * FROM TEST3;,5,4,3,2,UNION ALL에 의해서 총 9개의 행이 반환된다. 그리고 MINUS로 차집합을 만든다.,1
265,,,아래와 같이 일자별매출 테아블이 존재할 때 아래 결과처럼 일자별 누적매출액을 SQL로 구하려고 한다. WINDOW FUNCTION을 사용하지 않고 일자별 누적매출액을 구하는 SQL로 옳은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j112-1.png,,"SELECT A.일자 ,(SELECT SUM(B.매출액) FROM 일자별매출 B WHERE B. 일자 >= A. 일자) AS 누적 매출액 FROM 일자별매출 A GROUP BY A. 일자 ORDER BY A. 일자;","SELECT A. 일자, SUM(B.매출액) AS 누적매출액 FROM 일자별매출 A JOIN 일자별매출 B ON (A. 일자〉= B. 일자) GROUP BY A. 일자 ORDER BY A. 일자;","SELECT B. 일자, SUM(B.매출액) AS 누적매출액 FROM 일자별매출 A JOIN 일자별매출 B ON (A. 일자〉= B. 일자) GROUP BY B. 일자 ORDER BY B. 일자;","SELECT A.일자, SUM(A.매출액) AS 누적매출액 FROM 일자별매출 A GROUP BY A.일자 ORDER BY A.일자;","④는 일자별매출액에 일자별 매출 테이블과 동일하게 출력된다. ①,③는 작은 날짜쪽에 제일 큰 누적금액이 출력된다. ②은 일자별매출 테이블을 Self Join하여, A Alias 쪽에 먼저 읽혔다고 가정하면 다음처럼 데이터가 생성될 것이다. 1.A가 {2015.11.01, 1000} 일 때 B는 {2015.11.01, 1000} 2. A가 {2015.11.02, 1000} 일 때 B는 {{2015.11.01, 1000}, {2015.11.02, 1000}} 3. A가 {2015.11.03, 1000} 일 때 B는 {{2015.11.01, 1000}, {2015.11.02,1000}, {2015.11.03, 1000}} 위의 Self Join은 Equi Join이 아닌 Range Join이므로 A의 레코드는 B의 레코드 수 만큼 증가하게 된다.(A * B) 그러므로 위의 3번의 경우 A는 B의 레코드 개수와 동일하게 되므로 SUM(매출금액)을 하면 3,000이 된다. 이런 식으로 A Alias의 모든 레코드 개수를 Scan하면 누적 값을 출력하게 된다.",2
266,,,다음 주어진 데이터에서 해당 SQL문을 실행 했을 때의 결괏값으로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j536-1.png,"SELECT A, SUM(X) AS TAB FROM TABLE_B GROUP BY A;",,,,,A 칼럼별로 그룹화하고 집계 함수에서 NULL값을 제외하고 연산을 수행한다.,2
267,,,아래 SQL 수행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j644-1.png,"SELECT COL1 FROM TAB1 ORDER BY CASE WHEN MOD(COL2, 3) = 0 THEN 'A' ELSE 'B' END, COL1;",,,,,"CASE문 결과를 1차 정렬로 한 뒤, 이 값이 같을 경우 COL1의 값으로 2차 정렬을 수행한다. 이렇게 정렬된 COL1의 값은 SCOTT, ALLEN, FORD, SMITH 순으로 출력된다.",3
268,,,"아래와 같이 데이터가 들어있지 않은 왼쪽의 기관분류 테이블 (가) 를 오른쪽 기관분류 테아블 (나) 처럼 변경하고자 할 때 다음 중 올바른 SQL 문장은? (단, DBMS는 SQLServer로 가정한다.)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j43-1.png,,ALTER TABLE 기관분류 ALTER COLUMN 분류명 VARCHAR(30) NOT NULL; ALTER TABLE 기관분류 ALTER COLUMN 등록일자 DATE NOT NULL;,ALTER TABLE 기관분류 ALTER COLUMN 분류명 VARCHAR(30); ALTER TABLE 기관분류 ALTER COLUMN 등록일자 DATE NOT NULL;,"ALTER TABLE 기관분류 ALTER COLUMN (분류명 VARCHAR(30) NOT NULL, 등록일자 DATE NOT NULL);","ALTER TABLE 기관분류 ALTER COLUMN (분류명 VARCHAR(30), 등록일자 DATE NOT NULL);",,1
269,,,"SQL의 LIKE 구문을 사용해서 데이터 내부에 ""_""이 있는 것을 검색하는 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j414-1.png,,SELECT * FROM Mytest WHERE NAME LIKE '%_%' ESCAPE '_',SELECT * FROM Mytest WHERE NAME LIKE '%@_%' ESCAPE '@',SELECT * FROM Mytest WHERE NAME LIKE '%#_%',SELECT * FROM Mytest WHERE NAME LIKE '%_%',LIKE 연산은 '%'나 '_'가 들어간 문자를 검색하기 위해서는 ESCAPE 명령어를 사용할 수 있다. 사용 방법은 '_' 나 '%' 앞에 ESCAPE로 특수 문자를 지정하여 검색한다.,2
270,,,아래의 데이터 모델을 기준으로 SQL을 작성하였다. 다음 중 아래의 SQL에 대해 가장 바르게 설명한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j117-1.png,,GROUP BY 및 집계함수를 사용하지 않고 HAVING절을 사용하였으므로 SQL이 실행되지 못하고 오류가 발생한다.,(ㄷ)은 이벤트 시작일자가 '2014.10.01'과 같거나 큰 이벤트건수와 그 이벤트들을 기준으로 회원별 이메일 발송건수를 비교하는 것이다.,(ㄴ)을 제거하고 (ㄱ)의 EXISTS 연산자를 IN연산자로 변경해도 결과는 동일하다.,이벤트 시작일자가 '2014.10.01'과 같거나 큰 이벤트를 대상으로 이메일이 발송된 기록이 있는 모든 회원을 추출하는 SQL이다.,이벤트 시작일자가 '2014.10.01.'과 같거나 큰 이벤트를 기준으로 단 한차례라도 이메일 발송이 누락된 회원을 추출하는 SQL문장이다. (ㄴ)을 제거하고 (ㄱ)의 EXISTS 연산자를 IN연산자로 변경하게 되면 회원별로 메일을 발송한 건수를 계산할 수 없으므로 원하는 결과를 추출할 수 없다. GROUP BY 및 집계함수를 사용하지 않고 HAVING 절을 사용하였다고 하여 SQL문장이 오류가 발생하 지는 않는다.,2
271,,,"아래와 같은 데이터 모델에서 평가대상상품에 대한 품질평기향목별 최종 평가 결과를 추출하는 SQL 문장으로 옳은 것은? (단, 평가항목에 대한 평가(평가등급)가 기대수준에 미치지 못할 경우 해당 평기항목에 대해서만 재평가를 수행한다)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j120-1.png,,"SELECT B.상품ID. B.상품명, C.평가항목ID, C.평가항목명, A.평가회차, A.평가등급, A.평가일자 FROM (SELECT 상품ID, 평가항목ID ,MAX(평가회차) AS 평가회차 ,MAX(평가등급) AS 평가등급 ,MAX(평가일자) AS 평가일자 FROM 평가결과 GROUP BY 상품ID, 평가항목ID) A, 평가대상상품 B, 품질평가항목 C WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID;","SELECT B.상품ID, B.상품명, C.평가항목ID, C.평가항목명 ,MAX(A.평가회차) AS 평가회차 ,MAX(A.평가등급) AS 평가등급 ,MAX(A.평가일자) AS 평가일자 FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID GROUP BY B.상품ID, B.상품명, C.평가항목ID, C.평가항목명;","SELECT B.상품ID, B.상품명, C.평가항목ID, C.평가항목명, A.평가회차, A.평가등급, A.평가일자 FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID AND A.평가회차 = (SELECT MAX(X.평가회차) FROM 평가결과 X WHERE X.상품ID = B.상품ID AND X.평가항목ID = C.평가항목ID);","SELECT B.상품ID, B.상품명, C.평가항목ID, C.평가항목명, A.평가회차, A.평가등급, A.평가일자 FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C, (SELECT MAX(평가회차) AS 평가회차 FROM 평가결과) D WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID AND A.평가회차 = D.평가회차;","① 특정 평가회차에 대한 결과가 아닌, 상품ID, 평가항목ID별로 개별 MAX값을 구하므로 원하는 결과 가 아니다. ② 특정 평가회차에 대한 결과가 아닌, 평가결과 엔터티의 평가회차, 평가등급, 평가일자 속성에 대해 서 개별 MAX 값을 구하므로 원하는 결과가 아니다. ③ 연관 서브쿼리를 활용하여 특정 상품, 평가항목별로 최종 평가회차와 Join을 수행하여 원하는 결과를 출력한다. ④ Inline View D 에서 평가결과 엔터티의 특정상품 및 평가항목에 대한 최종 평가회차가 아닌 전체 데이터 중 평가회차가 가장 큰 값을 가지고 JOIN을 수행하므로 원하는 결과가 아니다.",3
272,,,다음 주어진 ERD를 수행하였을 때 오류가 날 수 있는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j551-1.png,,"SELECT 회원번호, 종목코드 FROM 일자별주문내역 WHERE 주문일자 ALL (SELECT DISITINCT 주문일자 FROM 계좌마스터);","SELECT 회원번호, 종목코드 FROM 일자별주문내역 WHERE 주문일자 EXISTS (SELECT DISITINCT 주문일자 FROM 계좌마스터);",SELECT * FROM 계좌마스터 WHERE 회원번호 IN (SELECT DISITINCT 회원번호 FROM 고객);,SELECT * FROM 계좌마스터 WHERE 회원번호 = (SELECT DISITINCT 회원번호 FROM 고객);,④번은 '=' 단일행 연산자로 서브쿼리의 결과가 반드시 하나만 리턴 되어야 한다. 만약 여러 개의 행이 리턴 되면 오류가 발생하게 된다.,4
273,,,다음 서브쿼리 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j699-1.png,SELECT SUM(SAL) FROM EMP WHERE HIREDATE > (SELECT HIREDATE FROM TAB1 WHERE NAME = 'JAMES');,6900,5400,4100,3800,"JAMES의 입사일보다 늦게 입사한 직원들의 급여 총 합을 구하는 문제이다. JAMES의 입사일인 1981/10/03 보다 늦게 입사한 직원은 ADAMS, FORD, MILLER 이며 이들의 급여 총합은 5400이다.",2
274,,,다음 SQL의 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j637-1.png,"SELECT ISNULL(COL1, 3) FROM TAB1;",,,,,"ISNULL(대상, 대체값) 함수는 대상이 NULL이면 대체값으로 치환하는 함수로서 COL1이 NULL이면 3으로 대체하라는 쿼리이기 때문에 1,2,3,3이 나오게 된다.",3
275,,,"다음 중 아래의데이터모델과 깉은테이블 및 제익조건을 생성하는 DDL문장으로 올바른 것은? (단, DBMS는 Oracle을 기준으로 한다.)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j42-1.png,,"CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) NOT NULL ,PROD_NM VARCHAR2(100) NOT NULL ,REG_DT DATE NOT NULL ,REGR_NO NUMBER(10) .CONSTRAINT PRODUCT_PK PRIMARY KEY (PROD_ID) );","CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) NOT NULL ,PROD_NM VARCHAR2(100) NOT NULL ,REG_DT DATE NOT NULL ,REGR_NO NUMBER(IO) NULL ,ADD CONSTRAINT PRIMARY KEY (PROD_ID) );","CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) ,PROD_NM VARCHAR2(100) ,REG_DT DATE ,REGR_NO NUMBER(10) ); ALTER TABLE PRODUCT ADD CONSTRAINT PRODUCT_PK PRIMARY KEY (PROD_ID);","CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) NOT NULL ,PROD_NM VARCHAR2(100) NOT NULL ,REG_DT DATE NOT NULL ,REGR_NO NUMBER(10) NULL); ALTER TABLE PRODUCT ADD PRIMARY KEY PRODUCT_PK ON (PROD_ID);",,1
276,,,다음 중 아래 SQL의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j136-1.png,,,,,,,4
277,,,"테이블 A, B, C가 있다. 다음 중 DELETE FROM A 쿼리를 수행한 후에 테이블 C 테이블에 남아 있는 데이터로 가장 올바른 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j347-1.png,"CREATE TABLE A (C INTEGER PRIMARY KEY, D INTEGER); CREATE TABLE B (B INTEGER PRIMARY KEY, C INTEGER REFERENCES A(C) ON DELETE CASCADE); CREATE TABLE C (A INTEGER PRIMARY KEY, B INTEGER REFERENCES B(B) ON DELETE SET NULL);","(1,1)","(2,2)","(1,NULL)과(2,NULL)","(1,NULL)과(2,2)",DELETE FROM A 이후 A 테이블은 모두 삭제된다. C 테이블은 Cascade 옵션에 의해서 A의 첫번째 행을 참조하는 두 건 모두 삭제된다. 그리고 B 테이블이 삭제됨에 따라 B 테이블의 B칼럼을 참조하는 C 테이블의 B 칼럼값은 SET NULL 옵션에 의해서 NULL 값으로 변경된다.,3
278,,,아래의 데이터 모델에서 SQL을 이용하여 표(지역별 월별 이용량)와 같은 형식의 데이터를 추출하려고 할 때 올바른 SQL 문장은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j125-1.png,,"SELECT (CASE GROUPING(B.지역ID) WHEN 1 THEN '지역전체' ELSE MIN(B.지역명) END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, 'YYYY.MM')) WHEN 1 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY GROUPING SETS(B.지역ID, TO_CHAR(A.이용일시, 'YYYY.MM'))","SELECT (CASE GROUPINGS(B.지역명) WHEN 1 THEN '지역전체' ELSE B.지역명 END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, 'YYYY.MM')) WHEN 1 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY CUBE(B.지역명, TO_CHAR(A.이용일시, 'YYYY.MM'))","SELECT (CASE GROUPINGS(B.지역ID) WHEN 1 THEN '지역전체' ELSE MIN(B.지역명) END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, 'YYYY.MM')) WHEN 1 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY ROLLUP(B.지역ID, TO_CHAR(A.이용일시, 'YYYY.MM'))","SELECT (CASE GROUPING(B.지역명) WHEN 0 THEN '지역전체' ELSE B.지역명 END) AS 지역명 ,(CASE GROUPING(TO_CHAR(A.이용일시, 'YYYY.MM')) WHEN 0 THEN '월별합계' ELSE TO_CHAR(A.이용일시, 'YYYY.MM') END) AS 이용월 ,SUM(A.이용량) AS 이용량 FROM 이용내역 A INNER JOIN 지역 B ON (A.지역ID = B.지역ID) GROUP BY ROLLUP(B.지역명, TO_CHAR(A.이용일시, 'YYYY.MM'))","위의 결과 데이터는 지역에 대해서 월별 이용량 및 소계와 전체 이용량을 출력하였으므로, ROLLUP 함수를 활용할 수 있다. ROLLUP 집계 그룹 함수는 나열된 컬럼에 대해 계층 구조로 집계를 출력하는 함수로서 ROLLUP(A, B)를 수행하면 (A, B)별 집계, A별 집계와 전체 집계를 출력할 수 있다. ④번 보기의 경우 CASE 절의 GROUPING 함수의 사용이 잘못 (0이 아닌 1이 되어야 함) 되었으며, ②번 보기처럼 CUBE를 사용하게 되면, 결합 가능한 모든 값에 대하여 다차원 집계를 생성하게 된다. ①번 보기처럼 GROUPING SETS를 사용하게 되면 계층구조 없이 지역에 대한 합계와 월별 합계를 각각 생성하게 된다.",3
279,,,"아래와 같은 데이터 모델에 대한 설명으로 가장 적절한 것은? (단, 시스템적으로 회원기본정보와 회원상세정보는 1:1, 양쪽 필수 관계임을 보장한다.)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j107-1.png,,회원ID 컬럼을 대상으로 (회원기본정보 INTERSECT 회원상세정보) 연산을 수행한 결과와 (회원기본정보 UNION 회원상세정보) 연산을 수행한 결과는 다르다.,회원ID 컬럼을 대상으로 (회원기본정보 INTERSECT 회원상세정보) 연산을 수행한 결과의 건수와 두 테이블을 회원ID로 JOIN 연산을 수행한 결과의 건수는 동일하다.,회원ID 컬럼을 대상으로 (회원기본정보 UNION ALL 회원상세정보) 연산을 수행한 결과의 건수는 회원기본정보의 전체건수와 동일하다.,회원ID 컬럼을 대상으로 (회원기본정보 EXCEPT 회원상세정보) 연산을 수행하면 회원상세정보가 등록되지 않은 회원ID가 추출된다.,"① 1:1, 양쪽 필수 관계를 시스템적으로 보장하므로 연산 수행결과는 같다. ③ 1:1, 양쪽 필수 관계를 시스템적으로 보장하므로 UNION을 수행한 결과는 회원기본정보의 전체건수와 동일하지만, UNION ALL을 수행하였으므로 결과건수는 회원기본정보의 전체건수에 2배가 된다. ④ 1:1, 양쪽 필수 관계를 시스템적으로 보장하므로 두 엔터티간의 EXCEPT 결과는 항상 공집합이다.",2
280,,,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j740-1.png,SELECT COUNT(COL1) FROM TAB1 WHERE NOT EXISTS(SELECT 'X' FROM TAB2 WHERE TAB1.COL2 = TAB2.COL2);,4,3,2,1,"NOT EXISTS는 서브쿼리 조건이 거짓인 경우 메인쿼리의 결과가 출력된다. 따라서 TAB2의 COL2와 일치하지 않는 값은 1이며, NULL은 TAB1과 TAB2가 모두 존재하지만 EQUAL(=) 연산 결과가 항상 거짓이므로, NOT EXISTS에 의 해 출력된다. 따라서 COUNT 결과는 2이다.",3
281,,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j696-1.png,SELECT COUNT(TAB1.COL1) AS CNT FROM TAB1 LEFT OUTER JOIN TAB2 ON TAB1.COL2 = TAB2.COL2 AND TAB1.COL1 = TAB2.COL1;,6,5,4,3,,2
282,,,다음 중 SQL의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j63-1.png,,3,2,1,0,,3
283,,,다음 2개의 SQL문이 같은 결과를 조회할 수 있도록 빈칸을 작성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j438-1.png,"SELECT ProductName, SUM(Price) FROM Mytest WHERE ProductName = '비디오' GROUP BY ROLLUP(ProductName); SELECT ProductName, SUM(Price) FROM Mytest WHERE ProductName = '비디오' GROUP BY GROUPING SETS( );","ProductName, ()","ProductName, Price",(),ProductName,두 SQL문은 모두 ProductName '비디오'에 대한 집계이다. ProductName '비디오' 에 대한 전체 합계가 조회되어야 한다.,1
284,,,다음 SQL문의 실행 결과는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j520-1.png,"SELECT AVG(NVL(COL2,0)) FROM test48;",25,24,23,22,NVL 함수로 NULL은 0으로 대체되고 평균이 계산된다.,2
285,,,아래와 같은 테이블에 SQL구문이 실행되었을 경우 최종 출력 값을 작성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j62-1.png,,4,3,2,0,,2
286,,,주어진 데이터에서 아래의 SQL문을 수행된 결과로 옳은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j451-1.png,"SELECT COALESCE(COL1, COL2 * 50,50) FROM sqld_12;",,,,,COALESCE 함수는 함수 내 비교식에서 NULL 값이 아닌 값으로 연산을 수행한다.,4
287,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j694-1.png,"SELECT EMPNO FROM EMP ORDER BY TO_CHAR(TO_NUMBER(SUBSTR(JUMIN, 3, 2)));",,,,,"SUBSTR(JUMIN, 3, 2)은 태어난 월을 추출하기 때문에, 순서대로 12, 11, 06, 01, 08의 문자 유형으로 출력된다. 이를 TO_NUMBER를 사용하여 숫자 형태로 변환하면 12, 11, 6, 1, 8이 되는데, 이를 다시 TO_CHAR로 변환하게 되면 문자값의 비교 규칙에 따라 1 < 11 < 12 < 6 < 8 순서대로 출력된다. (문자는 가장 왼쪽부터 비교하여 값이 작을수록 작은값이 된다)",3
288,,,"날짜값을 2020, 02와 같이 조회되도록 SQL문을 완성하시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j356-1.png,"SELECT EXTRACT (YEAR FROM SYSDATE), LPAD(EXTRACT(month from sysdate), (ㄱ), (ㄴ)) FROM Mytest;","ㄱ : 2, ㄴ : '0'","ㄱ : 2, ㄴ : '2'","ㄱ : 1, ㄴ : '2'","ㄱ : 1, ㄴ : '0'",COL1 값에서 Month값이 1이 두 자릿수 01로 출력되어야 하므로 LPAD 함수의 두 번째 인자 값에는 숫자 2이다. 세 번째 인자 값에는 문자 '0'이 와야 한다.,1
289,,,"다음 엔터티는 어떤 정규화를 위배한 것인가? (단, 고객번호가 PK임)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j726-1.png,,제 4정규화,제 3정규화,제 2정규화,제 1정규화,기본키(고객번호+상품명) 중 상품명에 의해 가격이 결정되므로 완전 함수 종속성을 위배하였다. 따라서 제 2 정규화 규칙을 위반하였다.,3
290,,,아래 각각 3개의 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j393-1.png,SELECT AVG(COL3) FROM SQLD01; SELECT AVG(COL3) FROM SQLD01 WHERE COL1 > 0; SELECT AVG(COL3) FROM SQLD01 WHERE COL1 IS NOT NULL;,"10, 10, 10","10, 20, 20","20, 10, 10","20, 20, 20","이 문제의 핵심은 그룹 함수(SUM, AVG, MAX, MIN)는 실행 시에 NULL이 제외된다는 것이다.",2
291,,,아래와 같은 보관금원장 엔터티에서 관서에 대한 정보가 반정규화 되어 있기 때문에 관서정보를 조화할 때 성능저하가 발생하고 있다. 이 엔터티에 대해 몇 차 정규화가 필요한 지와 분리된 스키마 구조를 가장 바르게 짝지은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j33-1.png,,"3차 정규화 - 정규화테이블{관서번호, 관리점번호, 관서명, 상태, 관서등록일자}","2차 정규화 - 정규화테이블{관서번호, 관리점번호, 관서명, 상태, 관서등록일자}","3차 정규화 - 정규화테이블{관서번호, 납부자번호, 관리점번호, 관서명, 상태, 관서등록일자}","2차 정규화 - 정규화테이블{관서번호, 납부자번호, 관리점번호, 관서명, 상태, 관서등록일자}",,2
292,,,다음 중 아래와 같은 데이터 상황에서 SQL의 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j75-1.png,,14,6,1,0,,2
293,,,다음 결과를 얻기 위한 SQL 문장으로 적절하지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j759-1.png,,"SELECT 이름, 성적 FROM (SELECT 성적, DENSE_RANK() OVER(ORDER BY 성적 DESC) AS RN FROM EXAM) WHERE RN BETWEEN 2 AND 3;","SELECT 이름, 성적 FROM (SELECT 성적, ROW_NUMBER() OVER(ORDER BY 성적 DESC) AS RN FROM EXAM) WHERE RN BETWEEN 2 AND 4;","SELECT TOP(3) WITH TIES 이름, 성적 FROM EXAM ORDER BY 성적 DESC;","SELECT 이름, 성적 FROM EXAM ORDER BY 성적 DESC OFFSET 1 ROW FETCH FIRST 3 ROWS ONLY;","TOP 쿼리는 성적이 높은 순서대로 동순위 포함하여 3명을 출력하므로 홍길동, 박길동, 최길동이 출력된다.",3
294,,,다음의 ERD에서 식별자 분류로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j448-1.png,고객마스터 테이블의 고객번호는 대표성에 따른 식별자 분류로는 (ㄱ)이고 스스로 생성했는지 여부에 따라서는 (ㄴ)이다. 또한 계좌마스터의 고객번호는 스스로 생성 여부에 따라서 (ㄷ)이다.,"ㄱ-내부식별자, ㄴ-단일식별자, ㄷ-보조식별자","ㄱ-보조식별자, ㄴ-내부식별자, ㄷ-외부식별자","ㄱ-주식별자, ㄴ-내부식별자, ㄷ-외부식별자","ㄱ-보조식별자, ㄴ-외부식별자, ㄷ-단일식별자",식별자는 대표성에 따라서 주식별자와 보조식별자로 분류되고 생성 여부에 따라서는 내부 식별자와 외부 식별자로 분류된다. 또한 속성의 수에 따라서 단일 식별자와 복합 식별자로 분류된다.,3
295,,,아래와 같은 데이터 모델에 대해 SQL을 수행 하였다. 다음 중 수행된 SQL과 동일한 결과를 도출하는 SQL은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j101-1.png,,"SELECT A.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A WHERE 서비스ID IN (SELECT 서비스ID FROM 서비스이용 MINUS SELECT 서비스ID FROM 서비스);","SELECT B.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A LEFT OUTER JOIN 서비스이용 B ON (A.서비스ID = B.서비스ID) WHERE B.서비스ID IS NULL GROUP BY B.서비스ID, A.서비스명, A.서비스URL;","SELECT X.서비스ID, X.서비스명, X.서비스URL FROM 서비스 X WHERE NOT EXISTS (SELECT 1 FROM (SELECT 서비스ID FROM 서비스 MINUS SELECT 서비스ID FROM 서비스이용) Y WHERE X.서비스ID = Y.서비스ID);","SELECT B.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A, 서비스이용 B WHERE A.서비스ID = B.서비스ID;","수행한 SQL은 이용된 적이 있었던 서비스를 추출하는 SQL이다. ① 서비스와 서비스이용 테이블의 순서를 변경하고 IN 절을 NOT IN으로 변경하면 동일한 결과를 출력할 수 있다. ② 서비스를 기준으로 OUTER JOIN을 수행하였으므로, 이용된 적이 없었던 서비스만 출력된다. B.서비스ID IS NOT NULL로 변경해야 동일한 결과가 출력된다. ③ 전체 서비스에서 이용된 적이 있었던 서비스를 MINUS하였으므로 이용된 적이 없었던 서비스가 서브쿼리에서 추출된다. 그러므로 NOT EXISTS 구문을 적용하면 이용된 적이 있었던 서비스가 출력된다. ④ 이용된 적이 있었던 서비스를 추출하는 것은 동일하나 서비스와 서비스이용은 1:n 관계이므로 서비스 이용건수 만큼 추출되므로 전체 결과가 다르다. GROUP BY를 수행하면 동일한 결과를 출력할 수 있다.",3
296,,,"아래 테이블에 대한 [뷰 생성 스크립트]를 실행한 후, 조회 SQL의 실행결과로 맞는 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j123-1.png,,400,300,200,0,조회 SQL 실행시 V_TBL은 뷰 스크립트로 치환되어 수행된다. 뷰 생성 스크립트에서 부여된 조건과 조회 SQL에서 부여된 조건 모두를 만족해야 한다.,3
297,,,"아래 부서 테이블의 담당자 변경을 위해 부서임시 테이블에 입력된 데이터를 활용하여 주기적으로 부서 테이블을 아래 결과와 같이 반영하기 위한 SQL으로 가장 적절한 것은?(단, 부서임시 테이블에서 변경일자를 가준으로 가장 최근에 변경된 데이터를 가준으로 부서 테이블에 반영되어야 한다)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j121-1.png,,UPDATE 부서 A SET 담당자 = (SELECT B.담당자 FROM 부서임시 B WHERE B.부서코드 = A.부서코드 AND B.변경일자 = '2015.01.25.') ;,UPDATE 부서 A SET 담당자 = (SELECT B.담당자 FROM 부서임시 B WHERE B.부서코드 = A.부서코드 AND B.변경 일자 = (SELECT MAX(C.변경일자) FROM 부서임시 C WHERE C. 부서코드 = B. 부서코드)) WHERE 부서코드 IN (SELECT 부서코드 FROM 부서임시);,"UPDATE 부서 A SET 담당자 = (SELECT C.부서코드 FROM (SELECT 부서코드, MAX(변경일자) AS 변경일자 FROM 부서임시 GROUP BY 부서코드) B, 부서임시 C WHERE B. 부서코드 = C. 부서코드 AND B. 변경일자 = C.변경일자 AND A. 부서코드 = C. 부서코드) WHERE EXISTS (SELECT 1 FROM 부서 X WHERE A.부서코드 = X.부서코드);","UPDATE 부서 A SET 담당자 = (SELECT C.부서코드 FROM (SELECT 부서코드, MAX(변경일자) AS 변경일자 FROM 부서임시 GROUP BY 부서코드) B, 부서임시 C WHERE B.부서코드 = C.부서코드 AND B.변경일자 = C.변경일자 AND A.부서코드 = C.부서코드)","① ④과 같은 사유로 부서코드 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다. 또한 변경일자를 하드 코딩하는 것은 답이 될 수 없다. ③ WHERE 절 조건이 부서임시가 아닌 부서 테이블이므로 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다. ④ 연관 서브쿼리를 활용한 UPDATE 에서 WHERE절은 UPDATE 대상이 되는 데이터의 범위를 결정하 게 되는데, WHERE 절이 누락되어 부서의 모든 데이터가 UPDATE 대상이 되므로 부서코드 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다.",2
298,,,다음 중 ERD에 대한 설명으로 가장 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j406-1.png,,고객은 개인고객이면서 동시에 기업고객이 되는 포괄적 관계이다.,고객 구분은 개인고객과 기업고객을 구분하는 차별자이다.,"고객, 개인고객, 기업고객 3개 엔터티를 3개의 테이블로 생성하여 사용하면 다수의 조인이 발생하여 조회속도가 떨어진다.","고객, 개인고객, 기업고객 간의 관계는 Super Type과 Sub Type 관계이다.",Super Type과 Sub Type은 베타적 관계와 포괄적 관계가 있는데 본 예제의 관계는 베타적 관계 모델링이다. 베타적 관계는 한순간에 하나만 될 수 있기 때문에 한순간에 개인고객이 되거나 아니면 기업고객이 된다.,1
299,,,"다음 모델의 배송 엔터티에서 고객의 정보를 찾을 때, 성능 향상과 SQL 문장을 단순화하는 가장 적절한 반정규화 방법은 무엇인가? (단, 주문목록 엔터티에서는 고객의 주식별자를 상속받기를 원하지 않음, 배송 엔터티에서는 고객 엔터티의 모든 속성을 참조하기를 원함)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j161-1.png,,고객의 모든 정보를 모두 배송 엔터티의 속성으로 반정규화,배송 엔터티와 주문목록 엔터티 관계를 식별자 관계로 수정,배송과 고객의 엔터티를 통합하는 반정규화,고객과 배송 엔터티의 관계를 추가(1:M관계)하는 관계 반정규화,고객 엔터티의 모든 속성을 참조하기를 원할 때 가장 효율성이 좋은 반정규화 기법은 관계를 중복하는 방법이며 이를 적용하면 두 테이블의 조인 경로를 단축하게 되고 SQL 문장을 단순하게 구성할 수 있다.,4
300,,,다음의 테이블을 보고 실행한 SQL문 중에서 그 결과가 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j541-1.png,,,,,,①번의 실행 결과는 NULL 이다. DECODE는 2개의 속성을 비교하는 것으로 위의 예에서는 '06'과 0을 비교하므로 NULL이 된다.,1
301,,,아래의 데이터 모델처럼 동일한 유형의 속성이 칼럼단위로 반복돠는 경우가 실제 프로젝트를 하면서 많이 발생 될 수 있다. 다음 중 아래와 같이 전제조건이 있을 때 테아블에서 나타날 수 있는 현상으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j35-1.png,,"유형기능분류코드 각각에 대하여 개별로 Index를 모두 생성할 경우 입력, 수정, 삭제 때 성능이 저하되므로 제1차 정규화를 수행한 후 인덱스를 적용하는 것이 좋다.",유형기능분류코드가 일반속성 안에서 반복적으로 속성이 구분되어 있기 때문에 이전종속을 수행해야 하는 제 2정규형이라 할 수 있다.,유형기능분류코드에 대해 Where절에 조건으로 들어오는 값이 있으므로 PK와 이에 대한 Index만 있으면 SQL문장은 빠르게 수행될 수 있다고 할 수 있다.,조회 조건이 유형기능분류코드에 따라 반복되는 그룹이 칼럼단위로 되어 있으므로 제 1정규형이라고 할 수 있다.,,1
302,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j758-1.png,"SELECT SUM(SAL) FROM (SELECT ENAME, DEPTNO, SAL, NTILE(2) OVER(PARTITION BY DEPTNO ORDER BY SAL) AS GN FROM EMP) WHERE (DEPTNO = 10 AND GN = 1) OR (DEPTNO = 20 AND GN = 2);",10275,9750,8625,7300,"그룹으로 나눌 때 명학히 나눠지지 않으면 앞 그룹의 크기를 더 크게 나누므로 10번 부서의 1번 그룹원은 MILLER, CLARK이며, 20번 부서의 2번 그룹원은 SCOTT과 FORD 이므로 1300 + 2450 + 3000 + 3000 = 9750 이 된다.",2
303,,,아래 ERD에 대한 설명으로 가장 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j484-1.png,,여러 사원이 동일한 콘도를 이용할 수 있다.,사원은 동일 일자에 여러 콘도를 이용할 수 있다.,회사 콘도는 누구도 이용하지 않을 수 있다.,사원은 동일한 콘도를 예약해서 반복적으로 방문할 수 있다.,이용내역' 엔터티에서 이용일자 + 사원번호가 기본키이므로 일자가 같은 날에 여러 콘도를 이용할 수 없다.,2
304,,,다음 중 아래 TAB1 을보고 각 SQL 실행결과를 가장 올바르게 설명한 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j73-1.png,,"SELECT COUNT(COL2) FROM TABI WHERE COL1 IN ('b','c'); -> 실행 결과는 1 이다.",SELECT COUNT(COL1) FROM TABI WHERE COL2 = NULL; -> 실행 결과는 1 이다.,"SELECT ISNULL(COL2,'X') FROM TABI WHERE COL1 = 'a' ; -> 실행 결과로 'X'를 반환한다.",SELECT COL2 FROM TABI WHERE COL1 = 'b' ; -> 실행 결과가 없다.(공집합),,3
305,,,다음 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j739-1.png,"SELECT SUM(NULLIF(COL1,100) + COL2) FROM TAB1;",600,500,400,300,"NULLIF(COL1, 100)은 COL1 값이 100이면 NULL을 리턴하고, 같지 않으면 COL1값을 리턴한다. 따라서 COL1값은 순서대로 NULL, NULL, 200이 리턴되므로 COL2와의 합은 순서대로 NULL, NULL, 300이 되어 총 300이 출력된다.",4
306,1과목,기타,,https://cbt.youngjin.com/upload/sqld/133.png,,SELECT NULL*2 FROM SQLD_13;,SELECT NULL*3 FROM SQLD_13;,SELECT NULL * NULL FROM SQLD_13;,SELECT count(고객) FROM SQLD_13 WHERE 거래내역 IS NULL;,,정답 : 다른 것은 모두 NULL을 반환하는데거래내역이 NULL인 고객의 수를 구해서 2를 반환한다.
307,1과목,정규화,,https://cbt.youngjin.com/upload/sqld/19.png,,2차정규형 - 3차정규화 대상,1차정규형 - 2차정규화 대상,3차정규형 - 보이스-코드 정규화 대상,보이스-코드 정규화 - 4차정규화 대상,,정답 : 결정자 중 일부 속성에만 함수 종속성을 가지고 있는 ‘Partial Dependency Attribute’를 갖는 것은 2차정규형을 위반한 사례에 해당한다. 즉 1차정규형이면서 2차정규화의 대상이 된다.
308,1과목,기타,,https://cbt.youngjin.com/upload/sqld/72.png,," max(COL2), min(COL2), sum(COL1)"," max(COL1), min(COL2), sum(COL2)"," max(COL1), min(COL2), sum(COL1)"," min(COL1), max(COL2), max(COL1)",,"정답 : A 속성은 COL1의 최댓값, B 속성은 COL2의 최솟값, C 속성은 COL1 속성의 합이다."
309,1과목,데이터 무결성,,https://cbt.youngjin.com/upload/sqld/132.png,," 부서 테이블에서 (2, '영업부') 튜플을 삭제한다면 참조 무결성 제약조건을 위배한다."," 사원 테이블에 (13, '강감찬', 'A1') 튜플을 삽입한다면 도메인 무결성 제약조건을 위배한다."," 사원 테이블에 (14, '김유신', 0) 튜플을 삽입한다면 참조 무결성 제약조건을 위배한다."," 부서 테이블에 (1, '연구부') 튜플을 삽입한다면 참조 무결성 제약조건을 위배한다.",,"정답 : 부서 테이블은 마스터 테이블이므로 사원 테이블에 없는 부서번호 등을 자유롭게 입력할 수 있다. 따라서 부서 테이블에 (1, ‘연구부’)을 입력하는 것은 참조 무결성 위배가 아니다."
310,2과목,DML,,https://cbt.youngjin.com/upload/sqld/146.png,, 1000, 1100, 1200, 1300,,"정답 : TX2의 update 문은 베타적 Lock 때문에 대기했다가 TX1 트랜잭션이 commit 한 후에 처리를 계속한다. TX1에 의해 1,100으로 바뀐 값을 읽어 200을 더하므로 최종 결과는 1,300이 된다."
311,2과목,조인,,https://cbt.youngjin.com/upload/sqld/77.png,," 2, 4, 3, 5, 12"," 2, 4, 5, 3, 12"," 2, 3, 4, 5, 12"," 2, 4, 3, 7, 12",,"정답 : TAB1 테이블에는 행이 4개, TAB2 테이블에는 행이 3개가 있다. KEY 칼럼을 사용해서 INNER JOIN을 하면 같은 것만 찾는다. 따라서 TAB1와 TAB2 테이블의 KEY 칼럼에서 ‘B’와 ‘C’가 같기 때문에 2개의 행이 출력된다."
312,1과목,서브쿼리,,https://cbt.youngjin.com/upload/sqld/74.png,," 10, 20"," 10, 20, 30"," 10, 20, 30 ,40"," 10, 20, 30, 40, 50",,정답 : ALL 연산자는 서브쿼리(Subquery) 값 모두가 조건에 만족하면 True를 반환한다.
313,1과목,조인,,https://cbt.youngjin.com/upload/sqld/78.png,, 10건, 14건, 18건, 20건,,정답 : DEPTNO로 조인을 하고 DNAME과 JOB으로 CUBE를 실행했다. CUBE는 전체합계와 각 칼럼별로 부분합계를 출력한다.
314,2과목,조인,,https://cbt.youngjin.com/upload/sqld/118.png,, Natural Join, Right Outer Join, Left Outer Join, Full Outer Join,,정답 : 위의 결과를 보면 EMPNO와 DEPTNO 각각에 서로 없는 것이 있다. 그래서 FULL OUTER JOIN이 된다.
315,2과목,기타,,https://cbt.youngjin.com/upload/sqld/130.png,, LEAD, LAG, NTILE, LAST_VALUE,,정답 : LAG() 윈도우 함수는 이전 행의 몇 번째 행 값을 가지고 올 수 있다.
316,1과목,기타,,https://cbt.youngjin.com/upload/sqld/22.png,, 전체가 하나의 테이블인 부동산관계자로 통합하는 All in One 타입," 슈퍼타입(부동산관계자)과 서브타입(부동산전세자, 부동산소유자)을 슈퍼+서브타입인 부동산전세자, 부동산소유자 2개 테이블로 만든 타입"," 부동산관계자의 일부 속성은 부동산전세자에게, 일부 속성은 부동산소유자에게 할당하여 배치하는 수평 분할 타입"," 슈퍼타입(부동산관계자)과 서브타입(부동산전세자, 부동산소유자)을 모두 1:1관계로 해체하여 개별로 테이블을 만드는 타입",,"정답 : 논리적인 데이터 모델에서 이용이 되는 슈퍼/서브 타입의 데이터 모델을 성능을 고려한 물리적인 데이터 모델에서 변환하는 방법은 세 가지(1:1타입, 슈퍼+서브타입, All in One 타입)가 있다."
317,1과목,기타,,https://cbt.youngjin.com/upload/sqld/131.png,, “21 NOT IN (SELECT 과일코드 FROM과일)”은 참이다., “19 < ANY (SELECT 과일코드 FROM 과일)”은 거짓이다., “15 < ALL (SELECT 과일코드 FROM 과일)”은 참이다., “19=ALL(SELECT 과일코드 FROM 과일)” 거짓이다.,,정답 : ALL은 전부 일치하는 것만 출력하는 것으로 AND라고 생각하면 되고 ANY는 OR로 생각하면 된다.
318,2과목,집합 연산자,,https://cbt.youngjin.com/upload/sqld/63.png,, 1, 2, 3, 4,,"정답 : 주어진 SQL문에서 앞에 UNION 연산을 수행하면 1, 2, 3, 4, 5가 반환되고 이어서 minus를 수행하면 1, 3, 4, 5가 반환된다."
319,2과목,윈도우 함수,,https://cbt.youngjin.com/upload/sqld/68.png,, RANK(), NTILE(), ROW_NUMBER(), DENSE_RANK(),,정답 : 결괏값에서 중복된 등수 2등 다음에 바로 다음 등수인 3이 왔으므로 빈칸에는 DENSE_RANK가 와야 한다.
320,2과목,조인,,https://cbt.youngjin.com/upload/sqld/110.png,," 차수＝5, 카디널리티＝3"," 차수＝5, 카디널리티＝2"," 차수＝8, 카디널리티＝9"," 차수＝8, 카디널리티＝3",,"정답 : 차수(Degree)와 카디널리티(Cardinality)를 구하는 문제로 차수는 결과 릴레이션의 칼럼 수이다. 그래서 Student와 dept 테이블을 조인하여 모든 컬럼을 출력하기 때문에 (SELECT *) 각각 Student 테이블에서 5개 , dept 테이블에서 3개 , 총 8개의 컬럼(=차수)을 가지게 된다. 카디널리티는 선택된 행들의 개수이다. Where문을 보면 결과 릴레이션에서 Student 릴레이션의 dept값이 100보다 큰 것만 조회한다. 위 조건에 부합하는 결과 행수는 9건이므로 카디널리티는 9가 된다. (Student와 Dept를 카티션곱 조인하면 15개의 행이 나오고, 이중 where 조건에 부합하는 대상은 9건이다)"
321,1과목,기타,,https://cbt.youngjin.com/upload/sqld/148.png,, 고객_IDX 인덱스 칼럼 순서를 조정한다., 주문_IDX 인덱스 칼럼 순서를 조정한다., 고객_IDX 인덱스에 칼럼을 추가한다., 주문_IDX 인덱스에 칼럼을 추가한다.,,정답 : • 고객_IDX 인덱스를 읽고 나서 고객 테이블을 액세스하는 횟수는 많으나 대부분 필터링되고 있다.• 고객에 대한 조건절로 사용된 고객등급이나 연령 칼럼이 인덱스에 포함돼 있지 않아 생기는 현상이므로 고객_IDX에 칼럼을 추가해 주어야 한다.
322,1과목,기타,,https://cbt.youngjin.com/upload/sqld/64.png,," (ㄱ) 남성의류, (ㄴ) 남성의류 = 여성의류;"," (ㄱ) 여성의류, (ㄴ) 여성의류 = 남성의류;"," (ㄱ) 여성의류 IS NULL, (ㄴ) 남성의류 = 여성의류;"," (ㄱ) 남성의류 IS NULL, (ㄴ) 여성의류 = 남성의류;",,"정답 : 결괏값에서 남성의류 속성값이 NULL부터 시작하므로 ㄱ. 보기에는 남성의류 IS NULL이 와야 한다. 남성의류를 상위계층, 여성의류를 하위계층으로 하며 각 남성의류별 여성의류값이 계층적으로 조회되므로 ㄴ. 보기에는 여성의류 = 남성의류가 와야 한다."
323,2과목,기타,,https://cbt.youngjin.com/upload/sqld/73.png,," ROLLUP(DEPTNO, JOB)"," GROUPING SETS(DEPTNO, JOB)"," DEPTNO, JOB"," CUBE(DEPTNO, JOB)",,"정답 : 주어진 결괏값을 보면1. DEPTNO별 합계, 2. DEPTNO, JOB별 합계, 3. 전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다."
324,2과목,조인,,https://cbt.youngjin.com/upload/sqld/127.png,, 4, 5, 9, 20,,"정답 : SQL문에서 COUNT() 함수는 행 수를 확인하는 집계 함수이다. 그런데 R 테이블과 S 테이블에 조인 조건이 없어서 카텐시안 곱이 발생한다. 즉, R 테이블의 행 수가 4개이고 S 테이블의 행 수가 5개이므로 4*5=20이 조회된다."
325,2과목,그룹 함수,,https://cbt.youngjin.com/upload/sqld/20230828_084538.png,, 0, 1, 2, 3,,"정답 : SELECT문을 보면 department로 GROUP BY한다. 그리면 총 3개의 그룹이 만들어진다. computer, physics, math이다. 3개의 그룹 중에서 개수가 2개 초과인 것을 조회하기 위해서 “HAVING count(*) > 2”문을 사용했다. 따라서 2개 초과인 것은 math이고 math는 총 3개가 있으므로 3이 된다."
326,1과목,기타,,https://cbt.youngjin.com/upload/sqld/91.png,," {(100, 영업, Lee, 90), (200, 개발, Kim, 95), (300, 서비스, Hong, 65)}"," {(100, 영업, Lee, 90), (200, 개발, Kim, 95)}"," {(100, 영업, Lee, 90)}"," {(100, 영업, Hong, 80), (100, 영업, Lee, 90), (200, 개발, Kim, 90), (200, 개발, Kim, 95), (600, null, Hong, 65)}",,정답 :
327,1과목,ER 모델링,,https://cbt.youngjin.com/upload/sqld/25.png,,계정은 다수의 계정 그룹을 가질 수 있다.,계정 그룹은 다수의 사용자를 가질 수 없다.,계정 그룹은 사용자를 반드시 가져야 한다.,계정은 반드시 계정 그룹을 가져야 한다.,,정답 : • ERD 관계에서 계정 그룹은 다수의 계정을 포함할 수도 있고 안 할 수도 있다(Optional).• 계정은 반드시 단 하나의 계정 그룹에 소속되어야 한다(Mandatory).
328,1과목,기타,,https://cbt.youngjin.com/upload/sqld/79.png,, where 주문번호 between 1 and 10, where 주문자명 like '%홍길동%', where 주문일자 >= '20181201', where 주문일자 = '20181201',,정답 :
329,2과목,ER 모델링,다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?,,"한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.",주소,이름,환자,나이,"엔터티는 집합의 특성을 가지고 있어야 한다. 본 시나리오에는 환자가 엔터티이고 환자이름,주소,전화번호,나이 등은 속성에 해당된다.",3
330,2과목,집합 연산자,다음 중 SQL문을 가장 잘 설명하고 있는 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j345-1.png,"SELECT A.* FROM MytestA A, MytestB B WHERE A.MANAGER_ID = B.EMPLOYEE_ID AND B.SALARY >= ANY A.SALARY;",어떤 상사보다도 연봉이 낮은 부하 직원,어떤 상사보다도 연봉이 높은 부하 직원,어떤 부하 직원보다도 연봉이 낮은 상사,어떤 부하 직원보다도 연봉이 높은 상사,"A테이블의 매니저 아이디가 B테이블의 직원 아이디이므로 A가 부하직원, B가 상사라고 볼 수 있다. 그러므로 상단의 SQL문은 어떤 부하직원보다도 연봉이 높은 상사의 데이터를 조회하는 SQL문이라 할 수 있다.",4
331,2과목,그룹 함수,다음 주어진 SQL문의 빈칸에 그룹 함수를 쓰시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j359-1.png,"SELECT COL1, COL2, SUM(COL3) FROM Mytest GROUP BY ( );","GROUPING SETS(COL1,(COL2,COL1))","GROUPING SETS(COL1,(COL2,COL3))","GROUPING SETS(COL1,(COL2,COL3))","GROUPING SETS(COL1,(COL1,COL2))",,4
332,2과목,트랜잭션 관리,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j617-1.png,"INSERT INTO TAB1 VALUES(5, 'E', 3); COMMIT; UPDATE TAB1 SET COL2 = 3 WHERE NO = 2; SAVEPOINT SAVE1; INSERT INTO TAB1 VALUES(6, 'F', 5); DELETE TAB1 WHERE NO = 4; ROLLBACK TO SAVE1; UPDATE TAB1 SET COL2 = 2 WHERE NO = 1; ROLLBACK; COMMIT; SELECT SUM(COL2) FROM TAB1;",13,12,11,8,"첫 INSERT문장은 COMMIT했기 때문에 영구 저장된다. 그 이후 UPDATE, INSERT, DELETE를 차례대로 하지만 SAVE1 지점으로 롤백하므로 INSERT와 DELETE는 실행 취소된다. 첫 UPDATE문장과 마지막 UPDATE문장은 모두 롤백되어 결과적으로는 첫 INSERT문장만 실행된다. 따라서 남은 행의 SUM(COL2) 결과는 11이다.",3
333,2과목,윈도우 함수,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,,"SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA FROM EMP;",SAL의 마지막 행은 급여가 가장 작은 사람이다.,SAL의 값에 따라서 데이터를 4등분으로 분류해서 DATA 필드로 조회된다.,SAL이 큰 순으로 조회된다.,DATA 필드가 가질 수 있는 값의 범위는 0~3까지이다.,NTILE 윈도우 함수는 데이터를 ARGUMENT 값으로 N등분하는 함수이다. 위의 예처럼 NTILE(4)는 1부터 4까지 4등분한다.,4
334,2과목,집합 연산자,"릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)",,"Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno) Dept(deptno, dname, loc)",SELECT deptno FROM Dept WHERE deptno <> ANY (SELECT deptno FROM Emp);,SELECT b.deptno FROM Emp a RIGHT OUTER JOIN Dept b ON a.deptno = b.deptno WHERE empno IS NULL;,SELECT deptno FROM Dept a WHERE NOT EXISTS (SELECT * FROM Emp b WHERE a.deptno = b.deptno);,SELECT deptno FROM Dept WHERE Deptno NOT IN (SELECT deptno FROM Emp);,①의 결과는 모든 DEPTNO가 조회된다.,1
335,2과목,JOIN,아래와 같은 두개의 테이블이 있을 때 아래의 SQL 결과 건수를 알맞게 나열한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j301-1.png,SELECT * FROM MytestA A INNER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A LEFT OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A RIGHT OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A FULL OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2); SELECT * FROM MytestA A CROSS JOIN MytestB B;,"2, 4, 3, 7, 12","2, 3, 4, 5, 12","2, 4, 5, 8, 12","2, 4, 3, 5, 12","-INNER JOIN은 B와 C가 같기 때문에 2건이다. -LEFT OUTER JOIN은 같은 것 2건과 D,E까지 포함해서 4건이 된다. -RIGHT OUTER JOIN은 같은 것 2건과 MytestB의 A까지 조회되어서 3건이 된다. -FULL OUTER JOIN은 같은 것 2건과 MytestA의 2건, MytestB의 1건 포함해서 5건이 된다. -CROSS JOIN은 MytestA의 4개의 행과 MytestB의 3개의 행을 곱해서 4*3=12건이다.",4
336,2과목,그룹 함수,다음 주어진 CUBE문과 동일한 것은?,,"GROUP BY CUBE(DEPTNO, JOB);","GROUP BY (DEPTNO, JOB, (DEPTNO, JOB), 0);","GROUP BY DEPTNO UNION GROUP BY JOB UNION GROUP BY (DEPTNO, JOB)","GROUP BY GROUPING SETS(DEPTNO, JOB, (DEPTNO, JOB), ());","GROUP BY ROLLUP(DEPTNO, JOB);",그룹 함수 중 CUBE 함수의 인자로 전달된 칼럼에 대해서 모든 결합 가능한 집계를 계산한다. GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있다. GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계없이 개별적으로 모두 처리한다.,3
337,2과목,단일행 함수,다음 쿼리의 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j587-1.png,"SELECT SUM(DECODE(SIGN(SAL-4000), 1, 1, 0)) FROM TAB1;",3,2,1,0,"SAL > 4000 이면 SAL - 4000 은 양수이므로 SIGN 을 취한 값이 1 이 리턴된다. DECODE 문을 해석하면 결국 SAL 이 4000 보다 큰 경우 1 을, 그렇지 않은 경우 0 을 리턴하므로 최종 출력값은 2 이다.",2
338,2과목,계층형 질의,아래 실행 결과를 출력하는 SQL로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j709-1.png,"SELECT 사원번호, 이름, LEVEL FROM 사원 WHERE 지역 = '경기' START WITH 상위관리자코드 IS NULL CONNECT BY 상위관리자코드 = PRIOR 사원번호;",,,,,WHERE절은 출력 대상을 결정하기 때문에 서울 지역인 홍길동은 출력하지 않는다.,4
339,2과목,집계 함수,아래 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j641-1.png,SELECT COUNT(COL1) AS RESULT FROM TAB1 WHERE COL2 >= 30 GROUP BY COL1;,,,,,WHERE절의 비교 연산 결과 COL2의 30과 40만 해당되고 그에 해당하는 COL1은 모두 NULL이다. GROUP BY에 의해 COL1이 NULL인 한 그룹이 생성되지만 NULL은 COUNT하지 않기 때문에 0이 출력된다.,2
340,2과목,서브쿼리,다음 쿼리의 수행 결과로 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j702-1.png,DELETE FROM TAB1 WHERE CODE IN (SELECT CODE FROM TAB2 WHERE STATUS = 'OPEN'); SELECT SUM(FARE) FROM TAB1;,800,600,400,100,"TAB2의 STATUS가 OPEN인 CODE는 0002와 0004이므로 TAB1에서 이들을 삭제하면 AAA,BBB만 남는다. 이들의 FARE 총합은 600이다.",2
341,2과목,트랜잭션 관리,주어진 SQL문을 수행한 결과로 올바른 것은?,,INSERT INTO test24 VALUES (1); INSERT INTO test24 VALUES (2); COMMIT; INSERT INTO test24 VALUES (3); SAVEPOINT SP; INSERT INTO test24 VALUES (4); ROLLBACK to SP; SELECT COUNT(*) FROM test24;,6,5,3,2,,3
342,2과목,DML,다음 SQL 문장의 결과로 출력되는 데이터는 무엇인가?,,"SELECT PLAYER_NAME 선수명, E_PLAYER_NAME 선수영문명 FROM PLAYER WHERE E_PLAYER_NMAE_LIKE '_A%';",위치에 상관없이 선수의 영문 이름에 A를 포함하는 선수들의 이름,선수의 영문 이름이 A로 시작하는 선수들의 이름,선수의 영문 이름이 A나 a로 시작하는 선수들의 이름,선수의 영문 이름의 두 번째 문자가 A인 선수들의 이름,"""_""와 ""%""는 와일드카드로 하나의 글자 또는 모든 문자를 대신하여 사용이 되므로 두 번째 문자가 대문자 A인 경우만 출력된다.",4
343,2과목,집합 연산자,다음 주어진 테이블에 대해서 아래의 SQL문을 수행하였을 때의 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j379-1.png,SELECT Count(*) FROM( SELECT DISTINCT COL1 FROM mytesta UNION ALL SELECT COL1 FRM mytestb );,11,12,10,4,"1번째 테이블에서 10,20,25,30,50,60이 반환되고 2번째 테이블에서 10,20,30,40,50이 반환되기 때문에 총 행 수는 11이 된다.",1
344,2과목,,다음의 SQL문 실행 결과는 무엇인가?,,SELECT * FROM dual WHERE NULL = NULL;,공집합,X,1,,SQL문에서 NULL과 NULL을 비교할 수가 없다. 만약 NULL 값을 조회하려면 is null을 사용해야 하고 NULL이 아닌 것을 조회하려면 is not null을 사용해야 한다.,1
345,2과목,윈도우 함수,다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?,,"SELECT 분류코드 AVG(상품가격) AS 상품가격, COUNT(*) OVER(ORDER BY AVG(상품가격) RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT FROM 상품 GROUP BY 분류코드;",CNT 칼럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000사이에 존재하는 상품의 개수를 구한 것이다.,CNT 칼럼은 분류코드별 평균상품가격을 서로 비교하여 -10000 ~ 10000 사이에 존재하는 분류코드의 개수를 구한 것이다.,WINDOW FUNCTION의 ORDER BY 절로 인하여 문법오류이다.,WINDOW FUNCTION을 GROUP BY(분류코드)절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다.,CNT 칼럼은 분류코드를 GROUPING된 집합을 원본집합으로 하여 분류코드별 평균상품가격을 서로 비교하고 현재 읽혀진 상품분류코드의 평균가격 대비 -10000 ~ +10000 사이에 존재하는 분류코드의 개수를 구한 것이다.,2
346,2과목,집계 함수,다음 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j642-1.png,"SELECT COL1 AS C1, SUM(COL2) AS C2 FROM TAB1 GROUP BY COL1 HAVING SUM(COL2) >= 400;",,,,,"GROUP BY 후 SUM(COL2) 연산 결과 (10, 300), (20, 400), (30, 500), (NULL, 600) 그룹이 출력된다. 이들 중 HAVING 조건에 만족하는 그룹은 (20, 400), (30, 500), (NULL, 600) 이다.",3
347,2과목,JOIN,다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?,,"가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다. 나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다. 다) EQUI JOIN은 "">"", ""<"", "">="", ""<=""를 사용한다. 라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.",라,다,나,가,"Non-EQUI join은 "">"",""<"","">="",""<=""를 사용하는 조인으로 대부분의 데이터베이스에서 잘 사용하지 않는 조인이다.",2
348,2과목,서브쿼리,다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?,,"[SQL] SELECT B.사원번호, B.사원명, A.부서번호, A.부서명 , (SELECT COUNT(*) FROM 부양가족 Y WHERE Y.사원번호 = B.사원번호) AS 부양가족수 FROM 부서 A, (SELECT * FROM 사원 WHERE 입사년도 = '2014') B WHERE A.부서번호 = B.부서번호 AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 = A.부서번호);","FROM 절의 서브쿼리는 동적 뷰(Dynamic View)라고도 하며, SQL문장 중 테이블 명이 올 수 있는 곳에서 사용할 수 있다.",WHERE 절의 서브쿼리에 사원 테이블 검색 조건으로 입사년도 조건을 FROM절의 서브쿼리와 동일하게 추가해야 원하는 결과를 추출할 수 있다.,"SELECT절에 사용된 서브쿼리는 스칼라 서브쿼리라고도하며, 이러한 형태의 서브쿼리는 JOIN 으로 동일한 결과를 추출할 수도 있다.","위 SQL에는 다중 행 연관 서브쿼리, 단일 행 연관 서브쿼리, Inline View 가 사용되었다","2014년에 입사한 사원들의 사원, 부서 정보와 부양가족수를 추출하는 SQL이다. SELECT 절에 사용된 서브쿼리는 단일행 연관 서브쿼리로 JOIN 으로도 변경이 가능하며, FROM 절에 사용된 서브쿼리는 Inline View 또는 Dynamic View 이고, WHERE 절에 사용된 서브쿼리는 다중행 연관 서브쿼리 이다. ②번 보기의 경우 이미 FROM절에 Inline View로 사원 테이블의 입사년도 조건을 명시하였으므로 WHERE 절의 EXISTS 조건은 부서와 사원 테이블간의 JOIN 조건에 의해 결과에 어떠한 영향도 미치 지 못하므로 삭제되어도 무방하다.",2
349,2과목,데이터 모델링 기법,다음 설명에 해당하는 모델링 관점은 무엇인가?,,업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점,데이터 관점,데이터와 데이터 간의 상관 관점,데이터와 프로세스의 상관 관점,프로세스 관점,-데이터 관점 : 업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링하는 방법 -프로세스 관점 : 업무가 실제로 하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링 하는 방법 -데이터와 프로세스의 상관 관점 : 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법,1
350,2과목,데이터베이스 개념,다음에서 설명하고 있는 식별자는?,,데이터베이스 키는 생성 여부에 따라 (A) 식별자와 (B)식별자로 분류된다. (A) 식별자는 엔터티 스스로 생성되는 식별자이고 (B)식별자는 다른 엔터티 간의 관계에 의해서 만들어지는 식별자이다.,"A : 인조 식별자, B : 본질 식별자","A : 내부 식별자, B : 외부 식별자","A : 외부 식별자, B : 내부 식별자","A : 기본키, B : 대체키","-내부 식별자는 엔터티 내부에서 스스로 생성되는 식별자이다. -예를 들어 부서코드, 주문번호, 종목코드 등이 있다. -다른 엔터티의 관계로 인하여 만들어지는 식별자이다. -예를 들어 계좌 엔터티에 회원ID이다.",2
351,2과목,윈도우 함수,다음 주어진 테이블이 아래의 결과와 같이 반환되도록 SQL문의 빈칸에 들어갈 것으로 알맞은 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j450-1.png,"SELECT ( ) OVER(ORDER BY SAL DESC) AS RANK, NAME, DEPTNAME, POSITION, SAL FROM TEST44;",NTILE(),ROW_NUMBER(),DENSE_RANK(),RANK(),RANK() 함수는 동일한 점수면 같은 등수를 부여한다.,4
352,2과목,그룹 함수,아래 SQL의 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j656-1.png,"SELECT PRODUCT_NO, GOGAK_NO, SUM(QTY) AS TOTAL_QTY FROM JUMUN GROUP BY GROUPING SETS(PRODUCT_NO, GOGAK_NO, ());",,,,,"GROUPING SETS(PRODUCT_NO, GOGAK_NO, ())에서 PRODUCT_NO별 SUM(QTY) 결과, GOGAK_NO별 SUM(QTY)연산 결과가 출력된 것과 ()으로 인해 SUM(QTY)의 전체 총 합이 출력된 것을 찾는 문제이다.",4
353,2과목,DML,다음의 SQL문이 반환하는 결괏값은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j297-1.png,"select * from Mytest order by COL1 desc, COL2 desc, COL3 desc;",,,,,"해당 SQL문은 주어진 테이블인 Mytest에서 CO1, COL2, COL3 속성 순서대로 내림차순 정렬을 수행한다. (1,null,1)은 COL1 desc에 의해 먼저 정렬되므로 마지막 행에 위치한다. COL1을 정렬해서 값이 동일한 행은 COL2 desc를 수행하는데, COL2 열도 동일한 행이 있으므로 그 행들에 대해 COL3 desc를 수행한다.",2
354,2과목,집합 연산자,다음 주어진 테이블에 대해서 아래와 같은 SQL문을 수행하였을 때 반환되는 ROW 값의 수는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j277-1.png,select * from A1 union select * from B1 minus select * from C1;,4,3,2,1,"select * from A union select * from B를 실행하면 1,2,3,4,5가 반환된다. 해당 결과에 MINUS 조인을 하면 4,5가 빠지기 때문에 최종적으로 1,2,3 이 된다.",2
355,2과목,윈도우 함수,"다음 SQL문을 실행하여 나오는 결과의 빈칸 (ㄱ),(ㄴ)을 작성하시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j354-1.png,"SELECT NTILE2, COUNT(*) AS CNT FROM( SELECT COL1, COL2, COL3, NTILE(3) OVER(ORDER BY COL3) AS NTILE2 FROM Mytest ) GROUP BY NTILE2;","ㄱ : 3, ㄴ : 2","ㄱ : 1, ㄴ : 3","ㄱ : 2, ㄴ : 3","ㄱ : 3, ㄴ : 1","주어진 테이블에서 COL3 속성의 값 7개를 2,2,2로 균등하게 3등분하고 남은 값을 앞에서부터 순차적으로 할당하므로 3,2,2개씩 파티션이 분할된다. 그러면 NTILE2에서는 각각 분할된 파티션별 번호인 1,2,3이 할당되고 CNT에서는 각각에 분할된 파티션별 행의 수가 카운트 되어 3,2,2가 반환된다.",2
356,2과목,그룹 함수,아래의 결괏값을 보고 SQL문의 빈칸에 들어 갈 수 있는 내용을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j205-1.png,"SELECT DEPTNO, JOB, SUM(SAL) FROM SQLD_73 GROUP BY ( );","CUBE(DEPTNO, JOB)","DEPTNO, JOB","GROUPING SETS(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","주어진 결괏값을 보면 1.DEPTNO별 합계, 2.DEPTNO, JOB별 합계, 3.전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다.",4
357,2과목,SP,아래는 임시부서(TMP_DEPT) 테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?,,"[PL/SQL] create or replace procedure insert_dept authid_current_user as begin (ㄱ) INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC) SELECT DEPTNO, DNAME, LOC FROM TMP_DEPT; commit; end;",execute 'TRUNCATE TABLE DEPT';,execute immediate 'TRUNCATE TABLE DEPT';,DELETE FROM DEPT;,TRUNCATE TABLE DEPT;,PL/SQL 에서는 동적 SQL 또는 DDL 문장을 실행할 때 EXECUTE IMMEDIATE 사용하여야 한다. ③번은 ROLLBACK이 가능하도록 삭제하는 것이 아니므로 옳은 답이 아니다.,2
358,2과목,집계 함수,아래와 같은 테이블 데이터가 있다. SQL에 대한 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j649-1.png,SELECT SUM(T1.COL2) FROM TAB1 T1 WHERE T1.COL2 = (SELECT MAX(COL2) FROM TAB1 T2 WHERE T1.COL1 = T2.COL1);,100,90,,에러,"서브쿼리 조건절은 TAB1의 각 행의 COL1을 확인하여 같은 값을 갖는 행들 중 COL2의 최대값과 일치하는 행을 찾아 COL2의 총 합을 묻는 질의절이다. 즉, COL1별 COL2 값이 최대인 행들의 COL2의 총 합을 리턴하는 문장이므로 A그룹에서는 30,30, B그룹에서는 40이 리턴되어 총 100이 출력된다.",1
359,2과목,단일행 함수,다음 함수의 결과로 가장 적절한 것은?,,"SELECT LTRIM('ORACLE', 'A') AS C1, SUBSTR('SQL-SERVER', 3, 3) AS C2, LENGTH(REPLACE('SQL-SERVER', 'E')) AS C3 FROM DUAL;",,,,,"LTRIM은 왼쪽에서부터 특정 문자열를 지우며, 중간에 있는 문자열은 삭제되지 않는다. 따라서 LTRIM('ORACLE','A'은 왼쪽에 A가 없으므로 ORACLE 그대로 리턴된다. SUBSTR('SQL-SERVER', 3, 3)은 세 번째 위치에서 3개 문자열 을 추출하기 때문에 L-S가 출력된다. 또한, REPLACE에 의해 E가 삭제된 문자열의 길이는 8이 된다.",2
360,2과목,그룹 함수,다음 주어진 두 개의 테이블에 대해서 아래와 같은 결괏값이 반환되도록 아래의 SQL문의 빈칸에 들어갈 값을 적으시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j556-1.png,"SELECT b.grade, a.StudentNo, SUM(b.grade) FROM TEST44_1 a, TEST44_2 b GROUP by ( );","GROUPING SETS(a.studentno, (b.grade, a.studentno));","GROUPING SETS(b.grade, (b.grade, a.studentno));","GROUPING SETS(b.grade, (a.studentno, b.grade));","GROUPING SETS(b.grade, (a.studentno));","결괏값을 보면 1.b.Grade, a.StudentNo에 대한 집계, 2.b.grade에 대한 집계가 있고 전체 집계는 없다.",2
361,2과목,DML,다음 문장의 수행 후 TAB2의 조회 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j718-1.png,ALTER TABLE TAB2 ADD FOREIGN KEY(CLASS_NO) REFERENCES TAB1(NO) ON DELETE SET NULL; DELETE FROM TAB1 WHERE NAME = 'C';,,,,,ON DELETE SET NULL 옵션에 의해 TAB1 데이터 삭제 시 자식 데이터의 외래키 컬럼은 NULL로 수정된다.,2
362,2과목,단일행 함수,"아래 SQL의 실행 결과로 알맞은 것은? (단, 문자타입인 경우 ''를 붙여서 표현, 숫자타입인 경우 숫자만 전달)",,"SELECT LTRIM(' AB DE ') AS C1, INITCAP('ABCDE') AS C2, TO_CHAR('123', '999.99') AS C3 FROM DUAL;",,,,,"LTRIM 함수에 제거문자열을 전달하지 않을 경우 왼쪽에서 공백을 제거한다. INITCAP 함수는 첫 문자만 대문자로 나머지 문자는 소문자로 반환하는 함수이며, TO_CHAR 함수에 의해 소수점 둘째 자리까지, 정수자리는 세자리로 표현하여 리턴한다.",4
363,2과목,DML,다음 주어진 테이블에서 아래의 SQL문의 결과값으로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j422-1.png,SELECT COUNT(*) FROM limbest.emp WHERE JOB = 'CLERK' OR (ENAME LIKE 'T%' AND SAL >= 3000);,8건,7건,6건,5건,"ENAME은 모두 ""T""로 시작한다. 따라서 SAL이 3000이상인 사람이 3건이고 JOB이 ""CLERK""은 4건이다. 따라서 총 7건이 조회된다.",2
364,2과목,집계 함수,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j654-1.png,SELECT SUM(COL1) FROM TAB1 T1 WHERE COL3 >= (SELECT AVG(COL3) FROM TAB2 T2 WHERE T2.COL2 = T1.COL2);,23,9,0,,"T2.COL2 값의 그룹별로 COL3의 평균보다 T1.COL3의 값이 큰 행을 찾고, 이들의 T1.COL1의 총 합을 구하는 질의절이다. T2에서 COL2의 값이 A인 그룹의 AVG(COL3)은 20이므로 T1에서 A그룹이면서 COL3의 값이 20보다 크거나 같은 대상을 찾으면 0건이 출력된다. 마찬가지로 T2에서 B그룹의AVG(COL3)을 구하면 20이고, T1의 B그룹중 COL3 의 값이 20보다 크거나 같은 행은 COL1의 값이 4,5인 행이므로 최종 결과는 9가 리턴된다.",2
365,2과목,JOIN,"아래의 테이블 스키마 정보를 참고하여, 다음 중 '구매 이력이 있는 고객 중 구매 홧수가 3회 이상인 고객의 이름과 등급을 출력하시오'라는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 구문으로 가장 적절한 것은?",,"[테이블] 고객(고객번호(PK), 이름, 등급) 구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK)) * 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다. [SQL 문장] SELECT A.이름 , A.등급 FROM 고객 A (ㄱ) GROUP BY A.이름 ,A.등급 (ㄴ)",(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : WHERE B.구매번호〉=3,(ㄱ) : LEFT OUTER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B.구매번호) >=3,(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING COUNT(B. 구매번호) >=3,(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B. 구매번호)〉=3,,3
366,2과목,,다음 주어진 테이블에 대해서 아래의 SQL문을 수행하였을 때의 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j507-1.png,SELECT CASE WHEN SUM (COL1 + COL2) IS NULL THEN 0 ELSE SUM(COL1 + COL2) END AS 합계 FROM TEST32;,25,22,12,,,2
367,2과목,ER 모델링,아래 시나리오에서 엔터티로 가장 적절한 것은?,,"A 쇼핑몰에서 상품을 주문하려면 회원에 가입해야 한다. 회원가입 시에는 회원ID, 이름, 전화번호를 입력하고 주문을 할 때는 배송지 주소를 입력해야 한다.",배송지 주소,A 쇼핑몰,회원,이름,"회원이라는 엔터티에 회원ID, 이름, 전화번호 속성이 있는 것이다. 엔터티는 2개 이상의 속성과 2개 이상의 인스턴스를 가진다.",3
368,2과목,ER 모델링,다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?,,1) 모든 릴레이션은 원자값을 가져야 한다. 2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다. 3) 실제 속성값이 올바르게 되었는지 확인한다 4) 속성명과 반드시 동일할필요는 없다.,차수,인스턴스,도메인,카디날리티,"예를 들어 도메인이란, 성별이라는 속성에서 값이 가질 수 있는 허용 범위를 나타낸다. 즉, 성별의 경우 남자는 'M', 여자는 'F'의 값을 가진다.",3
369,2과목,계층형 질의,"아래의 계층형 SQL에서 리프 데이터면 1, 그렇지 않으면 0을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은?",,"SELECT LEVEL, LPAD(' '.4 * (LEVEL-1) || EMPNO, MGR, () AS ISLEAF FROM SCOTT.EMP START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;",CONNECT_BY_ROOT,SYS_CONNECT_BY_PATH,CONNECT_BY_ISCYCLE,CONNECT_BY_ISLEAF,,4
370,2과목,DML,다음 보기와 동일한 SQL문은?,,SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B,SELECT * FROM MYTEST WHERE COL1 <= :A OR COL1 >= B,SELECT * FROM MYTEST WHERE COL1 >= :A OR COL1 <= :B,SELECT * FROM MYTEST WHERE COL1 <= :A AND COL1 >= :B,SELECT * FROM MYTEST WHERE COL1 >= :A AND COL1 <= :B,"BETWEEN은 같은 것도 포함된다. 즉, 크거나 같은 것이 조회된다.",4
371,2과목,집합 연산자,"테이블이 아래와 같을 때, 다음 집합연산자 수행 결과로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j655-1.png,"SELECT * FROM (SELECT COL1, COL2 FROM TAB1 UNION SELECT COL1, COL2 FROM TAB2) MINUS SELECT COL1, COL2 FROM TAB3;",,,,,먼저 TAB1과 TAB2의 UNION 결과는 아래와 같다. 이들 중 TAB3의 결과를 빼면 3번 결과가 같다.,3
372,2과목,윈도우 함수,아래 SQL 문장 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j755-1.png,"SELECT EMPNO, ENAME, DEPTNO, SAL, LAG(SAL, 2, 0) OVER(PARTITION BY DEPTNO ORDER BY SAL) LAG_VALUE FROM EMP;",,,,,같은 DEPTNO내에서 SAL이 낮은 순서대로 이전 이전 값을 가져오는 문장이다. 가져올 값이 없을 경우 0으로 리턴 한다.,3
373,2과목,JOIN,다음 중 HASH 조인의 순서로 올바른 것은?,,가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다. 나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다. 다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다. 라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다. 마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.,가 -> 라 -> 나 -> 마 -> 다,나 -> 가 -> 마 -> 라 -> 다,가 -> 나 -> 라 -> 마 -> 다,가 -> 나 -> 다 -> 라 -> 마,가->나->다->라->마 순서대로 해시 조인을 실행한다.,4
374,2과목,집계 함수,다음의 SQL문을 실행한 결과를 쓰시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j358-1.png,"SELECT SUM(CASE WHEN COL1 ='A' THEN 1 END) AS SUM1, SUM(CASE WHEN COL3 < 20000 THEN 1 END) AS SUM2 FROM Mytest;","4,8","3,7","2,6","1,5","SUM1은 COL1 ='A'조건을 만족하는 1,2,3행을 각각 1로 되돌리고 합계를 계산하기 때문에 3이 된다. COL2 < 20000 조건은 모든 행이 만족하고 1을 되돌리므로 합계는 7이 된다.",2
375,2과목,단일행 함수,다음 SQL 실행 결과로 가장 알맞은 것은?,,"SELECT REGEXP_SUBSTR('ORA-00600 Oracle SQL-Server 50', '[^0-9]+') ""REGEXPR_SUBSTR"" FROM DUAL;",ORA- Oracle SQL-Server,ORA-,00600 50,50,[^0-9]+ 는 숫자가 아닌 값이 여러 개 반복되는 문자열을 의미한다. REGEXP_SUBSTR은 이 패턴에 해당하는 값을 처음부터 찾아 단 하나의 문자열을 추출하므로 ORA-만 추출된다.,2
376,2과목,서브쿼리,다음 보기의 Sub Query 유형은 무엇인가?,,"SELECT A.EMPNO, A.ENAME FROM EMP A WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);",Looping Sub Query,Correlated Sub Query,Early Filter형 Sub Query,Service Sub Query,"상호연관 서브쿼리는 메인쿼리 값을 서브쿼리가 사용하고 서브쿼리의 값을 받아서 메인쿼리가 계산되는 쿼리이다. 문제에 나온 SQL문에서 EMP 테이블은 메인쿼리이고 EMP_T 부분은 서브쿼리이다. 즉, EMP_T의 서브쿼리가 실행되어서 1이 나오면 메인쿼리의 WHERE절 조건과 비교된다.",2
377,2과목,집합 연산자,다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.,,SELECT ... FROM 급여이력 S WHERE NOT EXISTS (SELECT 'X' FROM 사원 P WHERE P.사원번호 = S.사원번호) [SQL문] SELECT .... FROM 급여이력 S LEFT OUTER JOIN 사원 P ON(S.사원번호=P.사원번호) WHERE ( );,P.사원번호 IS NULL,P.사원번호 IS NOT NULL,P.사원번호 > 0,P.사원번호 = NULL,NOT EXISTS는 OUTER JOIN으로 변경할 경우 NOT NULL칼럼에 대해서 IS NULL로 검사하여 NOT EXISTS를 구현한다.,1
378,2과목,계층형 질의,다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. ( )에 올바른 것은?,,"SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, ( ) AS ISLEAF FROM Mytest START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;",CONNECT_BY_LEAF,SYS_CONNECT_BY_PATH,CONNECT_BY_ISCYCLE,CONNECT_BY_ISLEAF,"-CONNECT_BY_ISLEAF : 전개 과정에서 해당 데이터가 리프 데이터면 1, 아니면 0을 반환한다. -CONNECT_BY_ISCYCLE : 전개 과정에서 자식을 갖는데, 해당 데이터가 조상으로 존재하면1, 그렇지 않으면 0을 반환한다. 여기서 조상이란 자신으로부터 루트까지의 경로에 존재하는 데이터를 말한다. -SYS_CONNECT_BY_PATH : 하위 레벨의 칼럼까지 모두 표시해준다.",2
379,2과목,JOIN,SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?,,"SELECT * FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO AND B.DNMAE ='KIM'",SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B ON A.DEPTNO = B.DEPTNO WHERE 1=1 AND B.DNAME = 'KIM';,SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'KIM') WHERE 1=1;,SELECT * FROM SCOTT.EMP A RIGHT OUTER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'KIM') WHERE 1=1;,SELECT * FROM SCOTT.EMP A LEFT OUTER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'KIM') ;,조인 조건과 조회 조건이 분리되어야 하므로 조회 조건은 WHERE절로 분리되어야 한다. OUTER JOIN이 아닌 INNER JOIN이므로 INNER JOIN에 조회 조건 분리가 된 ①번이 맞다.,1
380,2과목,집계 함수,다음 주어진 테이블에 대해서 아래의 SQL문을 수행한 행수로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j513-1.png,"SELECT COUNT(COL1), COUNT(COL2) FROM ( SELECT DISTINCT COL1, COL2 FROM TEST40 );","3,3","2,2","2,1","1,2","DISTINCT 명령어로 중복된 COL1, COL2값은 제외되어 COL1, COL2이 (조조,1), (조조,2),(조조,3)이 된다.",1
381,2과목,계층형 질의,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j761-1.png,"SELECT SYS_CONNECT_BY_PATH(DNAME, '-') FROM DEPARTMENT WHERE DEPTNO = 103 START WITH PART IS NULL CONNECT BY PART = PRIOR DEPTNO ;",-컴퓨터정보학부,-소프트웨어공학과-컴퓨터정보학부,-컴퓨터정보학부-소프트웨어공학과,-소프트웨어공학과,최상위 학과인 컴퓨터정보학부와 인문사회학부로부터 시작하여 하위 학과들을 연결한 후 루트노드로부터의 연결과 정을 '-'로 이어서 출력하는 과정이다. DEPTNO가 103번인 소프트웨어공학과의 상위학과는 컴퓨터정보학부이다.,3
382,2과목,윈도우 함수,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j608-1.png,"SELECT 주문번호, 일자, SUM(주문금액) OVER(ORDER BY 일자) AS 주문금액, DENSE_RANK() OVER(PARTITION BY 지점 ORDER BY 주문금액) AS 순위 FROM 주문내역;",,,,,"SUM의 경우 ORDER BY 사용 시 ORDER BY 컬럼 순서대로 누적 합을 계산하는데, 이때 범위는 RANGE가 기본이다. RANGE란 ORDER BY 절에 명시된 컬럼의 값이 같을 경우 하나의 그룹으로 묶어서 누적 합을 계산하는 범위를 말한다. 따라서 2024.01.02 값이 두 개이므로 각각 1000과 2000이 먼저 3000으로 결합되어 두 번째와 세 번째 행의 누적 합이 둘 다 4000이 된다. DENSE_RANK의 경우 동순위 발생 뒤 순위가 연속적으로 출력되므로 주문번호가 3인 행의 순위는 2위가 된다.",2
383,2과목,,다음의 SQL 실행 결과는 무엇인가?,,SELECT sysdate + NULL FROM DUAL;,,내일 날짜가 조회된다.,오늘 날짜가 조회된다.,0,날짜형 데이터와 NULL을 더하면 NULL이 된다.,1
384,2과목,집합 연산자,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j703-1.png,SELECT SUM(COL2) FROM TAB1 WHERE COL2 < ANY(SELECT FARE FROM TAB2);,1000,600,300,100,"ANY는 작다와 만나면 값들 중 최댓값을 리턴한다. 따라서, 메인쿼리 WHERE절은 COL2 < 350 이 되므로 A, B, C들의 COL2의 총 합은 600이 된다.",2
385,2과목,JOIN,다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?,,"SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E LEFT JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE E.SAL > 3000 ORDER BY E.ENAME;","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE E.SAL > 3000 ORDER BY E.ENAME;","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D USING DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;","조인 조건에 성립하는 행만 출력하는 INNER JOIN이 수행되었으므로 조인조건을 ON절에, 일반조건을 WHERE절에 각각 명시하면 된다. USING을 사용하는 경우 반드시 괄호로 묶어서 전달해야 한다.",2
386,2과목,계층형 질의,다음은 계층형 쿼리를 수행하는 SQL문이다. ( )에 해당되는 것으로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j279-1.png,SELECT * FROM Mytest START WITH ( ㄱ ) IS NULL CONNECT BY PRIOR ( ㄴ ) AND today BETWEEN '2017-01-01' AND '2022-12-31' ORDER SIBLINGS BY empid;,(ㄱ) mgrid (ㄴ) mgrid = empid,(ㄱ) mgrid (ㄴ) empid = mgrid,(ㄱ) empid (ㄴ) mgrid = empid,(ㄱ) empid (ㄴ) empid = mgrid,mgrid가 NULL인 값을 시작해서 empid로 조회를 전개하는 순방향 조회를 하고 있다. 순방향 전개를 하면서 empid로 정렬한다.,2
387,2과목,집계 함수,다음 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j690-1.png,SELECT COUNT(COL1) RESULT FROM TAB1 WHERE COL3 < 100 GROUP BY COL1; SELECT COUNT(COL1) RESULT FROM TAB1 WHERE COL1 IS NOT NULL GROUP BY COL1 HAVING SUM(COL2) > 500;,,,,,"첫 번째 문장은 조건에 만족하는 COL1값이 NULL이므로 NULL 그룹이 리턴된다. 따라서 COUNT를 하면 0이 출력되며, 두 번째 문장은 HAVING 조건에 만족하는 그룹이 없으므로 공집합이 출력되어 COUNT 결과가 NULL이 된다.",2
388,2과목,윈도우 함수,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j757-1.png,"SELECT RATIO_TO_REPORT(COL2) OVER() AS C1, CUME_DIST() OVER(ORDER BY COL2) AS C2, ROUND(PERCENT_RANK() OVER(ORDER BY COL2),2) AS C3 FROM TAB1;",,,,,"RATIO_TO_REPORT는 총 합 기준 COL2의 값의 크기에 대한 차지 비율을 출력, CUME_DIST는 COL2 순서대로 각 행의 상대적 누적 위치 출력, PERCENT_RANK는 COL2 순서대로 각 행의 누적 분위수(0~1 사이)를 출력한다.",4
389,2과목,집계 함수,다음 출력 결과를 갖도록 하는 빈칸의 문장으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j707-1.png,"SELECT EMPNO, ENAME, DEPTNO, SAL, SUM(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL ____________________) AS RESULT FROM EMP;",ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING,ROWS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING,RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING,RANGE BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING,"누적합의 범위가 각 행마다 이전행과 현재행, 다음행을 연산하고 있으므로(JONES 기준 1100 + 2975 + 3000 = 7075) 1 PRECEDING AND 1 FOLLOWING 이며, SAL이 같은 SCOTT과 FORD의 누적합이 각각 다르게 계산되었으므로 ROWS가 적절하다.",1
390,2과목,DML,다음의 테이블이 있을 경우 SQL을 수행하였을 때 출력결과를 순서대로 나열한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j429-1.png,SELECT CASE WHEN C1=1 THEN 10 WHEN C1=2 THEN 20 ELSE C1 END FROM Mytest;,"1,2,30","10,20,30","10,20,3","1,2,3",CASE 문의 조건문에 따라서 1은 10으로 2는 20으로 입력된다.,3
391,2과목,JOIN,다음 ANSI 문법을 오라클 문법으로 바꾼 것으로 가장 적절한 것은?,,SELECT * FROM TAB1 JOIN TAB2 ON TAB1.COL1 = TAB2.COL1 LEFT OUTER JOIN TAB3 ON TAB1.COL2 = TAB3.COL2;,"SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2(+);","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2(+);","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2;","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2;",TAB1과 LEFT OUTER JOIN인 테이블은 TAB3이므로 TAB1과 TAB3의 관계에만 TAB3의 컬럼에 (+)를 붙여주면 된다.,2
392,2과목,집계 함수,아래의 테이블에 대해서 주어진 SQL문을 수행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j550-1.png,"SELECT A.jumin as ""주문"", B.custrank as ""고객등급"" FROM (SELECT jumun, SUM(price) AS Total FROM test34_1 GROUP BY jumun) A, test34_2 B WHERE A.Total BETWEEN B.minprice AND B.maxprice;",,,,,"먼저 FROM절에 있는 inline view의 실행 결과는 20, 7500과 10, 5000의 합계가 조회된다. 그리고 test34_2의 BETWEEN구로 조회하면 10번 VIP가 조회된다.",2
393,2과목,계층형 질의,"아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은?",,"SELECT LEVEL, EMPNO, MGR, _____________ AS 리프노드여부 FROM SCOTT.EMP START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;",CONNECT_BY_ROOT,SYS_CONNECT_BY_PATH,CONNECT_BY_ISCYCLE,CONNECT_BY_ISLEAF,각 행이 리프 노드 데이터인지 여부를 출력해주는 계층형 질의절의 가상 함수 CONNECT_BY_ISLEAF이다.,4
394,2과목,단일행 함수,다음의 SQL문 실행 결과를 고르시오.,,"SELECT ROUND(3.47,1) AS DATA1 FROM DUAL;",4,3,"3,5","3,4",ROUND 함수의 첫 번째 인자값인 3.47을 소수 첫째 자리까지 반올림한다.,3
395,2과목,집계 함수,다음의 SQL문을 실행한 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j343-1.png,"SELECT SUM(A.N1) FROM MytestA A, MytestB B WHERE A.V1 <> B.V1;",9,12,32,10,,2
396,2과목,DML,다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?,,INSERT INTO TAB1 VALUES(1); INSERT INTO TAB1 VALUES(2); SAVEPOINT SV1; UPDATE TAB1 SET COL1=7 WHERE COL1=2; INSERT INTO TAB1 VALUES(9); SAVEPOINT SV2; DELETE TAB1 WHERE COL1=7; INSERT INTO TAB1 VALUES(11); SAVEPOINT SV3; INSERT INTO TAB1 VALUES(9); ROLLBACK TO SV2; COMMIT;,"1,2","1,9,11,9","1,9,11","1,7,9",SQL문의 맨 하단에서 ROLLBACK TO SV2명령어를 수행하면 SAVEPOINT SV2 지점까지 변경 된 것을 모두 취소한다.,4
397,2과목,집계 함수,다음 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j751-1.png,"SELECT SUM(E2.SAL) AS RESULT FROM EMP E1, EMP E2 WHERE E1.HIREDATE >= E2.HIREDATE GROUP BY E1.ENAME;",,,,,"셀프조인을 통해 각 행마다 입사일이 작거나 같은 모든 행을 출력하는 쿼리로, 각 행마다의 누적 급여 총 합을 출력 하게 된다.",2
398,2과목,단일행 함수,"다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?",,SELECT SYSDATE FROM DUAL;,CONVERT,TO_CHAR,TO_DATE,TO_NUMBER,TO_CHAR문을 사용하면 문자형 타입으로 변환한다.,2
399,2과목,DML,다음 SQL문과 동일한 결과를 반환하는 SQL문은?,,select * from Mytest where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);,select * from Mytest where COL1 = 1 or (COL2 = 3 or COL2 = 4);,"select * from Mytest where COL1 in (1,3) or COL2 in (1,4);","select * from Mytest where COL1 in (1,3) and COL2 in (1,4);",select * from Mytest where COL1 = 1 and (COL2 = 3 or COL2 = 4);,"주어진 SQL문은 COL1, COL2 값이 각각(1,3) (1,4)인 행들만 조회되는 SQL문이다. 이와 같은 값을 반환하는 보기는 COL1이 1이면서 COL2가 3 또는 4인 값을 조회하는 ④번 보기이다.",4
400,2과목,단일행 함수,"오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?",,"SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;",2015.01.10.10:30:00,2015.01.10.10:10:00,2015.01.10.10:05:00,2015.01.10.11:01:00,,2
401,2과목,집계 함수,다음 보기의 결괏값을 얻기 위한 SQL문을 작성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j298-1.png,"SELECT ( ) AS A, ( ) AS B, ( ) AS C from Mytest","max(COL1), max(COL2), max(COL1)","max(COL1), min(COL2), sum(COL2)","max(COL1), min(COL2), sum(COL1)","max(COL2), min(COL2), sum(COL1)","A 속성은 COL1의 최댓값, B 속성은 COL2의 최솟값, C 속성은 COL1 속성의 합이다.",3
402,2과목,단일행 함수,"아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)",,"SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;",2024.08.24 09:59:30,2024.08.24 09:30:00,2024.08.24 06:00:00,2024.07.25 10:00:00,"오라클에서 날짜 연산 단위는 DAY(일)이다. 따라서 30/24/60 은 30*1/24/60 인데 1/24/60 는 1 분을 의미한다. (1(하루)를 24 로 나누면 1 시간, 다시 60 으로 나누면 1 분이 된다.) 따라서 30 분 이전을 출력하되, TO_CHAR 에서 요구하는 날짜 포맷으로 출력하면 2024.08.24 09:30:00 이 된다.",2
403,2과목,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j595-1.png,SELECT COUNT(*) AS RESULT FROM TAB1 WHERE COL1 = 200 GROUP BY COL1; SELECT SUM(COL2) AS RESULT FROM TAB1 WHERE COL1 = 100; SELECT COUNT(COL1) AS RESULT FROM TAB1 WHERE COL3 = 400;,,,,,"첫 번째 문장은 COL1 = 200 조건에 만족하는 값이 없고, 공집합을 GROUP BY 하면 아무것도 출력되지 않는다. 따라서 공집합에 대한 COUNT 결과는 0 이 아닌 공집합이 출력되므로 컬럼명만 출력되는 형태로 리턴된다. 두 번째 문장은 첫 번째 행에 대한 SUM(COL2)를 출력하게 되는데, 첫 번째 행의 COL2 값이 NULL 이므로 NULL 이 출력된다. NULL 로만 구성된 데이터의 SUM, AVG, MIN, MAX 등의 결과는 NULL 이 리턴되며 COUNT 만 0 으로 출력된다. 따라서 세 번째 문장의 출력값은 0 이 된다.",1
404,2과목,집계 함수,다음 SQL문의 ( )에 들어가는 것으로 올바르지 않은 것은?,,"SELECT ( ), Count(Empno) FROM EMP WHERE EMPNO > 0 GROUP BY DEPTNO, SAL;",Deptno 와 Sal,Sal,Deptno,Empno,SELECT구에는 GROUP BY절에 있는 칼럼만 나와야 한다.,4
405,2과목,서브쿼리,릴레이션 'employee'와 'department'에서 다음 SQL 질의문의 수행 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j215-1.png,"SELECT e.dno, d.dname, e.ename, e.score FROM employee e, department d WHERE e.dno = d.dno and (e.dno, score) IN (SELECT dno, max(score) FROM employee GROUP BY dno);","{(100,영업,Hong,80), (100,영업,Lee,90),(200,개발,Kim,90),(200,개발,Kim,95),(600,null,Hong,65)}","{(100,영업,Lee,90)}","{(100,영업,Lee,90),(200,개발,Kim,95)}","{(100,영업,Lee,90),(200,개발,Kim,90),(300,서비스,Hong,65)}","서브쿼리만 실행하면 DNO와 MAX(SCORE) 값이 {100,90},{300,65},{200,95} 이다. IN 문을 사용해서 조인을 하므로 {(100,영업,Lee,90),(200,개발,Kim,95),(300,서비스,Hong,65)}가 조회된다.",4
406,2과목,DML,"주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)",,"insert into test32 values (null,10); insert into test32 values (12,null); insert into test32 values (null,null); insert into test32 values (10,12); ㄱ. SELECT COUNT(COL1) FROM test32; ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null); ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;","4,2,3","2,2,3","2,1,3","2,3,4","ㄱ은 COUNT(COL1)을 사용하므로 NULL은 제외되기 때문에 2가 된다. 그리고 ㄴ은 IN구를 사용해서 NULL까지 조건으로 넣었지만, 12,10만 조회된다. 즉, NULL은 제외된다. 그리고 ㄷ은 COL1로 GROUP BY하였으므로 3건이 된다.",2
407,2과목,DDL,테이블의 칼럼을 변경하는 DDL문으로 올바른 것은?,,TEST 테이블의 NAME 칼럼의 데이터 타입을 CHAR에서 VARCHAR로 변경하고 데이터 크기를 100으로 늘린다.,ALTER table TEST add constraint column name NAME varchar(100),ALTER table TEST add column NAME varchar(100);,ALTER table TEST modify (NAME varchar(100));,ALTER talbe TEST alter column NAME varchar(100);,칼럼의 변경은 ALTER TABLE ~ MODIFY문을 사용하면 된다. 데이터 타입이나 길이를 변경할 수 있다.,3
408,2과목,서브쿼리,다음 SQL문의 실행 결과로 올바른 것을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j206-1.png,"SELECT DISTINCT DEPARTMENT_ID FROM HR.EMPLOYEES A WHERE A.DEPARTMENT_ID <= ALL (30,50);","10,20,30,40,50","10,20,30,40","10,20,30","10,20",ALL 연산자는 서브쿼리 값 모두가 조건에 만족하면 True를 반환한다.,3
409,2과목,,다음의 SQL문과 동일한 것을 고르시오.,,"Select NVL(Name,'없음') From Emp;",Select Case When Name IS NULL THEN '없음' ELSE '0' END AS USER_NAME FROM Emp;,Select Case When Name IS NULL THEN '없음' ELSE NAME END AS USER_NAME FROM Emp;,Select Case When Name IS NOT NULL THEN '0' ELSE NAME END AS USER_NAME FROM Emp;,Select Case When Name IS NOT NULL THEN NAME ELSE '0' END AS USER_NAME FROM Emp;,"IS NULL 함수는 만약 NULL이면 ""없음""을 출력하고 그렇지 않으면 NAME 칼럼의 값을 출력하는 것이다.",2
410,2과목,DML,"다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)",,"SELECT SYSDATE, TO_DATE(SYSDATE,'YYYY') FROM DUAL;",에러가 발생한다.,22 - 04 - 30 00 : 00 : 00 2022,2022/04/30 00 : 00 : 00 2022,2022 - 04 - 30 00 : 00 : 00 2022,SYSDATE는 Oracle에서 오늘의 날짜와 시간을 가지고 있는 Date 타입이다.따라서 Date 타입을 다시 TO_DATE로 형 변환을 하면 동일 타입을 변환하기 때문에 오류가 발생한다. 즉 이러한 경우는 TO_CHAR를 사용해서 문자형 타입으로 변환해야 한다.,1
411,2과목,계층형 질의,다음 중 아래의 TEST10 테이블에 대해서 SQL문을 수행하였을 때의 결과 건수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j533-1.png,"SELECT LPAD('**', (LEVEL-1)*2, ' ')|| EMPNO AS EMP, NAME FROM TEST10 WHERE EMPNO <> 3 START WITH EMPNO = 3 CONNECT BY EMPNO = PRIOR MANAGER;",3,2,1,0,위의 SQL에서 WHERE 조건에 의하여 EMPNO 3번은 조회에서 제외된다. 그리고 EMPNO가 3번으로 시작하여 계층형 조회를 한다. 따라서 EMPNO 1번과 2번 2개의 행이 조회된다.,2
412,2과목,단일행 함수,다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?,,"SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;",각 직원의 입사날짜로부터 6개월 후 두 번째 월요일에 해당하는 날짜,각 직원의 입사날짜로부터 6개월 후 첫 번째 월요일에 해당하는 날짜,각 직원의 입사날짜로부터 6일 후 두 번째 월요일에 해당하는 날짜,각 직원의 입사날짜로부터 6일 후 첫 번째 월요일에 해당하는 날짜,"ADD_MONTHS는 지정한 날짜에서 n개월 이후 날짜를 출력하는 함수이다. NEXT_DAY(날짜,요일) 는 지정한 날짜 뒤 의 첫 번째 지정요일에 해당하는 날짜를 리턴한다.",2
413,2과목,집계 함수,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j742-1.png,"SELECT COL2, SUM(COL3) AS C1, MIN(COL3) AS C2, MAX(COL3) AS C3 FROM TAB1 WHERE COL1 > 100 GROUP BY COL2;",,,,,"COL1 > 100 조건에 만족하는 값은 COL1이 200, 300, 400, 500, 300인 행이다. 이들을 COL2에 의해 그룹핑을 하면 A, B, NULL그룹이 리턴되며, NULL일 때의 SUM(COL3), MIN(COL3)은 모두 20이 리턴된다.",4
414,2과목,JOIN,SQL의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j648-1.png,SELECT COUNT(TAB1.NO) FROM TAB1 LEFT OUTER JOIN TAB2 ON TAB1.NO = TAB2.NO; SELECT COUNT(DISTINCT TAB1.CODE) FROM TAB1 RIGHT OUTER JOIN TAB2 ON TAB1.NO = TAB2.NO;,"9, 3","9, 2","7, 3","7, 2","LEFT OUTER JOIN의 결과 TAB1의 NO값이 1, 2, 4, 4, 6, 7, 3인 총 7개의 행이 나오게 되고, RIGHT OUTER JOIN의 결과로 TAB1의 CODE값이 A, B, B, B, NULL, NULL, NULL이 출력되어 DISTINCT 수는 총 2건이다.(NULL은 세지 않는다)",4
415,2과목,JOIN,다음 SQL 구문의 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j646-1.png,"SELECT COUNT(TAB1.COL1) FROM TAB1, TAB2 WHERE TAB1.COL2 = TAB2.COL2(+);",5,4,3,2,"(+) 가 붙은 반대편 테이블이 기준이 되는 테이블로 TAB1 테이블을 기준 테이블로 LEFT OUTER JOIN이 수행된다. 즉, 조인 조건이 일치하지 않아도 TAB1은 생략되서는 안되므로 INNER JOIN의 결과에 TAB1의 COL2가 NULL, C인 경우 추가적으로 출력되므로 총 5건이 나온다.",1
416,2과목,DML,다음 주어진 테이블에 대해서 아래의 SQL문을 실행하였을 때 결과 행의 수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j548-1.png,"SELECT * FROM TEST32 WHERE (COL1,COL2) IN (10000,'ABC'));",3,2,1,,"보기의 SQL문은 COL1, COL2가 각각 10000, 'ABC'인 행만을 조회하는 SQL문으로 1번째 행만 조회된다.",3
417,2과목,집합 연산자,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j741-1.png,"SELECT COUNT(COL1) FROM TAB1 WHERE COL2 NOT BETWEEN 2000 AND 3000 AND COL3 NOT IN (10, 20);",2,1,0,,"2000과 3000사이 값이 아니면 2000미만, 3000초과가 된다. 이들 중 COL3이 10, 20과 일치하지 않는 행은 존재하지 않는다. 따라서 COUNT 결과는 0이다. 조건에 만족하지 않더라도 COUNT는 NULL이 아닌 0을 리턴한다.",3
418,2과목,DCL,다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?,,UPDATE A_User.TB_A SET col1='TEST' WHERE col2=100;,"GRANT SELECT, UPDATE ON A_User, TB_A TO TEST;","REVOKE UPDATE ON A_User, TB_A TO TEST;","REVOKE SELECT ON A_User, TB_A FROM TEST;",GRANT UPDATE TO TEST;,GRANT privileges ON object TO user;,1
419,2과목,집합 연산자,다음 중 SQL에서 실행 결과가 같은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j349-1.png,"(1) SELECT A ID, B.ID FROM MytestA A FULL OUTER JOIN MytestB B ON A.ID = B.ID (2) SELECT A ID, B.ID FROM MytestA A LEFT OUTER JOIN MytestB B ON A.ID = B.ID UNION SELECT A ID, B.ID FROM MytestA A RIGHT OUTER JOIN MytestB B ON A.ID = B.ID (3) SELECT A ID, B.ID FROM MytestA A, MytestB B WHERE A.ID = B.ID UNION ALL SELECT A.ID, NULL FROM MytestA A WHERE NOT EXISTS (SELECT 1 FROM MytestB B WHERE A.ID = B.ID) UNION ALL SELECT NULL, B.ID FROM MytestB B WHERE NOT EXISTS (SELECT 1 FROM MytestA A WHERE B.ID = A.ID)","1,2,3","2,3","1,3","1,2","보기 3개 모두 FULL OUTER JOIN과 동일한 결과를 반환한다. 즉, 교집합과 MytestA 및 MytestB의 차집합 모두가 조회된다.",1
420,2과목,집계 함수,다음 주어진 테이블들에 대해서 아래의 SQL문을 수행하였을 때 결과의 행수로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j510-1.png,"SELECT COUNT(*) ROWCNT FROM test36_1 a,test36_2 b WHERE a.ename LIKE b.condition;",6,4,3,0,,3
421,2과목,계층형 질의,다음과 같은 데이터 상황에서 계층형 질의절을 완성하기 위해 필요한 표현식은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j760-1.png,SELECT * FROM EMP START WITH EMPNO = '0001' CONNECT BY MGR = PRIOR EMPNO;,ORDER SIBLINGS BY,NOCYCLE,SYS_CONNECT_BY_PATH,CONNECT_BY_ROOT,위 데이터는 SMITH와 ALLEN이 서로 순환구조를 가지기 때문에 출력이 불가하다. 따라서 출력을 원할 경우 CONNECT BY 뒤에 NOCYCLE 옵션을 전달해야 한다.,2
422,2과목,DML,다음의 정렬 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j743-1.png,"SELECT ID FROM TAB1 ORDER BY CASE WHEN ID > 'B' THEN 'A' ELSE ID END, ID;",,,,,"문자 B보다 큰 ID는 BI와 BAA이다. 따라서 ID 는 CASE문에 의해 순서대로 AA, ABC, A, B, A 변환되어 두번째 정렬 기준인 ID 값과 함께 정렬된다. 문자 정렬은 왼쪽부터 비교하여 값이 같을 때까지 비교하여 더 큰 값이 큰 문자열이 되므로 최종 정렬 결과는 정렬 결과는 A(BAA), A(BI), AA, ABC, B 가 된다.",2
423,2과목,DML,주어진 SQL문에서 오류가 발생하지 않는 것은?,,"CREATE TABLE TEST20 ( ID NUMBER PRIMARY KEY, AGE NUMBER NOT NULL, NAME VARCHAR2(1) ); (1) insert into test20 values(10,20,sysdate); (2)insert into test20 values(20,null,'a'); (3)insert into test20(age, name) values(20,'a'); (4)insert into test20(id,age,name) values(20,10,null);",4,3,2,1,(1)번은 NAME에 DATE 타입의 데이터를 입력하여 오류가 발생한다. (2)번은 AGE가 NOT NULL인데 null을 입력하여 오류가 발생한다. (3)번은 ID의 기본키 값을 입력하지 않아서 오류가 발생한다.,1
424,2과목,서브쿼리,아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?,,"가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다. 나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다. 다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는 '=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다. 라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다. 마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.","가,나,마","나,다,라","가,나,라","나,라,마","다) 서브쿼리의 결과가 복수 행 결과를 반환하는 경우에는 IN, ALL, ANY 등의 복수 행 비교 연산자와 사용하여야 한다. 마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인 쿼리의 조건과 비교되는 데, SQL Server에서는 현재 지원하지 않는 기능이다.",3
425,2과목,ER 모델링,다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?,,"가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다. 나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다. 다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다. 라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.","가,다","나,라","가,라","가,나",데이터베이스 식별자는 대표성 여부에 따라서 주식별자와 보조 식별자로 구분된다. 주식별자는 후보키 중에서 엔터티를 대표하는 식별자로 다른 엔터티와 참조하여 연결할 수 있는 식별자이다.,3
426,2과목,서브쿼리,다음 서브쿼리 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j700-1.png,"SELECT SUM(SAL) FROM EMPLOYEES WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMPLOYEES GROUP BY DEPTNO);",7500,4500,3000,1500,"다중컬럼 서브쿼리를 사용하여 각 부서별로 최대급여를 받는 직원들의 급여 총합을 출력하고 있다. 10번 부서는 1500, 20번 부서는 3000이지만 FORD와 MILLER 둘 다 출력되므로 총 합은 7500이다.",1
427,2과목,윈도우 함수,"다음의 SQL문을 실행했을 때 아래 결과가 조회되도록 (ㄱ), (ㄴ)에 들어갈 숫자를 고르시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j353-1.png,"SELECT COL1, COL2, COL3, LEAD(COL3, (ㄱ), (ㄴ)) OVER(PARTITION BY COL1 ORDER BY COL3 ) AS Result FROM Mytest","ㄱ : 1, ㄴ : 4","ㄱ : 1, ㄴ : 9","ㄱ : 2, ㄴ : 4","ㄱ : 2, ㄴ : 9","COL3 값에서 두 번째 다음값이 Result 값으로 출력되니 (ㄱ)에는 숫자 2가 와야 하고, 현재 COL3값의 두번째 다음값이 해당 파티션내에서 존재하지 않을 경우에는 기본값으로 9를 출력하니 (ㄴ)에는 숫자 9가 와야한다.",4
428,2과목,JOIN,DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?,,SELECT * FROM DEPT CROSS JOIN DEPT;,16,12,8,4,CROSS JOIN으로 DEPT에 행이 4건이다. 즉 4*4=16행이 조회된다.,1
429,2과목,JOIN,다음 SQL 구문의 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j645-1.png,SELECT COUNT(A.COL2) FROM TAB1 A JOIN TAB2 B ON A.COL2 = B.COL2;,3,2,1,0,"NULL 끼리는 동등비교 조건에 참으로 리턴되지 않는다. TAB1의 COL2값이 A인 경우 TAB2의 1건, B인 경우 2건, C의 경우 조건에 만족하는 값이 없으므로 INNER JOIN에서는 생략된다. 따라서 총 3건이 출력된다.",1
430,2과목,집합 연산자,다음의 SQL문 중에서 결과가 동일한 하나의 SQL문은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j470-1.png,"select * from kpipool where (subkpi, mainkpi) in((20,10),(0,30));","select * from kpipool where (subkpi, mainkpi) in ((20,30),(30,40));","select * from kpipool where (subkpi, mainkpi) in ((10,20),(20,30));","select * from kpipool where subkpi in (20,10);",select * from kpipool where subkpi = 20;,"④번의 SQL문 subkpi가 20번인 행을 조회한다. 그리고 문제에서 제시한 SQL문도 in구로 (20,10)을 사용했으므로 똑같이 subkpi가 20인 행이 조회된다.",4
431,2과목,DML,"학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)",,ㄱ : SELECT DEPT FROM SUDENT; ㄴ : SELECT DISTINCT DEPT FROM STUDENT; ㄷ : SELECT NAME FROM STUDENT WHERE DEPT = '영문학과';,"ㄱ:200, ㄴ:200, ㄷ:50","ㄱ:200, ㄴ:3, ㄷ:50","ㄱ:200, ㄴ:3, ㄷ:1","ㄱ:3, ㄴ:3, ㄷ:1","ㄱ은 STUDENT 테이블을 조건없이 조회하는 것이므로 200=50+100+50이 된다. 그리고 ㄴ은 ""DISTINCT""를 사용했으므로 학과명이 중복되면 한 번만 출력한다. 문제에서는 영문학과, 법학과, 수학과가 있으므로 3이 되고 ㄷ은 WHERE절에 ""영문학과""만 조회하므로 50이 된다.",2
432,2과목,집계 함수,아래 SQL에 대한 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j750-1.png,"SELECT SUM(TAB2.COL2) FROM TAB1, TAB2 WHERE TAB1.COL2 = TAB2.COL1;",900,800,700,600,"A는 100, 200을 B는 300, C는 300을 리턴한다. 따라서 총 합은 900 이다.",1
433,2과목,집계 함수,다음 SQL 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j591-1.png,SELECT COUNT(CODE) FROM TAB1 WHERE CODE LIKE '_1%' OR CODE LIKE '%A%';,8,7,5,4,"_1%' 조건은 두 번째 값이 1 인 문자열을 나타내므로 A1C1, B1A0, C1A1, D1B2 총 4 개이고, '%A%' 조건은 A 를 포함하는 문자열이므로 A1C1, A2C2, B1A0, C1A1 총 4 개이다. OR 조건은 두 집합의 합집합(중복값은 한 번만)이므로 총 8 개에서 두 조건을 모두 만족하는 A1C1, B1A0, C1A1 을 제외하면 총 5 개이다.",3
434,2과목,,다음 주어진 테이블에서 아래의 SQL문을 수행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j539-1.png,SELECT SUM(COL1+COL2+COL3+COL4) FROM test23; SELECT SUM(COL1) + SUM(COL2) + SUM(COL3) + SUM(COL4) FROM tset23;,"Null, Null","50, 240","Null, 240","50, Null","첫 번째 SQL문의 첫 번째 행인(10,10,10,20)은 NULL 값이 없으므로 합계 50이 조회된다. 그리고 두 번째 SQL문에서는 240의 합계가 조회된다. 즉, SUM 집계함수에서 NULL은 자동으로 제외한다.",2
435,2과목,DML,아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?,,"insert into a1 values(1,4); insert into a1 values(2,5); insert into a1 values(3,6); insert into a1 values(4,7); insert into a2 values(1,4); insert into a2 values(2,5); insert into a2 values(null,6); insert into a2 values(null,7); (1)select * from a1,a2 where a1.col1=a2.col1; (2)select * from a1 left outer join a2 on a1.col1=a2.col1; (3)select * from a1 right outer join a2 on a1.col1=a2.col1; (4)select * from a1 full outer join a2 on a1.col1=a2.col1;","(4), (1)","(3), (4)","(2), (3)","(1), (2)","FULL Outer Join은 총 6개의 행이 조회되고, LEFT와 RIGHT Outer Join은 총 4개의 행이 조회된다. 그리고 보기 1번의 Inner 조인은 2개의 행이 조회된다.",1
436,2과목,ER 모델링,속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?,,(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다. 다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.,일반속성 - 기본키 속성 - 외래키 속성,파생속성 - 외래키 속성 - 기본키 속성,외래키속성 - 기본키 속성 - 파생 속성,기본키 속성 - 외래키 속성 - 일반 속성,기본키는 엔터티를 대표하는 키로 최소성과 유일성을 만족해야 한다. 외래키는 두 개의 테이블 간에 연결을 설정하기 위한 키이다.,4
437,2과목,윈도우 함수,주어진 테이블에 대해서 아래와 같이 결과가 반환되도록 주어진 SQL문의 빈칸을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j517-1.png,"SELECT ( ) OVER(ORDER BY sal desc) as rank, name, deptname, position, sal FROM test44;",NTILE(),ROW_NUMBER(),DENSE_RANK(),RANK(),위의 결괏값에 동일한 RANK가 없으므로 ROW_NUMBER()가 되어야 한다.,2
438,2과목,집계 함수,다음 수행 결과를 차례대로 나열한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j799-1.png,"SELECT COUNT(*) C1, COUNT(COL1) C2, SUM(COL2) C3 , SUM(COL1+COL2+COL3) C4 FROM TAB1;","3, 2, NULL, NULL","3, 2, 2, NULL","3, 2, 2, 0","0, 2, 2, 0",COUNT(*)는 모든 컬럼의 값이 NULL일 때만 제외한다. COL1+COL2+COL3은 각 행마다 NULL을 포함하므로 모든 행이 값이 NULL이 된다.,2
439,2과목,DML,다음의 Mytest 테이블에 데이터를 입력 시 에러가 발생하는 것은?,,"Create table Mytest ( A number(10) primary key, B number(10), C date, D varchar2(10) );","INSERT into Mytest values(4,32,20220420,'004')","INSERT into Mytest values(3,200,sysdate-10,'004')","INSERT into Mytest values(2,1111,to_date('20230101','YYYYMMDD'),'003')","INSERT into Mytest values(1,12,sysdate,002)",①의 경우 20220420이라는 숫자형 값을 바로 DATE에 넣어 데이터타입 불일치 에러가 발생한다. TO_DATE(20220420)으로 바꾸어야 한다.,1
440,2과목,JOIN,다음의 SQL문을 ANSI 표준 SQL문으로 올바르게 변환한 것은?,,"SELECT * FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO AND B.DNAME = 'SALES';",SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B ON A.DEPTNO = B.DEPTNO WHERE 1=1 AND B.DNAME = 'SALES';,SELECT * FROM SCOTT.EMP A CROSS JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'SALES');,SELECT * FROM SCOTT.EMP A RIGHT OUTER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'SALES');,SELECT * FROM SCOTT.EMP A LEFT OUTER JOIN SCOTT.DEPT B ON(A.DEPTNO = B.DEPTNO AND B.DNAME 'SALES');,OUTER JOIN 혹은 CROSS JOIN이 아닌 INNER JOIN이므로 ①번이 된다.,1
441,2과목,단일행 함수,다음 SQL문의 결과로 출력되는 데이터는 무엇인가?,,"SELECT NEXT_DAY (ADD_MONTHS(sysdate,6),'월요일) FROM dual;",오늘 날짜로부터 6일 후 두 번째 월요일을 출력한다.,오늘 날짜로부터 6개월 후 첫 번째 월요일을 출력한다.,오늘 날짜로부터 6개월 후 두 번째 월요일을 출력한다.,오늘 날짜로부터 6일 후 첫 번째 월요일을 출력한다.,"ADD_MONTHS 함수는 6개월을 더하고 NEXT_DAY 함수는 지정된 요일의 첫 번째 날짜를 출력한다. 즉, 문제에서는 6개월 후 첫 번째 월요일을 출력한다.",2
442,2과목,윈도우 함수,다음 중 아래의 SQL에 대한 설명으로 가장 적절한 것은?,,"[SQL] SELECT 상품분류코드 ,AVG(상품가격) AS 상품가격 ,COUNT(*) OVER(ORDER BY AVG(상품가격) RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS 유사개수 FROM 상품 GROUP BY 상품분류코드;",유사개수 컬럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품의 개수를 구한 것이다.,유사개수 컬럼은 상품분류코드별 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품분류코드의 개수를 구한 것이다.,WINDOW FUNCTION의 ORDER BY절에 AVG 집계 함수를 사용하였으므로 위의 SQL은 오류가 발생한다.,WINDOW FUNCTION을 GROUP BY 절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다.,"GROUP BY 절의 집합을 원본으로 하는 데이터를 WINDOW FUNCTION과 함께 사용한다면 GROUP BY 절과 함께 WINDOW FUNCTION을 사용한다고 하더라도 오류가 발생하지 않으며, 유사개수 컬럼 은 상품분류코드로 GROUPING된 집합을 원본집합으로 하여 상품분류코드별 평균상품가격을 서로 비교하여 현재 읽혀진 상품분류코드의 평균가격 대비 -10000 ~ +10000사이에 존재하는 상품분류코 드의 개수를 구한 것이다.",2
443,2과목,JOIN,아래 결괏값은 주어진 2개 테이블을 특정 JOIN하여 나타난 결과이다. 어떤 조인인지 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j477-1.png,SELECT * FROM SQLD27 ( ) SQLD27_2 ON SQLD27.COL1 = SQLD27_2.COL1;,INNER JOIN,FULL OUTER JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,주어진 두 개의 테이블에서는 같은 COL1 값을 갖는 튜플을 조회하고 우측 테이블에만 있는 값들이 추가로 조회되므로 RIGHT OUTER JOIN이다.,3
444,2과목,윈도우 함수,다음 SQL 구문 결과와 같은 결과를 갖는 SQL은?,,"SELECT COUNT(DECODE(DEPTNO,10,1)) AS ""10"", COUNT(DECODE(DEPTNO,20,1)) AS ""20"", COUNT(DECODE(DEPTNO,30,1)) AS ""30"" FROM EMP;"," SELECT * FROM EMP UNPIVOT (COUNT(*) FOR DEPTNO IN (10,20,30));","SELECT * FROM EMP UNPIVOT (COUNT(DEPTNO) FOR DEPTNO IN (10,20,30));","SELECT * FROM (SELECT EMPNO, JOB, DEPTNO FROM EMP) PIVOT (COUNT(DEPTNO) FOR EMPNO IN (10,20,30));","SELECT * FROM (SELECT EMPNO, DEPTNO FROM EMP) PIVOT (COUNT(EMPNO) FOR DEPTNO IN (10,20,30));","10, 20, 30번 부서원의 수를 각 컬럼별로 표현한 것은 LONG -> WIDE로의 변환을 수행하는 PIVOT의 결과로 대체할 수 있다. PIVOT 절에서 IN 앞의 컬럼은 서로 다른 컬럼으로 분해할 대상이 명시되어야 하므로 DEPTNO가 들어가야 한다.",4
445,2과목,JOIN,다음 보기의 SQL을 실행하면 총 12개의 행이 조회된다. ( )에 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j303-1.png,SELECT * FROM MytestA ( ) MytestB;,RIGHT OUTER JOIN,CROSS JOIN,LEFT OUTER JOIN,INNER JOIN,"CROSS JOIN은 MytestA 테이블이 4행, MytestB 테이블이 3행이므로 4*3=12가 된다.",2
446,2과목,DML,아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?,,"SELECT DEPTNO, COUNT(EMPNO) FROM SCOTT.EMP WHERE SAL >= 400 GROUP BY DEPTNO HAVING COUNT(EMPNO) >= 3 ORDER BY DEPTNO;",FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY,FROM -> WHERE -> GROUP BY -> SELECT -> HAVING -> ORDER BY,FROM -> WHERE -> HAVING -> GROUP BY -> ORDER BY -> SELECT,FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> SELECT,FROM 절에서 테이블 목록을 가져오고 WHERE 절에서 검색 조건에 불일치하는 행을 제외한 후 GROUP BY 절에서 명시된 행의 값을 그룹화한다. HAVING 절은 GROUP BY 절로 정렬이 된 데이터를 대상으로 조건을 정의한 후 SELECT 절에서 조회 후 ORDER BY 절에서 명시한 칼럼값을 기준으로 정렬하여 출력한다.,1
447,2과목,,다음 SQL문의 실행 결과는?,,"SELECT COALESCE(nullif(1,1),200,300) as data from dual;",400,300,200,100,"nullif(1,1)에서 NULL을 반환하고 COALESCE(NULL,200,300)에서 200을 반환한다.",3
448,2과목,그룹 함수,다음 중 주어진 테이블에서 SQL문의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j461-1.png,SELECT ID FROM test29 GROUP BY ID HAVING COUNT(*) = 2 ORDER BY (CASE WHEN ID = 1000 THEN 0 ELSE ID END);,,,,,"CASE문으로 ID가 1000인 것은 0 으로 변경하고 나머지는 ID값으로 ASC(오름차순) 한다. 단, COUNT 함수로 2건만 조회된다. 따라서 3000, 9999의 값이 2건이라서 3000, 9999만 조회된다.",4
449,2과목,JOIN,다음의 SQL문과 동일한 결괏값을 보여주는 SQL문은?,,SELECT * FROM Mytesta a full outer join Mytestb b on a.col1 = b.col1;,SELECT * FROM Mytesta a left outer join Mytestb b on a.col1 = b.col1 union SELECT * FROM Mytesta a right outer join Mytestb b on a.col1 = b.col1;,SELECT * FROM Mytesta a cross join Mytestb b on a.col1 = b.col1,SELECT * FROM Mytesta a left outer join Mytestb b on a.col1 = b.col1 union all SELECT * FROM Mytesta a left outer join Mytestb b on a.col1 = b.col1;,SELECT * FROM Mytesta group by col1;,위의 SQL문에서 FULL OUTER JOIN의 결과값은 'LEFT OUTER JOIN' 결과와 'RIGHT OUTER JOIN'결과를 UNION 연산하는 결괏값과 동일하다.,1
450,2과목,식별자,다음이 설명하는 식별자로 가장 적절한 것은?,,다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자,내부식별자,본질식별자,인조식별자,보조식별자,다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자는 내부식별자이다.,1
451,2과목,단일행 함수,다음 SQL의 실행 결과는?,,"SELECT ROUND(10.51234, 1) FROM DUAL;",11,10.51,10.5,10,"ROUND(숫자, 반올림 소수 자리)는 반올림하는 함수이다.",3
452,2과목,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j593-1.png,SELECT SUM(COL2) + SUM(COL3) FROM TAB1; SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 > 0; SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 IS NOT NULL; SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 IS NULL;,"1000, NULL, 400, 600","1000, 100, 400, 600","500, NULL, 400, 600","500, 100, 400, 600","SUM(COL2)는 NULL 만 제외하고 총합을 리턴하므로 500 이 출력된다. 하지만 2 번 지문의 경우 COL1 > 0 조건에 만족하는 행은 첫 번째 행 하나이므로 SUM(COL2) + SUM(COL3) = NULL + 100 이 되며, 이때는 NULL 이 리턴된다.",1
453,2과목,서브쿼리,"아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?",,"[테이블] 사원 (사번, 이름, 나이) 가족 (이름, 나이, 부양사번) * 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다. [SQL 문장] SELECT 이름 FROM 사원 WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))",(ㄱ) : NOT EXISTS (ㄴ) : 사번 <> 부양사번,(ㄱ) : NOT EXISTS (ㄴ) : 사번 = 부양사번,(ㄱ) : EXISTS (ㄴ) : 사번 <> 부양사번,(ㄱ) : EXISTS (ㄴ) : 사번 = 부양사번,"'현재 부양하는 가족들이 없는 사원들의 이름을 구하라'를 구현하는 방법은 가족 테이블에 부양사번이 없는 사원 이름을 사원 테이블에서 추출 하면 되고, SQL 문장으로 NOT EXISTS, NOT IN , LEFT OUTER JOIN을 사용하여 구현 할 수 있다. 1. NOT EXISTS SELECT 이름 FROM 사원 WHERE NOT EXISTS (SELECT * FROM 가족 WHERE 사번 = 부양사번) 2. NOT IN SELECT 이름 FROM 사원 WHERE 사번 NOT IN (SELECT 부양사번 FROM 가족) 3.LEFT OUTER JOIN SELECT 이름 FROM 사원 LEFT OUTER JOIN 가족 ON (사번 = 부양사번) WHERE 부양사번 IS NULL",2
454,2과목,DDL,다음에서 설명하는 DDL문으로 올바른 것은?,,Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.,ALTER table Mytest add constraint column 칼럼명 default not null,ALTER table Mytest modify (칼럼명 not null),ALTER table Mytest add column 칼럼명 default not null,ALTER table Mytest alter column 칼럼명 not null,"테이블에 존재하는 칼럼의 데이터 유형, 디폴트 값, not null에 대한 제약조건을 변경하는 명령어는 ALTER 문의 modify이다.",2
455,2과목,계층형 질의,Mytest 테이블에 대해서 SQL문을 실행햇을 때 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j352-1.png,SELECT * FROM Mytest START WITH MGRID IS NULL CONNECT BY PRIOR EMPID = MGRID AND today BETWEEN '2017-01-01' AND '2022-12-31' ORDER SIBLINGS BY EMPID;,,,,,MGRID가 NULL인 값에서 시작해서 EMPID로 조회를 전개하는 순방향 조회를 하고 있다. 순방향 전개를 하면서 EMPID로 정렬한다.,4
456,2과목,그룹 함수,아래 SQL에서 출력되는 ROWS의 개수를 구하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j401-1.png,"SELECT DNAME, JOB, COUNT(*) ""Total EMP"", SUM(SAL) ""Total Sal"" FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY CUBE(DNAME,JOB);",20건,18건,14건,10건,"두 개의 테이블을 조인하면 14개의 행이 나오게 된다. 이를 CUBE로 집계를 하면 전체합계 1건, JOB별 집계 5건, DEPTNO별 집계 3건, DEPTNO에서의 JOB별 집계가 3건씩 9건으로 총 18건이 출력된다.",2
457,2과목,그룹 함수,다음의 SQL문 실행 결과로 조회되는 행의 개수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j432-1.png,"SELECT COUNT(*) FROM( SELECT COUNT(*) FROM Mytest GROUP BY ROLLUP(DATA1), DATA2);",8,6,4,3,총 행 수는 8개 조회된다.,1
458,2과목,집계 함수,다음 sutdent 테이블을 이용하여 아래의 SQL을 수행하였을 때 실행 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j234-1.png,SELECT count(*) FROM student GROUP BY department HAVING count(*) > 2;,3,2,1,0,"SELECT문을 보면 department로 GROUP BY한다. 그러면 총 3개의 그룹이 만들어진다. computer, physics, math이다. 3개의 그룹 중에서 개수가 2개 초과인 것을 조회하기 위해서 ""HAVING count(*) >2"" 문을 사용했다. 따라서 2개 초과인 것은 math이고 math는 총 3개가 있으므로 3이 된다.",1
459,2과목,집계 함수,다음 출력 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j748-1.png,"SELECT COL1, COL2, (SELECT COL2 FROM TAB2 WHERE TAB1.COL2 = TAB2.COL1) AS RESULT1, (SELECT MAX(COL2) FROM TAB3 WHERE TAB1.COL1 = TAB3.COL1) AS RESULT2 FROM TAB1;",,,,,"RESULT1은 TAB2의 COL1의 값이 TAB2의 COL1과 같은 행의 COL2값을 리턴한다. 하지만 TAB1의 COL2가 NULL 인 경우 조건에 일치하지 않아도 생략되지 않고 NULL로 출력되는데, 이는 메인쿼리의 WHERE절이 정의되지 않아 전체 행이 출력되기 때문이다. 마찬가지로 RESULT2도 TAB1의 COL1이 D인 경우 TAB1.COL1 = TAB3.COL1 조건에 일치하지 않지만 NULL로 출력된다.",2
460,2과목,집합 연산자,다음 SQL의 실행 결과는?,,SELECT 1 FROM DUAL UNION SELECT 2 FROM DUAL UNION SELECT 1 FROM DUAL;,"1,2,1","2,1","1,2",1,,3
461,,,다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은?,,"가. 데이터베이스 모델링 시에 정규화를 수행한다. 나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다. 다. 트랜잭션의 유형을 분석한다. 라. 데이터베이스 전체 용량을 산정해야 한다. 마. 성능관점에서 데이터 모델을 검증하고 확인한다. 바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.","가,마","다,라","다,마","가,나","성능을 고려한 데이터베이스 모델링 시에도 가장 먼저 정규화를 수행해서 데이터 모델의 독립성을 향상시켜야 한다. 그리고 필요에 따라서 트랜잭션 유형, 반정규화 등을 수행하고 제일 마지막에는 성능관점에서 데이터 모델을 검증해야 한다.",1
462,,,다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?,,"가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다. 나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다. 다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다. 라. 자주 수정되는 속성을 주식별자로 지정한다.","나, 라","다, 라","가, 다","가, 나",,3
463,,,다음 주어진 테이블에 대해서 아래의 SQL문의 실행 결과로 가장 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j459-1.png,"SELECT ID, AGE FROM test20 ORDER BY (CASE WHEN ID = 10 OR ID=13 THEN 1 ELSE 2 END), AGE DESC",,,,,"CASE 문을 사용해서 정렬의 순서를 변경했고 그래서 ID가 13, 10번이 가장 먼저 조회된다. 즉, 10과 13번이 먼저 조회되고 AGE로 DESC이므로 13의 AGE가 50이라서 가장먼저 조회된다.",4
464,,,다음과 같은 SQL 문장이 있다. 예제의 ORDER BY 절과 같은 결과를 갖는 구문은 어떤 것인가?,,"SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버 FROM PLAYER ORDER BY PLAYER_NAME, POSITION, BACK_NO DESC;","ORDER BY 1 DESC, 2, 백넘버","ORDER BY PLAYER_NAME ASC, 2, 3","ORDER BY 선수명, 2, DESC 백넘버","ORDER BY 선수명 ASC, 포지션, 3 DESC",ORDER BY절에서 정렬 기준이 생략되면 fault로 ASC 정렬이 된다. ORDER BY절에는 칼럼명 대신에 SELECT절에 기술한 칼럼의 순서번호나 칼럼의 ALIAS명을 사용할 수 있다.,4
465,,,다음의 SQL문에 대한 설명 중 옳지 않은 것은?,,SELECT * FROM EMP WHERE EMPNO LIKE '100%';,기능상으로는 문제가 없지만 성능 문제가 있다.,EMP 테이블을 FULL SCAN한 것은 인덱스가 없어서이다.,"LIKE 조건을 사용하지 말고 "">""를 사용해야 한다.",내부적으로 형변환이 발생했다.,EMPNO는 기본키이므로 자동으로 인덱스가 생성된다. FULL SCAN이 된 것은 LIKE 조건에서 숫자 칼럼과 문자값 간에 형 변환이 발생해서이다.,2
466,,,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,,"SELECT JOB, ENAME, SAL, RANK() OVER(ORDER BY SAL DESC) ALL_RANK, RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK FROM EMP;",PARTITION문을 사용해서 해당 파티션 내에서 순위를 계산한다.,"RANK() 함수를 사용했으므로 급여가 동일한 사람이 있다면, 조회 순서에 따라서 1등과 2등으로 표시된다.",JOB별로 SAL이 큰 등수가 조회된다.,SAL칼럼은 급여가 큰 순으로 조회된다.,RANK()함수를 사용할 경우 급여가 동일한 사람이 있을 때 같은 등수로 조회된다.,2
467,,,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?,,"SELECT DEPTNO, SUM(SAL) AS SUM_SAL FROM EMP GROUP BY DEPTNO UNION ALL SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL FROM EMP; SELECT DEPTNO, SUM(SAL) AS SUM_SAL FROM EMP GROUP BY _______________;","ROLLUP(DEPTNO, ())","ROLLUP(DEPTNO, SAL)",ROLLUP(SAL),ROLLUP(DEPTNO),"ROLLUP은 전체 소계를 함께 출력한다. 즉, ROLLUP(A) => GROUP BY A 결과에 전체 소계 출력",4
468,,,다음 출력 결과로 가장 알맞은 것은?,,"SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 FROM DUAL;","8,3","8,1","2,3","2,1","둘 다 숫자(\d)가 2회 이상 나열된 단어의 수를 찾는 문제이므로 C1은 2, C2는 3개가 리턴된다.",3
469,,,다음 SQL문에 대한 설명으로 올바른 것은?,,SELECT * FROM SQLD_33 WHERE EMP_NAME LIKE 'A%',테이블의 EMP_NAME이 A 또는 a로 끝나는 모든 ROW,테이블의 EMP_NAME이 A로 끝나는 모든 ROW,테이블의 EMP_NAME이 A로 시작하는 모든 ROW,테이블의 EMP_NAME이 A 또는 a로 시작하는 모든 ROW,특정 문자로 시작하는 것을 조회하기 위해서는 like문을 사용해야 한다. 그리고 'A%'는 A로 시작하는 것을 조회한다.,3
470,,,다음 WINDOW FUNCTION이 포함된 SQL문의 실행 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j334-1.png,"SELECT MGR, ENAME, SAL, SUM(SAL) OVER (PARTITION BY MGR ORDER BY HIREDATE ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS MGR_SUM FROM Mytest;","4500, 7500, 7500, 3000, 4500, 4500, 5000, 8500, 8500","4500, 7500, 5500, 3000, 4500, 2500, 5000, 8500, 5500","2000, 4500, 7500, 2000, 3000, 4500, 3000, 5000, 8500","2000, 2500, 3000, 2000, 1000, 1500, 3000, 2000, 3500",위의 Mytest 테이블에서 MGR 속성별로 파티션을 분할했을 때 각각의 파티션 내에서 HIREDATE 속성값 기준으로 오름차순 정렬하고 그때 같은 파티션 내에서 현재 행을 기준으로 바로 이전 행부터 바로 다음 행까지의 급여의 합계를 계산하여 MGR_SUM 속성값으로 조회한다.,2
471,,,아래의 상품 마스터 테이블에 대한 상품ID '001'의 최종 상품명은 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j559-1.png,BEGIN TRANSACTION; SAVE TRANSACTION SP1; UPDATE 상품마스터 SET 상품명 = 'LG-TV' WHERE 상품ID ='001'; SAVE TRANSACTION SP2; UPDATE 상품마스터 SET 상품명 = '평면-TV' WHERE 상품ID = '001'; ROLLBACK TRANSACTION SP2; COMMIT;,없음,TV,평면-TV,LG-TV,"ROLLBACK TRANSACTION SP2 문장에 의해 UPDATE 상품 SET 상품명 = '평면-TV' WHERE 상품ID = '001'이 ROLLBACK 되었고, 첫 번째 UPDATE 문장만 유효한 상태에서 COMMIT 되었으므로 첫 번째 UPDATE한 내역만 반영된다. 그러므로 LG-TV가 된다.",4
472,,,아래와 같은 테이블이 있다. 다음 SQL 실행 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j602-1.png,"SELECT COUNT(DEPTNO) FROM EMPLOYEES WHERE DEPTNO <= ALL(SELECT DEPTNO FROM EMPLOYEES WHERE HIREDATE >= TO_DATE('2020/02', 'YYYY/MM'));",5,4,3,2,"서브쿼리 결과가 먼저 실행되어 2020년 2월 1일보다 입사일이 큰 행의 DEPTNO(30, 40, 50)가 출력되고 ALL이 작다와 결합되어 이들 중 30보다 작거나 같은 조건으로 전달된다. 따라서 DEPTNO가 10, 20, 30인 EMPNO의 수는 총 3개이다.",3
473,,,다음 SQL 구문의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j597-1.png,SELECT SAL FROM TAB1 ORDER BY TO_CHAR(SAL);,2500 1300 800 300,300 1300 800 2500,300 800 1300 2500,1300 2500 300 800,"TO_CHAR에 의해 SAL 값이 문자로 변환되며, 문자 값의 대소 비교는 값의 왼쪽부터 비교하므로 왼쪽 값이 가장 작은 값의 크기가 제일 작다. 따라서 1300 < 2500 < 300 < 800 순이 되며, 오름차순 정렬은 1300, 2500, 300, 800 순서로 배치된다.",4
474,,,"사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)",,"Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH GRANT OPTION; kim :GRANT SELECT, INSERT, DELETE ON R TO Park; Lee: REVOKE DELETE ON R FROM Kim; Lee:REVOKE INSERT ON R FROM Kim CASCADE;","Kim : INSERT INTO R VALUES(500, 600);",Park : DELETE FROM R WHERE B = 800;,"Park : INSERT INTO R VALUES(400, 600);",Park : SELECT * FROM R WHERE A = 400;,"1. Lee : GRANT SELECT, INSERT, DELETE ON R TO Kim WITH GRANT OPTION; -> Kim에게 테이블 R에 SELECT, INSERT, DELETE 권한을 주면서, Kim 이 다른 유저에게 테이블 R에 동일한 권한을 줄 수 있다. 2. Kim : GRANT SELECT, INSERT, DELETE ON R TO Park; -> Kim이 테이블 R에 Lee에게 받은 권한을 Park에게 준다. 3.Lee : REVOKE DELETE ON R FROM Kim; -> Kim에서 테이블 R의 DELETE 권한을 취소한다. 4. Lee : REVOKE INSERT ON R FROM Kim CASCADE; -> Kim과 Park에서 INSERT 권한을 취소한다. WITH GRANT OPTION으로 Kim으로부터 받은 Park의 권한은 CASCADE 명령어로 받은 권한을 취소 할 수 있다.","2,4"
475,,,다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?,,INSERT INTO Mytest VALUES(1); INSERT INTO Mytest VALUES(2); SAVEPOINT SV1; UPDATE Mytest SET CO1=8 WHERE COL1=2; INSERT INTO Mytest VALUES(9); SAVEPOINT SV2; DELETE Mytest WHERE COL1=8; INSERT INTO Mytest VALUES(11); SAVEPOINT SV3; INSERT INTO Mytest VALUES(9); ROLLBACK TO SV2; COMMIT;,"1,8,9","1,8,11,8","1,8,11","1,2",위의 SQL문의 맨 하단의 ROLLBACK TO SV2 명령어를 수행하면 SAVEPOINT SV2 지점까지 변경된 것을 모두 취소한다.,1
476,,,다음의 SQL문이 순서대로 수행되고 난 후 결과값으로 알맞은 것은?,,Create table test20 (col1 number(10)); INSERT INTO test20 VALUES(1); INSERT INTO test20 VALUES(4); SAVEPOINT SV1; UPDATE test20 SET COL1=8 WHERE COL1=2; SAVEPOINT SV1; DELETE test20 WHERE COL1 > =2; ROLLBACK TO SV1; INSERT INTO test20 VALUES(3); SELECT MAX(COL1) FROM test20;,,,,,SAVEPOINT가 동일할 때 ROLLBACK을 수행하면 가장 마지막 시점의 SAVEPOINT 지점으로 ROLLBACK 된다.,2
477,,,"TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?",,SELECT * FROM test24 minus SELECT 1 FROM DUAL;,1,"1,2","2,3","1,2,3","MINUS는 Oracle에서 차집합을 구하는 것이다. 즉 위의 SQL에서 1을 제외하게 되므로 2,3이 된다.",3
478,,,아래의 테이블들에 대해서 SQL문을 수행하였을 때의 결과 값은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j545-1.png,SELECT COUNT(*) FROM TEST29_1 A WHERE A.COL NOT IN(SELECT COL FROM TEST29_2);,6,3,1,0,NOT IN 안에 NULL이 들어가면 아무것도 출력되지 않는다. 이 때 COUNT는 0을 출력하게 된다.,4
479,,,다음 중 서브쿼리를 올바르게 구분한 것은?,,SELECT (A) FROM (B) a WHERE a.col = (C),A : 인라인 뷰 B : 스칼라 서브쿼리 C : 서브쿼리,A : 스칼라 서브쿼리 B : 인라인 뷰 C : 서브쿼리,A : 서브쿼리 B : 스칼라 서브쿼리 C : 인라인 뷰,A : 스칼라 서브쿼리 B : 서브쿼리 C : 인라인 뷰,"큰 의미에서는 모두 서브쿼리이다. SELECT구에 사용하면 스칼라 서브쿼리, FROM구에 사용하면 인라인 뷰, WHERE구에 사용하면 서브쿼리로 구분한다.",2
480,,,주어진 테이블에 대해서 아래의 SQL문을 수행한 결과로 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j491-1.png,select count(*) from TEST11 where COL3 <> 3 start with COL3 = 4 connect by COL1 = prior COL2;,3,2,1,0,,1
481,,,데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?,,( ) CREATE TABLE TO AAA,COMMIT,INSERT,REVOKE,GRANT,GRANT는 권한을 부여하는 SQL문이다. 반대로 권한을 취소하는 것은 REVOKE이다.,4
482,,,다음 SQL문의 실행 결과로 올바른 것은?,,Create table Mytest(COL1 number(10)); INSERT INTO Mytest VALUES(2); INSERT INTO Mytest VALUES(2); SAVEPOINT SV1; UPDATE Mytest SET COL1=7 WHERE COL1=2; INSERT INTO Mytest VALUES(9); SAVEPOINT SV2; DELETE Mytest WHERE CO1=7; INSERT INTO Mytest VALUES(11); SAVEPOINT SV3; INSERT INTO Mytest VALUES(20); ROLLBACK TO SV2; COMMIT; SELECT * FROM mytest;,"7,7,9","7,9,11,9","7,9,11","1,2","위의 SQL문 면 하단에서 ROLLBACK TO SV2 명령어를 수행하면, SAVEPOINT SV2 지점까지 변경된 것을 모두 취소한다.",1
483,,,관계에 대한 설명으로 가장 적절하지 않은 것은?,,회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다.,개인회원 또는 법인회원 둘 중 하나로 주문 가능할 경우 고객과 주문 엔터티는 상호포함적 관계이다.,고객과 주문내역 엔터티 간의 '주문' 관계는 행위에 의한 관계이다.,부서와 사원 엔터티 간의 '소속' 관계는 존재적 관계이다,관계는 존재적 관계와 행위에 의한 관계로 나누어 볼 수 있다.,개인 회원 또는 법인 회원 중 하나만 주문이 가능한 경우 두 엔터티의 관계는 상호배타적 관계이다.,1
484,,,다음은 ERD 작성 순서이다. 올바른 것을 고르시오.,,가)엔터티를 그린다. 나)엔터티를 적절하게 배치한다. 다)엔터티 간에 관계를 설정한다. 라)관계명을 기술한다. 마)관계의 참여도를 기술한다. 바)관계의 필수 여부를 기술한다.,가->나->다->마->바->라,가->나->라->다->마->바,가->나->다->라->마->바,나->가->다->라->마->바,1)엔터티를 그린다. 2)엔터티를 적절하게 배치한다. 3)엔터티 간의 관계를 설정한다. 4)관계명을 기술한다. 5)관계의 참여도를 기술한다. 6)관계의 필수 여부를 기술한다.,3
485,,,다음의 SQL문을 실행했을 때 결과는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j380-1.png,SELECT * FROM MytestA a left outer join MytestB b on a.col1 = b.col1;,,,,,①번 보기는 INNER JOIN ②번 보기는 FULL OUTER JOIN ③번 보기는 RIGHT OUTER JOIN ④번 보기는 LEFT OUTER JOIN이다.,4
486,,,SELECT문의 처리 순서로 올바른 것은?,,"SELECT deptno,sum(sal) FROM dept WHERE deptno > 10 GROUP BY deptno ORDER BY deptno;","ORDER BY, SELECT, WHERE, GROUP BY, FROM","SELECT, FROM, WHERE, GROUP BY, ORDER BY","FROM, WHERE, GROUP BY, SELECT, ORDER BY","WHERE, GROUP BY, ORDER BY, FROM, SELECT",,3
487,,,다음 SQL의 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j636-1.png,"SELECT TO_CHAR(TO_DATE(SUBSTR(JUMIN, 1, 6), 'RRMMDD'), 'YYYY-MM-DD') FROM TAB1;",2075-10-23 0:00:00,1975-10-23 0:00:00,2075-10-23,1975-10-23,"주민번호의 앞 6자리를 사용하여 날짜변환 시 RR 포맷을 사용하면 두 자리 연도가 1~49 사이면 2000년대를, 50~99이면 1900년도의 4자리 연도로 출력, YY를 사용하면 2000년대를 출력한다.",4
488,,,다음 주어진 테이블에 대해서 아래와 같은 결과값이 나오도록 SQL문의 빈칸에 들어갈 수 있는 내용을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j531-1.png,"SELECT DEPTNO, JOB, SUM(SAL) FROM T_TEST GROUP BY ( );","CUBE(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","GROUPING SETS(DEPTNO, JOB)","DEPTNO, JOB","집계결과는 DEPTNO별 합계, JOB별 합계, DEPTNO 및 JOB별 합계, 전체합계가 조회되고 Rollup이 와야 한다.",2
489,,,다음 주어진 테이블에서 아래의 SQL문을 수행하였을 때의 결과가 RESULT와 같을 때 SQL문의 빈칸으로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j375-1.png,"SELECT DNMAE,JOB,SUM(SAL) FROM Mytest GROUP BY ( )",CUBE(JOB),GROUPING SETS(JOB),"ROLLUP(DNAME,JOB)","CUBE(DNAME,JOB)","결괏값을 보면 1.DNAME, JOB별 소계 2.DNAME별 소계 3.JOB별 소계 4.전체 집계 등 모든 조합 가능한 소계와 집계가 조회되었으므로 빈칸에 들어갈 그룹 함수는 CUBE이다.",4
490,,,다음의 SQL문을 실행한 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j377-1.png,SELECT COUNT(C1) FROM Mytest,4,3,2,1,COUNT(C1)은 NULL 값은 제외된다. 따라서 3개가 된다.,2
491,,,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j609-1.png,"SELECT DNAME, FIRST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE1, LAST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE2 FROM TAB1;",,,,,"FIRST_VALUE, LAST_VALUE는 ORDER BY 컬럼 순서대로 범위 내 가장 처음 값과 마지막 값을 리턴하는 함수인데, 이때 기본 범위는 RANGE UNBOUNDED PRECEDING AND CURRENT ROW이다. 따라서 같은 DNAME 내 SAL 순서대로 가장 앞에 있는 이름은 아시아지부의 경우 홍길동, 남유럽지부의 경우 김길동이 된다. 하지만 각 행마다 LAST_VALUE를 구할 때 범위가 처음부터 현재 행까지만 고려해서 마지막 값을 리턴하기 때문에 항상 현재 행의 값이 마지막 값이 되므로 각 행의 값이 리턴된다.",1
492,,,다음 주어진 테이블에 대해서 아래의 SQL문을 실행하였을 때의 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j498-1.png,"SELECT C1, C2, CASE WHEN C2 <= 100 THEN 'B' WHEN C2 <= 300 THEN 'A' ELSE 'S' END GRADE FROM test19 ORDER BY C2;",,,,,"C2 값으로 오름차순 정렬하고 CASE문으로 B,A,S 등급을 부여한다. 전체등급이 300점을 넘는 등급이 없기 때문에 S등급은 없고 C1의 6번만 A등급을 받는다.",4
493,,,다음 SQL의 실행 결과를 얻기 위한 빈칸에 들어갈 값으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j711-1.png,"SELECT * FROM TAB1 UNPIVOT (_____ FOR _____ IN (""2023"", ""2024""));","판매량, 판매량","성별, 판매량","성별, 연도","판매량, 연도","첫 번째 밑줄은 10, 20, 30, 40 값이 쌓여 하나의 컬럼을 이룰 때 컬럼명을 나타내는 자리이므로 판매량, 두 번째 밑줄은 2023, 2024를 넣을 컬럼명을 의미하므로 연도가 적절하다.",4
494,,,아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?,,"CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) ); INSERT INTO MYTEST VALUES(1,100); INSERT INTO MYTEST VALUES(2,200); COMMIT;",SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY 2;,SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY N2;,SELECT * FROM MYTEST ORDER BY 2;,SELECT N1 FROM MYTEST ORDER BY N2;,①번 보기에서 ORDER BY 항목은 반드시 SELECT 목록에 있는 칼럼의 자릿수를 사용해야 한다.,1
495,,,다음 정규화에 대한 설명으로 가장 적절한 것은?,,이행적 종속을 없애도록 테이블을 분리하는 단계,제4정규화,제3정규화,제2정규화,제1정규화,이행적 종속을 없애도록 테이블을 분리하는 단계는 제 3 정규화이다.,2
496,,,주어진 테이블에 대해서 아래의 SQL문을 수행하였을 때의 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j512-1.png,SELECT COUNT(*) FROM TEST39 GROUP BY COL1 HAVING COUNT(*)>2;,6,5,3,,"COL1 칼럼으로 GROUP BY를 할 경우 행 수가 2건 보다 많은 것은 4,5,6행이다.",3
497,,,다음 주어진 SQL문을 수행하였을 때의 결과가 아래와 같을 때 ( )에 들어갈 것으로 알맞은 것은?,,"SELECT 10 + 20 * (( )NULL, 0.1, 0.2)) FROM DUAL; 결과 : 14",COALESCE,NVL2,NVL,ISNULL,위의 SQL문에서 NVL2 함수의 첫 번째 인자값이 NULL이기 때문에 0.2를 반환한다. 그리고 10+20*0.2가 되어 14를 반환한다.,2
498,,,다음의 SQL문에 대한 설명으로 올바른 것은?,,"SELECT 'A', 1 FROM DUAL UNION ALL SELECT 1, 'A' FROM DUAL;",실행 결과로 아무것도 출력되지 않는다.,위의 SQL문은 실행되지 않는다.,UNION ALL을 사용해서 합집합을 만들고 중복을 제거한다.,"위의 SQL문 실행 결과는 A, 1, 1 ,A가 조회된다.",①오류 발생으로 실행되지 않는다. ③UNION의 설명이다. ④조회되는 데이터의 구조가 다르기 때문에 오류가 발생한다.,2
499,,,다음 날짜 연산의 결과로 가장 적절한 것은?,,"SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;",2024/05/24 10:10:00,2024/05/24 10:00:10,2024/05/14 11:00:00,2024/05/14 10:10:00,"2024/08/24 10:00:00 날짜로부터 10일 이전, 3개월 이전은 2024/05/14 10:00:00 이다. 10/24/60는 10분을 의미하므로 10분을 더하면 2024/05/14 10:10:00 이 된다.",4
500,,,다음 주어진 테이블에서 해당 SQL문을 실행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j496-1.png,"SELECT * FROM SQLD5 WHERE COL1 IN (1,2,NULL);",,,,,"NULL은 비교에서 애초에 제외되어 IN 연산자 안에 NULL이 있어도 비교 연산을 수행하지 않는다. 주어진 테이블의 COL1 속성값 1,2값을 갖는 튜플만 조회된다.",4
501,,,다음 문장이 차례대로 수행된 이후의 데이터 값으로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j667-1.png,"ALTER TABLE TAB1 ADD COL4 CHAR(5); ALTER TABLE TAB1 MODIFY COL4 DEFAULT 'AAA'; INSERT INTO TAB1 VALUES(4, 'D', 40, NULL); INSERT INTO TAB1(COL1, COL2, COL3) VALUES(5,'E',50);",,,,,"COL4 컬럼 추가 시, 기존 세 개의 행의 값은 NULL이 삽입된다. 그 이후 DEFAULT 값을 변경해도 이전에 삽입된 행은 반영되지 않고, 이후 삽입되는 행에 대해 적용된다. COL3에 DEFAULT 값이 설정되어 있다 하더라도 NULL을 직접 입력하면 NULL이 삽입되며, 마지막 INSERT 문장처럼 COL3의 값이 아예 입력되지 않을 경우만 DEFAULT VAULE로 삽입된다.",2
502,,,다음중 아래에서 성능을 고려한 데이터 모델링의 순서로 가장 적절한 것은?,,"가. 데이터 모델링을 할 때 정규화를 정확하게 수행한다. 나. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다. 다. 데이터베이스 용량산정을 수행한다. 라. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다. 마. 성능관점에서 데이터 모델을 검증한다. 바. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.",가-다-라-나-바-마,가-다-라-바-나-마,가-나-다-라-바-마,가-나-다-라-마-바,,1
503,,,ERD 작성 순서로 올바른 것을 고르시오.,,가) 엔터티를 그린다. 나) 엔터티를 적절하게 배치한다. 다) 엔터티 간에 관계를 설정한다. 라) 관계명을 기술한다. 마) 관계의 참여도를 기술한다. 바) 관계의 필수 여부를 기술한다.,가->나->다->마->바->라,가->나->라->다->마->바,나->가->다->라->마->바,가->나->다->라->마->바,,4
504,,,주어진 테이블에서 해당 SQL문을 수행 시 결과값으로 조회되는 테이블은 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j473-1.png,"SELECT C2, SUM(C3) FROM SQLD_01 GROUP BY C2 HAVING COUNT(*) >= 2;",,,,,주어진 테이블에서 C2 칼럼으로 그룹화 했을 때 C2 칼럼별 튜플의 수가 2개 이상인 C2칼럼에 대해서 C3의 합계를 계산한다.,3
505,,,"Oracle 환경에서 주어진 테이블을 아래의 결과와 같이 정렬하고자 할 때, SQL문의 빈칸에 들어갈 값을 고르시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j557-1.png,"SELECT C1,C2 FROM SQLD_02 ORDER BY C1,C2 DESC ( );",NULL LAST,NULLS LAST,NULL IS LAST,IS NULL,NULLS LAST는 NULL 값을 마지막에 정렬시키는 것이다.,2
506,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j710-1.png,"SELECT DEPTNO, DNAME, LEVEL, CONNECT_BY_ROOT(DNAME) AS ROOT FROM DEPARTMENT START WITH PART IS NULL CONNECT BY PRIOR PART = DEPTNO;",,,,,"PRIOR의 위치가 PART에 있으므로 가장 최상위 학과(PART IS NULL)를 먼저 출력하고, 두 행의 PART를 DEPTNO 로 갖는 행을 찾지만 해당 행이 없으므로 최상위 학과인 공과대학과 인문대학만 출력된다.",3
507,,,다음의 SQL문을 수행하였을 때의 결과로 알맞은 것은?,,"CREATE TABLE MYTEST (N1 NUMBER(10), N2 NUMBER(10)); INSERT INTO MyTEST VALUES (100, 200); INSERT INTO MyTEST VALUES (200, 300); SAVEPOINT T1; UPDATE MYTEST SET N1=300 WHERE N2=200; SAVEPOINT T1; DELETE MYTEST WHERE N1>=200; ROLLBACK TO SAVEPOINT T1; SELECT MAX(N1) FROM MYTEST;",200,100,300,,"SAVEPOINT가 중복될 경우 ROLLBACK TO SAVEPOINT을 수행하면, 중복된 SAVEPOINT 중 맨 뒤에 있는 SAVEPOINT 지점으로 ROLLBACK 된다.",3
508,,,다음 SQL 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j616-1.png,UPDATE EMPLOYEE E1 SET SAL = (SELECT MAX(SAL) FROM EMPLOYEE E2 WHERE E1.DNAME = E2.DNAME) WHERE SAL <= (SELECT AVG(SAL) FROM EMPLOYEE);,,,,,"전체 평균(4000)보다 급여가 낮은 직원들의 급여만 수정되므로 김길동 두 명의 급여는 수정되지 않는다. SET절은 각 행의 급여 수정 시 부서명을 확인하여 서브쿼리에서 해당 부서의 최대 급여를 찾아 수정하는 구문이다. 따라서 아시아지부는 모두 3000으로, 남유럽지부는 8000으로 수정된다.",2
509,,,다음 SQL문에 대한 실행 계획을 읽는 순서로 올바른 것은?,,1. Nested loops 2. Hash join 3. TABLE ACCESS (FULL) TABLE1 4. TABLE ACCESS (FULL) TABLE2 5. TABLE ACCESS (BY ROWID) TABLE3 6. INDEX (UNIQUE SCAN) PK_TABLES3,"6,5,4,3,2,1","3,4,6,2,5,1","1,2,3,4,5,6","3,4,2,6,5,1",SQL 문장에서 실행 계획을 읽는 순서는 우선 안에서 밖으로 읽으면서 같은 레벨에서는 위에서 아래로 읽는다.,4
510,,,다음 주어진 테이블에서 해당 SQL문을 실행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j546-1.png,"SELECT * FROM SQLD5 WHERE COL1 IN(1,2,NULL);",,,,,"NULL은 비교에서 애초에 제외되어 IN()연산자 안에 NULL이 있어도 비교연산을 수행하지 않는다. 주어진 테이블의 COL1 속성값 1,2값을 갖는 튜플만 조회된다.",4
511,,,다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?,,"SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; HR) GRANT CREATE VIEW TO HONG; SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; SYSTEM) REVOKE CREATE VIEW FROM HR;",HR 유저에게 부여된 EMP 테이블 입력 권한 회수 시 HONG에게 부여된 권한도 함께 회수되었다.,HR이 HONG에게 부여한 EMP 테이블의 조회 권한은 SYSTEM 계정에서 직접 회수가 가능하다.,HR 유저에게 부여된 CREATE TABLE 권한 회수 시 HONG에게 부여된 CREATE TABLE 권한도 함께 회수되었다.,HR 계정에게 부여된 SCOTT.EMP에 대한 SELECT 권한도 함께 회수된다.,"중간관리자가 WITN GRANT OPTION으로 부여 받은 권한을 제 3자에게 부여한 경우, 관리자가 제 3자의 권한을 직 접 회수할 수 없다. 하지만 중간관리자 권한을 회수하면 제 3자에게 부여한 권한도 함께 회수된다. 반대로 WITH ADMIN OPTION으로 부여할 경우 중간관리자 권한 회수 시 제 3자에게 부여한 권한은 함께 회수되지 않는다.",1
512,,,"다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?",,"(1) SELECT A.ID, B.ID FROM TBL1 A FULL OUTER JOIN TBL2 B ON A.ID = B.ID (2) SELECT A.ID, B.ID FROM TBL1 A LEFT OUTER JOIN TBL2 B ON A.ID = B.ID UNION SELECT A.ID, B.ID FROM TBL1 A RIGHT OUTER JOIN TBL2 B ON A.ID = B.ID (3) SELECT A.ID, B.ID FROM TBL1 A, TBL2 B WHERE A.ID = B.ID UNION ALL SELECT A. ID, NULL FROM TBL1 A WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID) UNION ALL SELECT NULL, B.ID FROM TBL2 B WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","1,2,3","2,3","1,3","1,2",,2
513,,,다음 테이블에 대해서 주어진 SQL문을 수행한 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j392-1.png,"SELECT A.JUMIN, B.CUSTRANK FROM (SELECT JUMUN, SUM(price) AS TOTAL, FROM T_ORDER GROUP BY JUMUN) A, T_CUST B WHERE 1=1 AND A.TOTAL BETWEEN B.MINPRICE AND B.MAXPRICE;",,,,,위의 SQL문은 1번째 테이블에서 주문자별로 grouping 하였을 때 각 주문자별로 주문금액의 합계를 계산하고 그 값이 두 번째 테이블의 실적범위에 해당하는 곳에서 고객등급과 주문자 정보를 조회한다.,4
514,,,다음 SQL 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j651-1.png,"SELECT E1.EMPNO, E1.ENAME, E1.HIREDATE, COUNT(E2.EMPNO) AS CNT FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.HIREDATE > E2.HIREDATE GROUP BY E1.EMPNO, E1.ENAME, E1.HIREDATE ORDER BY E1.HIREDATE;",,,,,"셀프조인을 사용하여 EMP에서의 각 직원별로 입사일이 빠른 직원의 수를 계산하는 질의절이다. 이 때, LEFT OUTER JOIN을 수행하였기 때문에 입사일이 가장 빠른 SMITH의 경우도 CNT가 0으로 출력된다.",3
515,,,다음의 JOIN 결과를 보고 빈칸에 들어갈 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j558-1.png,SELECT * FROM TEST46_1 ( ) TEST46_2 ON TEST46_1.COL1 = TEST46_2.COL1;,CROSS JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,SELF JOIN,"결과 테이블을 보면 TEST46_1 테이블에만 있는 3번행(COL1, COL2)만 조회되고 TEST46_2 테이블에는 3번행이 없으므로 NULL로 조회되었다. 따라서 LEFT OUTER JOIN을 실행한 것이다.",3
516,,,"아래 SQL 수행 결과로 가장 적절한 것은? (단, DBMS는 오라클)",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j695-1.png,"SELECT ENAME, DEPTNO, SAL FROM EMP ORDER BY DEPTNO, SAL DESC;",,,,,"DEPTNO가 작은순서대로, DEPTNO가 같은 경우 SAL이 큰 순서대로 정렬하여 출력한다. NULL이 마지막에 출력되는게 기본 순서이지만DESC로 내림차순 정렬하면 NULL이 젤 먼저 출력된다.",2
517,,,다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?,,"(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다. (나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다. (다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다. (라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다. (마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","가, 다, 라, 마","가, 나, 다, 라","가, 나, 다","가, 다, 라",,1
518,,,다음 보기의 SQL문을 실행했을 때의 결괏값은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j307-1.png,SELECT SUM(SCORE) / COUNT(NO) FROM Mytest,400,300,200,100,"COUNT(칼럼명)으로 조회를 하는 경우는 NULL 값이 제외된다. 따라서 3이 된다. 즉, 합계 1200/3=400이다.",1
519,,,다음의 설명에 해당하는 join은?,,조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.,INNER JOIN,NESTED LOOP JOIN,SORT MERGE JOIN,HASH JOIN,sort merge조인은 테이블을 정렬한 후에 정렬된 테이블을 병합하면서 조인을 실행한다.,3
520,,,다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?,,"우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.",예금분류는 설계(DESIGNED)속성이다.,이자와 이자율은 파생(DERIVED)속성이다.,"원금, 예치기간은 기본(BASIC)속성이다.",일반예금은 코드 엔터티를 별도로 구분하고 값에는 코드값만 포함한다.,,2
521,,,주어진 보기의 SQL(ROLLUP)에 대한 결과와 동일한 결과를 반환하도록 아래 SQL문의 ( )에 올바른 것은?,,"SELECT COL1, COL2, COUNT(*) FROM TEST46 GROUP BY ROLLUP (COL1, COL2); SELECT COL1, COL2, COUNT(*) FROM TEST46 GROUP BY GROUPING SETS ( )",UNION ALL,MINUS,EXPECT,UNION,"ROLLUP은 그룹된 칼럼의 Subtotal 생성하기 위해서 사용된다. 그룹의 수가 N개일 때 N+1개의 Subtotal이 생성된다. 그리고 GROUPING SETS은 여러 그룹질의를 UNION ALL과 같은 결과를 만들어서 소계, 합계를 집계할 수 있다.",1
522,,,"학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?",,"SELECT 학생.이름 학생명, 교수.이름 교수명 FROM 학생 _________ 교수 ON 학생.교수번호 = 교수.교수번호;",INNER JOIN,FULL OUTER JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,"왼쪽에 배치된 학생 테이블 기준, 지도 교수가 없어도 교수 정보를 NULL로 출력하려면 LEFT OUTER JOIN이 수행 되어야 한다.",4
523,,,다음 중 홍길동 사용자에게 아래의 작업을 실행할 수 있도록 권한을 부여한 것으로 올바른 것은 무엇인가?,,Update emp set sal=1000 where deptno=100;,grant create table on 홍길동 on emp;,"revoke select, update on emp;","grant select, update on emp;","grant select, update on emp to 홍길동;",grant는 권한을 부여하는 SQL문이고 revoke는 권한을 삭제하는 SQL문이다. grant구의 문법은 grant 권한 on 테이블 to 사용자이다.,4
524,,,다음의 SQL문을 실행했을 때 그 결과가 다른 하나는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j415-1.png,"SELECT NVL(COL2,COL3) AS 금액A, COALESCE(COL2,COL3) AS 금액B, NULLIF(COL2,COL3) AS 금액C, CASE WHEN COL2 IS NOT NULL THEN COL2 ELSE COL3 END AS 금액D FROM Mytest",금액D,금액C,금액B,금액A,"②번 보기에서의 연산자인 NULLIF는 COL2와 COL3이 동일하면 NULL을, 동일하지 않으면 COL2를 반환하는데 3번째 행에서 COL2, COL3 값이 다르므로 해당 행에서의 COL2 값인 NULL 값을 반환한다.",2
525,,,다음 SQL문의 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j659-1.png,SELECT * FROM 고객 ORDER BY 포인트 DESC OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY;,,,,,고객 테이블에서 포인트가 높은 순서대로 정렬을 한 후 2개의 행을 건너 뛰고 3번째부터 2개의 행을 뽑는다.,4
526,,,다음이 설명하는 관계로 가장 적절한 것은?,,"두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.",상호일관적,상호배타적,상호포괄적,상호종속적,두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계는 상호 배타적 관계이다.,2
527,,,"아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?",,"CREATE TABLE 서비스 (서비스번호 VARCHAR2(10) PRIMARY KEY, 서비스명 VARCHAR2(100) NULL, 개시일자 DATE NOT NULL ); [SQL] (ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1; (ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11'); (ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''; (ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL;","SQL Server에서 (ㄴ)과같이 데이터를 입력하고, (ㄹ)과 같이 조회하였을 때, 데이터는 조회되지 않는다.","ORACLE에서 (ㄴ)과같이 데이터를 입력하고, (ㄷ)과 같이 조회하였을 때, 데이터는 조회된다.","ORACLE에서 (ㄴ)과같이 데이터를 입력하였을 때, 서비스명 컬럼에 공백문자 데이터가 입력된다.",서비스번호 컬럼에 모든 레코드 중에서 '001'과 같은 숫자형식으로 하나의 레코드만이라도 입력되어 (ㄱ)은 오류 없이 실행된다.,,1
528,,,아래 SQL 실행 결과로 가장 적절한 것은?,,"CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); INSERT INTO TAB1 VALUES(1,10); INSERT INTO TAB1 VALUES(2,20); INSERT INTO TAB1 VALUES(3,30); COMMIT; ALTER TABLE TAB1 ADD (COL3 NUMBER); INSERT INTO TAB1 VALUES(4,40,100); UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; DELETE TAB1 WHERE COL1 = 3; ALTER TABLE TAB1 DROP COLUMN COL1; ROLLBACK; SELECT SUM(COL2 + COL3) FROM TAB1;",140,130,120,110,"처음 INSERT 3개의 문장은 COMMIT을 수행했으므로 영구 저장된다. 이후 COL3을 추가하면 이미 입력된 세 개의 행에 대해 NULL을 갖게 된다. 그 뒤 수행하는 INSERT, UPDATE, DELETE 문장은 이어서 실행하는 ALTER TABLE DROP COLUMN 문장으로 인해 자동 확정된다.(DDL AUTO COMMIT). 따라서 ROLLBACK을 수행해도 취소되지 않는다.",1
529,,,다음 중 아래의 테이블에서 SQL을 실행할 때 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j124-1.png,"[SQL] SELECT CASE WHEN GROUPING(A.서비스ID) = 0 THEN A.서비스ID ELSE '합계', END AS 서비스ID ,CASE WHEN GROUPING (B.가입일자) = 0 THEN NVL (B.가입일자, '-') ELSE '소계' END AS 가입일자 ,COUNT (B. 회원번호) AS 가입건수 FROM 서비스 A LEFT OUTER JOIN 서비스가입 B ON (A.서비스ID = B. 서비스ID AND B.가입일자 BETWEEN '2013-01-01' AND '2013-01-31') GROUP BY ROLLUP (A.서비스ID, B.가입일자);",execute 'TRUNCATE TABLE DEPT';,execute immediate 'TRUNCATE TABLE DEPT';,DELETE FROM DEPT;,TRUNCATE TABLE DEPT;,ROLLUP은 계층 구조를 가진 SUB TOTAL을 생성하는 함수로 나열된 컬럼의 순서가 변경되면 수행 결과도 변경된다. 위의 SQL문장은 서비스ID에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수 를 구하되 Outer Join을 수행하였으므로 가입내역이 없는 서비스ID(004)에 대해서도 SUB TOTAL을 출력하고 있다. ④은 서비스ID 에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수를 구한 것은 맞으나 LEFT OUTER JOIN이 아닌 INNER JOIN에 대한 결과로 서비스ID 004가 출력되지 않았다.,2
530,,,아래 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j612-1.png,"SELECT E.*, LEVEL FROM 사원 E START WITH 매니저사원번호 IS NULL CONNECT BY PRIOR 사원번호 = 매니저사원번호 AND EXTRACT(MONTH FROM 입사일자) >= 7 ORDER SIBLINGS BY 이름;",,,,,"매니저 사원번호가 NULL인 지점을 시작으로 레벨 1을 부여, 나사장의 사원번호를 매니저 사원번호로 가지면서 하반기 입사자인 행을 찾아 레벨 2를 부여한다. 이렇게 연결된 행으로부터 CONNECT 절의 조건을 만족하는 행을 계속 이어 나간다. 이때, START WITH 절은 CONNECT BY에 있는 조건에 따라 생략되지 않기 때문에 나사장이 상반기 입사자라도 출력된다.",3
531,,,"다음 중 RANK, DENSE_RANK, ROW_NUMBER 결과로 가장 적절한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j657-1.png,"SELECT NO, RANK() OVER(ORDER BY JUMSU DESC) AS RANK1, DENSE_RANK() OVER(ORDER BY JUMSU DESC) AS RANK2, ROW_NUMBER() OVER(ORDER BY JUMSU DESC) AS RANK3 FROM STUDENT;",,,,,"RANK는 동점일 경우 같은 등수로 표시하고 다음 순위는 동점인 순위의 수만큼 밀리므로 12245가 출력되지만 DENSE_RANK는 동점일 경우 동순위를 부여 뒤, 다음 순위가 바로 이어지므로 12234가 리턴된다. ROW_NUMER는 동점일 경우를 인정하지 않고 순서대로 나열하므로 12345가 최종 출력된다.",3
532,,,다음의 SQL문 실행 결과로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j431-1.png,"SELECT COUNT(DATA1), COUNT(DATA2) FROM (SELECT DISTINCT DATA1, DATA2 FROM Mytest);","1,1","2,2","2,1","1,3","인라인 뷰에 있는 DISTINCT구는 중복을 제거하기 때문에 1,A 와 1,B 두개의 행이 조회된다. 따라서 행 수를 계산하는 COUNT는 2,2가 조회된다.",2
533,,,"다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?",,"create table 사원(번호 char(10) primary key, 월급 integer); SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000; SQL B : select count(번호) from 사원;","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 번호 필드에 널(NULL)값이 존재할 수 있기 때문이다.","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 월급 필드에 널(NULL)값이 존재할 수 있기 때문이다.",SQL A와 SQL B의 결과는 항상 다르다.,SQL A와 SQL B의 결과는항상 같다.,"count()는 행 수를 계산하는 집계함수이다. 집계함수의 특성은 NULL 값을 제외한다는 것이다. 그래서 NULL 값이 존재하는 경우 집계 결과는 달라질 수 있다. 번호 칼럼은 PK이므로 값이 무조건 들어있다. 즉, COUNT(번호)는 모든 행의 개수를 출력한다. 반면에 월급 칼럼에 NULL이 들어있을 경우에는 WHERE 월급>=100000 OR 월급<100000 이 부분에서 NULL은 정상적인 비교가 되지않아 행이 조회되지 않는다. 즉 출력되는 행의 개수가 달라질 수 있다는 의미이다.",2
534,,,다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?,,데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.,외래키,후보키,수퍼키,인조키,후보키는 유일성과 최소성을 만족하는 키이다.,2
535,,,아래의 SQL의 출력 결과 중 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j604-1.png,SELECT COUNT(*) FROM TAB1 WHERE EXISTS (SELECT 1 FROM TAB2 WHERE TAB2.COL1 = 'A');,3,1,0,,서브쿼리 결과가 항상 거짓이므로 조건에 만족하는 행이 없다. 이 경우 COUNT는 NULL이 아닌 0을 리턴한다.,3
536,,,테이블을 생성할 수 있는 권한을 부여하는 SQL문을 완성하시오.,,( ) CREATE TABLE TO LIMBEST;,ROLLBACK,COMMIT,GRANT,REVOKE,테이블의 권한을 부여하는 DCL은 GRANT이다.,3
537,,,다음의 SQL문은 파티션별 윈도우의 전체건수에서 현재 행보다 작거나 같은 건수에 대해서 누적백분율을 구하는 SQL문이다. (ㄱ)에 올바른 윈도우 함수는?,,"SELECT DEPTNO, ENAME, SAL, ( ㄱ ) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) as PCT FROM EMP;",CUME_DIST(),LAG(),LEAD(),NTILE(),CUME_DIST 함수는 주어진 그룹에 대한 상대적인 누적분포도 값을 반환하는 것으로 분포도 값은 0 초과 1 이하 사이의 값이다.,1
538,,,"아래와 같은 테이블 TAB1, TAB2가 있을 때 아래의 SQL의 결과 건수를 알맞게 나열한 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j600-1.png,SELECT * FROM TAB1 A INNER JOIN TAB2 B ON (A.KEY1 = B.KEY2) SELECT * FROM TAB1 A LEFT OUTER JOIN TAB2 B ON (A.KEY1 = B.KEY2) SELECT * FROM TAB1 A FULL OUTER JOIN TAB2 B ON (A.KEY1 = B.KEY2) SELECT * FROM TAB1 A CROSS JOIN TAB2 B SELECT * FROM TAB1 A NATURAL JOIN TAB2 B,3 6 8 12 4,3 5 6 16 3,2 5 6 16 4,2 4 6 8 3,"INNER JOIN은 값이 같으면 모두 출력되므로 TAB1의 KEY1의 값이 BB인 경우 2건, CC와 DD는 일치하는 값이 없으므로 생략, EE는 한 건이 출력되어 총 3건이 리턴된다. LEFT OUTER JOIN은 TAB1의 KEY1의 값이 모두 출력돼야 하므로 앞의 INNER JOIN 결과에 CC와 DD가 추가적으로 리턴되어 총 5건이 된다. FULL OUTER JOIN은 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과의 합집합(중복 값은 한 번만 출력)이므로 총 6건이며 CROSS JOIN의 경우는 모든 발생 가능한 조합이므로 4X4, 16건이 리턴된다. NATURAL JOIN에 의해 COL1, COL2 값이 같은 값만 출력되며 이때 NULL은 같다고 볼 수 없기 때문에 제외되어 총 3건이 출력된다.",2
539,,,아래 SQL 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j599-1.png,"SELECT COUNT(*) FROM TAB1, TAB2 WHERE NAME LIKE RULE_NAME;",3,2,1,0,"TAB1을 RULE_NAME에 매핑되는 규칙으로 TAB2에 조인을 수행했기 때문에, 각 행마다 LIKE 조건이 일치하면 TAB2 값이 출력된다. 즉, SCOTT은 %O%와, FORD는 %O%와 F% 둘 다 매핑되어 행이 두 개로 출력된다. 따라서 총 행의 수는 3건이 리턴된다.",1
540,,,다음 설명에 해당하는 속성의 종류는 무엇인가?,,-다른 속성에 영향을 받아 발생하는 속성으로서 보통 계산된 값들이 이에 해당한다. -다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많다. -가급적 속성을 적게 정의하는 것이 좋다.,파생 속성,설계 속성,기본 속성,연관 속성,다른 속성으로부터 계산이나 변형이 되어 생성되는 속성을 파생속성이라고 한다.,1
541,,,아래의 SQL 의 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j598-1.png,"SELECT SUM(A.COL1) FROM TAB1 A, TAB2 B WHERE A.COL2 <> B.COL2;",30,12,10,8,"NULL은 같지 않다에 참이 리턴되지 않는다. 따라서 TAB1 기준 COL2가 A인 경우는 1개, NULL인 경우 0개, B인 경우 1개, C인 경우 2개가 리턴된다. 따라서 이들의 COL1에 대한 총 합은 12가 된다.",2
542,,,"""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?",,ㄱ : SELECT COUNT(*) FROM TEST; ㄴ : SELECT COUNT(NUM2) FROM TEST;,"ㄱ:8, ㄴ:8","ㄱ:8, ㄴ:10","ㄱ:10, ㄴ:8","ㄱ:10, ㄴ:10",COUNT(칼럼명)을 실행하면 NULL 값은 제외된다.,3
543,,,"다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?",,"집합 A = {가, 나, 다, 라}, 집합 B = {다, 라, 마, 바}, 집합 C = {다, 라}",Product,Intersection,Difference,Union,"집합 C는 집합 A와 집합 日의 교집합이며, 데이터베이스에서 교집합 기능을 하는 집합 연산 Intersection 이다.",2
544,,,다음 출력 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j615-1.png,"SELECT COUNT(COL1) FROM TAB1 WHERE REGEXP_LIKE(COL1, '[XY-]+Z?');",5,4,3,2,"[XY-]는 X 또는 Y 또는 -와 같다. 따라서 X, Y, - 중 하나가 여러 번 반복되면서 그 뒤에 Z값이 오거나 오지 않는 문자열 배열을 갖는 행은 전체이므로 총 5개가 출력된다.",1
545,,,다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?,,"SELECT EMPNO, deptno, SALARY AS ""salary"" FROM Mytest WHERE EMPNO < 1000;","EMP, DEPT, SALARY","EMPNO, DEPTNO, SALARY","EMP, DEPT, SAL","EMPNO, DEPTNO, salary",세 번째 칼럼명 Alias를 사용했으므로 salary가 된다. 또한 deptno는 oracle에서 대문자로 조회되고 SQL Server에서는 칼럼명 그대로 조회된다.,4
546,,,두 개의 테이블에 대해서 UNION ALL을 실행 했을 때 조회되는 행 수는?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j341-1.png,"SELECT DISTINCT COL1, COL2 FROM MytestA UNION ALL SELECT COL1, COL2 FROM MytestB;",7,4,5,2,"첫 번째 테이블에서 DISTINCT로 중복된 행이 제외되어 (1,2),(1,3) 두개의 행만 남고 두번 째 테이블과 UNION ALL로 중복을 포함하여 합쳐져 (1,2),(1,3),(1,2),(1,4),(1,5) 5개의 행이 조회된다.",3
547,,,다음 SQL 실행 결과로 가장 적절한 것은?,,"SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;",031-234-XXX,031-XXX-4567,XX1-234-4567,031-234-4567,문자열 처음부터 찾아서 두 번째로 발견되는 숫자의 연속 문자열을 XXX로 치환하면 031-XXX-4567 이 리턴된다.,2
548,,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j790-1.png,SELECT COUNT(ENAME) FROM EMP WHERE ENAME NOT LIKE '_L%E%';,4,3,2,1,"두 번째 글자가 L이면서 그 뒤에 E를 하나 포함하는 이름을 제외하면 SMITH, KING, CLARK 가 출력된다.",2
549,,,"다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?",,"employee(eno, ename, address, score, dno) dependent(eno, ename, birthday, relation)","SELECT e.eno, e.ename, count(*) FROM employee e, dependent d WHERE e.eno = d.eno GROUP BY e.eno, e.name HAVING count(*) >= 3;","SELECT e.eno, e.ename, t.cnt FROM employee e, (SELECT eno, count(*) as cnt FROM dependent GROUP BY eno HAVING count(*) >= 2) t WHERE e.eno = t.eno;","SELECT e.eno, e.ename, count(*) FROM employee e, dependent d WHERE EXISTS (SELECT * FROM dependent GROUP BY eno HAVING count(*) >=2) GROUP BY e.eno, e.ename;","SELECT eno, ename, count(*) FROM employee e, dependent d WHERE e.eno = d.eno and count(*) >= 2 GROUP BY d.eno;","위의 문제는 GROUP BY ~ HAVING절을 파악하는 것으로 GROUP BY에 조건을 걸기 위해서는 HAVING절을 사용해야 하며 ④번의 경우 count(*) 조건을 사용하기 위해서 HAVING절을 사용해야 한다. ③번은 서브쿼리 SELECT문에 집계함수가 존재하지 않는다. ①번은 HAVING count(*)의 ""3""이 2가 되면 올바르게 실행된다.",2
550,,,주어진 테이블에 대해서 아래와 같이 결괏값이 반환되도록 아래의 SQL문 빈칸에 들어갈 윈도우 함수를 적으시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j562-1.png,"SELECT ENAME, SAL, ( ) as SM_CNT FROM SQLD_11;",COUNT(*) OVER(ORDER BY CNT RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 0 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),MAX(SAL) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),"먼저 위의 SQLD_11 테이블에서 결과값과 같이 반환되도록 'SAL' 속성을 기준으로 정렬을 수행하고, 각각의 행에서의 SAL 속성값을 기준으로 -50에서 +100범위 사이에 포함되는 SAL값을 가지는 모든 행의 수를 COUNT하여 SIM_CNT 속성값으로 조회한다.",3
551,,,다음과 같은 결괏값을 조회하기 위해서 SQL 문의 ( )에 알맞은 것을 넣으시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j309-1.png,"SELECT ENAME, SAL, ( ) as CNT FROM Mytest;",COUNT(*) OVER(ORDER BY CNT RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 0 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),MAX(SAL) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),"먼저 위의 Mytest 테이블에서 결괏값과 같이 반환되도록 ''SAL"" 속성을 기준으로 정렬을 수행하고 각각의 행에서의 SAL 속성값을 기준으로 -50에서 +150 범위 사이에 포함되는 SAL값을 가지는 모든 행의 수를 COUNT하여 CNT 속성값으로 조회한다.",3
552,,,다음 SQL 실행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j663-1.png,"SELECT REGEXP_REPLACE(COL1, 'A(X|Y)+\.') FROM TAB1;",,,,,A 뒤에 X 또는 Y가 여러 개 오며 그 뒤에 .이 오는 문자열을 찾아 모두 지우는 쿼리문이다.,3
553,,,아래의 결괏값을 보고 SQL문의 빈칸에 들어 갈 수 있는 내용을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j299-1.png,"SELECT DEPTNO, JOB, SUM(SAL) FROM Mytest GROUP BY ( );","CUBE(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","GROUPING SETS(DEPTNO, JOB)","DEPTNO, JOB","주어진 결괏값을 보면 1, DEPTNO별 합계, 2.DEPTNO,JOB별 합계, 3.전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다.",2
554,,,다음 식별자에 대한 설명으로 가장 적절한 것은?,,"엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자",복합식별자,본질식별자,인조식별자,보조식별자,"주식별자의 반대는 보조식별자로, 인스턴스를 구분할 수 있지만 대표성을 가지지 못하는 식별자를 말한다. 본질 식별자는 업무적으로 존재하는 식별자, 인조식별자는 업무에서 사용되지는 않지만 인위적으로 만든 식별자를 의미하며 복합식별자는 단일 식별자의 반대로 여러 속성으로 구성된 식별자를 의미한다.",4
555,,,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,,ㄱ : SELECT SUM(SAL) FROM EMP GROUP BY DEPTNO; ㄴ : SELECT SUM(SAL) FROM EMP GROUP BY ROLLUP(DEPTNO);,ㄱ의 SQL문은 전체합계는 출력되지 않는다.,ㄴ은 부서별 합계와 전체합계가 출력된다.,ㄱ과 ㄴ의 결과 행 수는 동일하다.,ㄱ은 부서별 합계를 출력한다.,ㄱ과 ㄴ의 SQL문의 행 수는 다르다. 왜냐하면 ROLLUP은 전체합계가 추가적으로 출력된다.,3
556,,,주어진 테이블에 대해서 아래와 같은 결괏값이 나오도록 SQL 빈칸을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j397-1.png,"SELECT EMPLOYEE_ID, DEPARTMENT_ID, LAST_NAME, SALARY, LAG(SALARY,( )) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY) AS BEFORE_SALARAY FROM EMPLOYEES WHERE EMPLOYEE_ID < 110;",4,3,2,1,"LAG 함수는 이전 행의 값을 반환하는 함수이다. LAG(SALARY, 2)라고 하면 이전 두 번째 행 값을 반환하게 된다.",3
557,,,아래 SQL의 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j640-1.png,SELECT SUM(SAL) FROM TAB1 WHERE NO NOT IN (SELECT NO FROM TAB2 GROUP BY NO);,700,600,,0,NOT IN문의 서브쿼리 결과 중 NULL이 포함되는 경우 데이터가 출력되지 않는다. NULL은 논리적으로 비교할 수 없는 연산이기 때문에 NULL을 비교하는 연산자로 인해 전체조건이 거짓이 된다. 조건에 만족하는 값이 없으므로 SUM 결과는 NULL이 된다.,3
558,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j752-1.png,"SELECT NAME, NVL((SELECT FARE FROM PROMOTION P2 WHERE P1.CODE = P2.CODE), 100) PRO_FARE FROM PRODUCT P1;",,,,,"스칼라 서브쿼리는 OUTER JOIN을 수행하지 않아도 연결 조건에 만족하지 않는 행도 출력된다. 즉, D가 출력되는데, NVL로 NULL을 100으로 치환하고 있으므로 D의 PRO_FARE는 100으로 리턴된다.",2
559,,,아래 SQL에서 출력되는 ROWS의 개수를 구하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j210-1.png,"SELECT DNAME, JOB, COUNT(*) ""Total Emp"", SUM(SAL) ""Total Sal"" FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY CUBE(DNAME,JOB);",20건,18건,14건,10건,DEPTNO로 조인을 하고 DNAME과 JOB으로 CUBE를 실행했다. CUBE는 전체합계와 각 칼럼별로 부분합계를 출력한다. CUBE는 입력된 칼럼들의 모든 조합으로 집계를 출력한다.,2
560,,,다음 SQL문의 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j736-1.png,"SELECT DECODE(DEPTNO, 10, DECODE(JOB, 'CLERK', 'A', 'B'), 'C') AS RESULT FROM EMP ORDER BY EMPNO;",,,,,"DEPTNO가 10이면서 JOB이 CLERK인 경우 A, DEPTNO가 10이면서 JOB이 CLERK가 아닌 경우는 B를 리턴하며, DEPTNO가 10이 아닌 경우는 모두 C를 리턴한다.",4
561,,,아래의 내용은 주식별자의 어떤 특징을 설명한 것인가?,,학생의 학번으로 고유한 구조를 표현할 수가 있다.하지만 ABC대학교의 학생 엔터티의 주식별자를 학번과 입학일자로 해서 잘못된 모델링을 했다.,존재성,불변성,최소성,유일성,최소성 : 주식별자는 최소성을 만족하는 키이다.,3
562,,,다음은 어떤 데이터 모델링에 대한 설명인가?,,추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링,개념적 데이터 모델링,개괄적 데이터 모델링,물리적 데이터 모델링,논리적 데이터 모델링,"모델링의 3 단계는 개념적, 논리적, 물리적 모델링이 있으며, 이 중 추상화 수준이 가장 높고 업무를 분석하는 단계는 개념적 모델링이다.",1
563,,,다음 SQL 수행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j639-1.png,"SELECT COALESCE(COL1, COL2, COL3) RESULT FROM TAB1;",,,,,"COALESCE 함수는 대상들 중 널이 아닌 첫 번째 값을 출력하므로 첫 번째 행부터 10, 10, 20 이 출력된다.",3
564,,,아래 설명 중 빈칸에 해당하는 내용을 작성하시오.,,ABC기업에 입사한 새로운 개발자에게 권한을 부여할 때 사용하는 것은 ( ㄱ ) 이고 권한을 회수할 때 사용하는 것은 ( ㄴ )이다.,ㄱ. AUTHORIZE ㄴ.REMOVE,ㄱ.GRANT ㄴ.REVOKE,ㄱ.ALLOW ㄴ.REVOKE,ㄱ.GRANT ㄴ.WITHDRAW,GRANT는 사용자에게 권한을 부여하고 REVOKE는 권한을 회수한다.,2
565,,,아래 실행 결과를 출력하는 SQL로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j660-1.png,"SELECT 사원번호, 이름, LEVEL FROM 사원 START WITH 사원번호 IN (1006, 1001) CONNECT BY PRIOR 상위관리자코드 = 사원번호;",,,,,"START WITH 조건이 1006과 1001이므로 두 행이 1레벨이 되고, 해당 행의 상위관리자코드를 사원번호로 갖는 행을 찾으면 둘 다 홍길동이 출력된다. 따라서 정답은 3번이 된다.",2
566,,,주어진 데이터에서 아래의 SQL문을 실행한 행의 건수로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j479-1.png,"SELECT COUNT(*) FROM SQLD49, SQLD49_2 WHERE SQLD49.COL1 = SQLD49_2.COL1;",3,4,9,1,INNER JOIN이므로 JOIN조건을 만족하는 행만 가져와서 조건을 수행한다.,3
567,,,다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?,,가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다. 나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다. 다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다. 라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.,"가,나,다,라","나,다,라","가,나,라","가,나,다",,1
568,,,트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?,,트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.,지속성,고립성,일관성,원자성,"트랜잭션 전후의 데이터가 일관적인지를 설명한 내용이다. 원자성은 모두 성공하거나 모두 실패해야 한다는 특징이며, 고립성은 트랜잭션 실행 도중 다른 트랜잭션에 영향을 받지 않는다는 특성이다. 또한, 지속성은 트랜잭션이 성공적으로 수행되면 갱신한 데이터베이스 내용이 영구적으로 저장되는 특징을 말한다.",3
569,,,아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는?,,SELECT _________(5.47) FROM DUAL;,ROUND,FLOOR,CEIL,TRUNC,"TRUNC는 소수점 이하 버림으로 결과값인 5, CEIL은 값보다 큰 최소정수로 6이 출력된다. FLOOR는 값보다 작은 최대 정수가 리턴되므로 5, ROUND는 소수점 첫번째 자리에서 반올림하여 5가 출력된다.",3
570,,,다음은 WINDOW 함수를 사용해서 순위를 구한 것이다. 다음 중 빈칸의 내용으로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j290-1.png,"SELECT ( ) OVER (ORDER BY 급여 desc) as 순위, 이름, 급여 FROM Mytest;",ROW(),ROW_NUMBER(),DENSE_RANK(),RANK(),결괏값에서 중복된 등수 2등 다음에 바로 다음 등수인 3등이 왔으므로 빈칸에는 DENSE_RANK가 와야 한다.,3
571,,,AUTO COMMIT이 FALSE로 설정된 환경에서 다음의 SQL문을 실행했을 때의 결과로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j384-1.png,CREATE TABLE MYTEST_TEMP (COL1 NUMBER(10)); UPDATE MYTEST SET COL1=130 WHERE COL2=10; ROLLBACK;,AUTO COMMIT이 FALSE이므로 UPDATE구는 자동 COMMIT되지 않는다.,ORACLE에서 ROLLBACK을 실행하면 테이블은 생성되지 않는다.,ORACLE에서 ROLLBACK을 수행하면 UPDATE구는 취소된다.,SQL SERVER에서 ROLLBACK을 하는 경우 UPDATE구는 취소된다.,CREATE TABLE 문구와 같은 DDL구는 ROLLBACK으로 취소되지 않는다.,2
572,,,다음의 주어진 테이블에서 아래의 SQL문을 수행하였을 때의 결과가 RESULT와 같을 때 SQL문의 (ㄱ)에 들어갈 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j350-1.png,"SELECT VAL, COUNT(*) AS CNT FROM( SELECT( ㄱ )(4) over (ORDER BY COL1) AS VAL FROM Mytest ) WHERE 1=1 GROUP BY VAL ORDER BY 1;",LAG,RANK,LEAD,NTILE,"NTILE 함수는 expr에 명시된 값만큼 파티션을 균등하게 분할하는 함수로 expr에 명시된 숫자가 4이고 order by가 1이니 오름차순 정렬로 총 4개의 VAL속성값으로 파티션이 분할되며 각 파티션별로 행의 수가 균등하게 분할되어 3,3,2,2의 행의 수로 각각 분할된다.",4
573,,,"다음의 ""Mytest17"" 테이블에서 아래의 SQL문을 수행한 결과로 알맞은 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j372-1.png,SELECT SUM(C1+C2+C3+C4) FROM Mytest7 UNION ALL SELECT SUM(C1) + SUM(C2) + SUM(C3) + SUM(C4) FROM Mytest17;,"NULL, NULL","50, 260","NULL, 260","50, NULL","1번째 경우는 4개의 칼럼(C1,C2,C3,C4)모두 NULL이 아닌 값을 가지는 행에 대해서만 합계가 계산되므로 첫 번째 행에서의 칼럼들의 합계만 계산된다. 2번째 경우는 4개의 칼럼에 대해서 각각의 합계가 계산되고 이후에 각 합계들의 최종적인 합계가 계산된다.",2
574,,,Orders 테이블의 고객id에는 Customers 테이블에 존재하지 않는 고객id도 있다. Customers 테이블에 존재하지 않는 고객id만 Orders 테이블에서 추출하는 SQL을 ( )를 채워 완성하시오.,,SELECT * FROM Orders WHERE ( ㄱ ) (SELECT * FROM Customers WHERE ( ㄴ ));,ㄱ: NOT EXISTS ㄴ: Customers. id <> Orders. id,ㄱ: NOT EXISTS ㄴ: Customers. id = Orders. id,ㄱ: EXISTS ㄴ: Customers. id <> Orders. id,ㄱ: EXISTS ㄴ: Customers. id = Orders. id,"Customers 테이블에서 존재하지 않은 고객id를 식별하기 위해서는 NOT EXISTS를 사용하고 WHERE구에 ""Customers. id = Orders. id""를 사용해야 한다.",2
575,,,다음 주어진 테이블에 대해서 [결과]와 같이 반환되게 하는 SQL문을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j497-1.png,"SELECT DNAME, JOB, SUM(SAL) FROM TEST18 GROUP BY ( )",CUBE(DNAME),"GROUPING SETS(DNAME,JOB)","ROLLUP(DNAME,JOB)","CUBE(DNAME,JOB)","결괏값을 보면 1.DNAME, JOB별 소계 2.DNMAE 별 소계 3.JOB별 소계 4.전체 집계 등 모든 조합 가능한 소계와 집계가 조회되었으므로 빈칸에 들어갈 그룹 함수는 CUBE이다.",4
576,,,아래의 SQL 구문 중 결과가 다른 것은?,,"MytestA 테이블 칼럼: NO, C1 MytestB 테이블 칼럼: NO, C2","SELECT A.NO, A.C1, B.C2 FROM MytestA A JOIN MytestB B ON (A.NO = B.NO);","SELECT A.NO, A.C1, B.C2 FROM MytestA A CROSS JOIN MytestB B;","SELECT NO, A.C1, B.C2 FROM MytestA A CROSS JOIN MytestB B;","SELECT NO, A.C1, B.C2 FROM MytestA A NATURAL JOIN MytestB B;","①,③,④번 보기는 두 개의 테이블에서 동일한 이름을 가지는 칼럼에 대해서 조인을 수행하는 방식이고 ②번 보기는 두 테이블의 모든 데이터에 대해서 조인을 수행하는 CROSS JOIN방식이다.",2
577,,,다음 계층형 쿼리문에 대한 설명으로 옳지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j458-1.png,"SELECT ID, PARENT_ID, NAME, PARENT_NAME FROM SQLD_13 WHERE PARENT_ID NOT IN (3) START WITH PARENT_ID = 0 CONNECT BY PRIOR ID = PARENT_ID ORDER SIBLINGS BY PARENT_ID ASC, ID ASC;",ORDER SIBLINGS BY를 하면 전체 테이블 기준으로 정렬한다.,중복이 생겼을 때 루프를 돌지 않기 위해 NO CYCLE 옵션을 사용할 수 있다.,순방향 전개다.,PARENT_ID가 0이라도 3이 포함되면 전개를 멈춘다.,"④의 경우, 계층쿼리는 일단 START WITH_CONNECT BY로 전개를 수행한 후에 WHERE로 필터링을 한다. 만약 CONNECT BY에 AND 조건을 PARENT_ID != 3 식이었다면 전개 중에 멈추겠지만 WHERE에서 필터링을 하는 것이므로 일단 전개를 완료한 후에 WHERE가 실행되는 것으로 볼 수 있다.",1
578,,,"다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?",,"create table 학과 (학과번호 char(10) primary key, 학과명 char(10)); create table 학생 (학번 char(10) primary key, 소속학과 char(10), foreign key (소속학과) references 학과(학과번호) on delete cascade on updatde set null); insert into 학과 values ('1', '전산과'); insert into 학과 values ('2', '전기과'); insert into 학생 values ('100', '1'); insert into 학생 values ('200', '2'); insert into 학생 values ('300', '2'); select count(학번) from 학생; delete from 학과 where 학과번호 = '2'; select count(학번) from 학생;","3,null","3,3","3,2","3,1","""select count(학번) from 학생""은 학생 테이블에 총 3개를 삽입했으므로 3이 된다. 그리고 ""delete from 학과 where 학과번호 =2""를 삭제한다. 학과 테이블에서 학과번호 ""2""를 삭제하면 학생 테이블과 외래키 관계로 있고 ""on delete cascade""가 설정되어 있다. 따라서 학생 테이블에 학과번호 2번은 모두 자동 삭제된다. 그러면 학생 테이블에는 학과번호 ""1""번만 남게 되기 때문에 1개이다.",4
579,,,아래의 SQL문을 순차적으로 수행한 결괏값으로 올바른 것은?,,CREATE TABLE SQLD_29 (N1 NUMBER); INSERT INTO SQLD_29 VALUES(1); INSERT INTO SQLD_29 VALUES(2); CREATE TABLE TMP_SQLD_29 (N1 NUMBER); INSERT INTO TMP_SQLD_29 VALUES(1); TRUNCATE TABLE TMP_SQLD_29; ROLLBACK; COMMIT; SELECT SUM(N1) FROM SQLD_29;,4,3,1,,"CREATE, TRUNCATE 같은 DDL은 묵시적으로 COMMIT을 수행하므로 ROLLBACK 명령어를 수행하면 마지막 COMMIT을 수행한 6번째 행으로 이동한다.",2
580,,,다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?,,- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 - 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마,논리스키마,내부스키마,개념스키마,외부스키마,,3
581,,,아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?,,"가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다. 나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다. 다) 1:M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다. 라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.","가,나,다,라","가,나,다","가,나",가,,3
582,,,다음 중 아래와 같은 상황에서 사용할 수 있는 SQL 명령어는?,,"우리가 관리하는 데이터베이스의 ""매출"" 테이블이 너무나 많은 디스크 용량을 차지하여 ""매출” 테이블에서 필요한 데이터만을 추출하여 별도의 테이블로 옮겨 놓았다. 이후 ""매출"" 원본 테이블의 데이터를 모두 삭제함과 동시에, 디스크 사용량도 초기화 하고자 한다.(단, ""매출"" 테이블의 스키마 정의는 유지한다.)",DELETE TABLE FROM 매출;,DROP TABLE 매출;,DELETE FROM 매출;,TRUNCATE TABLE 매출;,,4
583,,,아래와 같은 결과가 나오도록 (ㄱ)에 알맞은 SQL문을 완성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j460-1.png,"SELECT 회원ID, DENSE_RANK() OVER(ORDER BY (ㄱ) ) AS RANK, 주문금액 FROM SQLD7;",주문금액 1,주문금액 ASC,(주문금액),(주문금액) DESC,결과 테이블은 주문금액이 큰 순서대로 순위를 부여하는 테이블로 주문금액 속성을 내림차순 정렬했을 때의 순위이고 같은 등수 다음에는 바로 다음 등수가 부여되었으므로 DENSE 랭크 함수가 들어가야 한다.,4
584,,,아래와 같이 테이블 및 데이터가 생성된 경우 추가 실행이 불가능한 문장은?,,"CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); INSERT INTO TAB1 VALUES(100, 100); COMMIT;",ALTER TABLE TAB1 DROP COLUMN COL4;,ALTER TABLE TAB1 MODIFY COL2 DEFAULT 100 NOT NULL;,ALTER TABLE TAB1 ADD COL5 NUMBER NOT NULL;,"ALTER TABLE TAB1 ADD (COL3 NUMBER, COL4 VARCHAR2(10));",새로운 컬럼 추가 시 기존 데이터의 새 컬럼 데이터는 NULL로 삽입된다. 따라서 DEFAULT 값 선언 없이는 NOT NULL 속성을 갖는 컬럼 추가는 불가능하다.,3
585,,,다음 주어진 테이블들에 대해서 아래의 SQL문을 수행한 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j466-1.png,SELECT COUNT(DISTINCT COL1) FROM test31_1 WHERE COL3= (SELECT COL3 FROM test31_2 WHERE COL2 = 'A'),4,3,2,1,서브쿼리는 COL2가 'A'인 것을 조회하므로 10이 나온다. 그리고 test31_1 테이블에서 COL3가 10인 것을 조회한다. 그러면 2건이 조회된다. 왜냐하면 DISTINCT는 COL1로 수행하므로 중복된 것이 없다.,3
586,,,주어진 테이블에서 아래의 SQL문과 다른 값을 반환하는 SQL문을 고르시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j283-1.png,"SELECT * FROM Mytest WHERE (COL1, COL2) IN (('x','y'),('kk','BB'))",SELECT * FROM Mytest WHERE (COL = 'x' or COL1 = 'KK') and (COL2 = 'y' or COL2 ='BB');,SELECT * FROM Mytest WHERE (COL1 = 'x' and COL2 = 'KK') or (COL1 = 'y' and COL2 ='BB');,SELECT * FROM Mytest WHERE (COL1 = 'x' and COL2 = 'y') or (COL1 = 'KK' and COL2 ='BB');,"SELECT * FROM Mytest WHERE NOT (COL1, COL2) in (('A', 'B'), ('x', 'KK'), ('a','b'),('1','2'), ('y','BB'));","위의 SQL문은 COL1과 COL2값으로 각각 (x,y),(KK,BB)를 갖는 행들이 반환되지만 ②번 보기는 COL1 과 COL2 값으로 각각 (x,KK),(y,BB)값을 갖는 행들이 반환된다.",2
587,,,아래의 SQL문을 수행하였을 때의 결과가 [결과]와 같을 때 이에 대한 설명으로 올바르지 않은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j421-1.png,"SELECT mgr, empno, ename, LEVEL, CONNECT_BY_ISLEAF, SYS_CONNECT_BY_PATH(ENAME,'-') ""PATH"" FROM limbest.EMP START WITH mgr is null Connect by prior empno = mgr;",LEVEL은 계층의 깊이를 의미하며 TEST1은 최상위 계층이다.,자식에서 부모로 가는 역방향이다.,"CONNECT_BY_ISLEAF는 LEAF이면 1을, 아니면 0을 반환한다.",EMPNO 1000번의 MGR은 NULL 값이다.,위의 계층형 조회는 최상위 계층에서 하위 계층으로 검색하는 정방향 조회이다.,2
588,,,"어느 기업의 직원 테이블(EMP)이 직급(GRADE)별로 사원 500명, 대리 100명, 과장 30명, 차장 10명, 부장 5명, 직급이 정해지지 않은(NULL) 사람 25명으로 구성되어 있을 때, 다음 중 SQL문을 SQL1)부터 SQL3)까지 순차적으로 실행한 결과 건수를 순서대로 나열한 것은?",,"SQL1) SELECT COUNT(GRADE) FROM EMP; SQL2) SELECT GRADE FROM EMP WHERE GRADE IN('차장', '부장', '널'); SQL3) SELECT GRADE, COUNT(*) FROM EMP GROUP BY GRADE;","670, 40, 6","645, 15, 6","645, 40, 5","670, 15, 5",SQL1) 645건 : 사원 500명 + 대리 100명 + 과장 30명 + 차장 10명 + 부장 5명 SQL2) 15건 : 차장10명 + 부장 5명 SQL3) 6건 : 5개 직급 + NULL,2
589,,,아래 SQL의 실행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j691-1.png,SELECT SUM(COL2 + COL3) FROM TAB1 WHERE COL1 IS NOT NULL;,33,12,,0,"COL1이 NULL이 아닌 값은 위의 세 행인데, 이들의 COL2+COL3의 값은 순서대로 NULL, 12, NULL이 된다. 따라서 총합은 12가 출력된다.",2
590,,,다음 보기가 설명하는 3층 스키마는 무엇인가?,,-사용자 관점 또는 사용자 뷰를 표현한다. -업무상 관련이 있는 데이터만 접근(권한 설정)한다. -관련된 데이터베이스의 일부만 표시한다.,논리 스키마,내부 스키마,개념 스키마,외부 스키마,,4
591,,,주어진 테이블들에 대해서 아래의 SQL문을 수행하였을 때 반환되는 ROW값의 수는 얼마인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j452-1.png,SELECT * FROM TEST1 UNION ALL SELECT * FROM TEST2 MINUS SELECT * FROM TEST3;,5,4,3,2,UNION ALL에 의해서 총 9개의 행이 반환된다. 그리고 MINUS로 차집합을 만든다.,1
592,,,다음 주어진 데이터에서 해당 SQL문을 실행 했을 때의 결괏값으로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j536-1.png,"SELECT A, SUM(X) AS TAB FROM TABLE_B GROUP BY A;",,,,,A 칼럼별로 그룹화하고 집계 함수에서 NULL값을 제외하고 연산을 수행한다.,2
593,,,아래 SQL 수행 결과로 가장 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j644-1.png,"SELECT COL1 FROM TAB1 ORDER BY CASE WHEN MOD(COL2, 3) = 0 THEN 'A' ELSE 'B' END, COL1;",,,,,"CASE문 결과를 1차 정렬로 한 뒤, 이 값이 같을 경우 COL1의 값으로 2차 정렬을 수행한다. 이렇게 정렬된 COL1의 값은 SCOTT, ALLEN, FORD, SMITH 순으로 출력된다.",3
594,,,다음 설명에 해당하는 속성의 종류는 무엇인가?,,"ABC 온라인 쇼핑몰은 매일 고객들의 주문정보를 주문 릴레이션에 저장하고 있다. 그리고 매일 24시에 주문 릴레이션에 있는 금액을 조회하여 일별 주문합계 테이블에 상품별, 일별, 주문합계 금액을 보관한다. 이때 주문 릴레이션의 금액 속성에 의해서 발생된 주문합계 속성은 무엇이라고 하는가? 또한 주문합계 속성은 금액 속성과 데이터 정합성을 유지해야 한다.",연관 속성,설계 속성,기본 속성,파생 속성,"속성의 종류는 기본 속성, 설계 속성, 파생 속성이 있으며, 본 문제에서 금액은 기본속성에 해당되고 기본 속성의 계산이나 변형으로 새롭게 만들어진 주문합계는 파생 속성이 된다.",4
595,,,아래의 SQL문에 대한 설명으로 올바른 것은?,,SELECT * FROM EMP WHERE EMP_NAME LIKE 'K%';,테이블의 EMP_NAME이 A 또는 a로 끝나는 모든 행이 검색된다.,테이블의 EMP_NAME이 K로 끝나는 모든 행이 검색된다.,테이블의 EMP_NAME이 K로 시작하는 모든 행이 검색된다.,테이블의 EMP_NAME이 K 또는 k로 시작하는 모든 행이 검색된다.,LIKE문의 'K%'는 K로 시작하는 모든 행을 검색하는 것이다.,3
596,,,다음 SQL 수행 결과로 가장 적절한 것은?,,"SELECT ROUND(TO_DATE('2024-02-20 14:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'MONTH') AS D1, TRUNC(TO_DATE('2024-09-12 09:00:00', 'YYYY-MM-DD HH24:MI:SS')) AS D2 FROM DUAL;",,,,,"ROUND와 TRUNC는 각각 날짜의 반올림과 버림을 수행할 수 있다. 두 번째 인수 생략 시 ""일"" 단위로의 반올림/버림이 진행되며, 'MONTH'의 경우 ""월"" 단위로의 반올림/버림이 진행된다. 즉, ""일"" 단위에서 반올림을 진행하게 된다.",2
597,,,다음 서브쿼리 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j699-1.png,SELECT SUM(SAL) FROM EMP WHERE HIREDATE > (SELECT HIREDATE FROM TAB1 WHERE NAME = 'JAMES');,6900,5400,4100,3800,"JAMES의 입사일보다 늦게 입사한 직원들의 급여 총 합을 구하는 문제이다. JAMES의 입사일인 1981/10/03 보다 늦게 입사한 직원은 ADAMS, FORD, MILLER 이며 이들의 급여 총합은 5400이다.",2
598,,,다음 SQL의 수행 결과로 알맞은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j637-1.png,"SELECT ISNULL(COL1, 3) FROM TAB1;",,,,,"ISNULL(대상, 대체값) 함수는 대상이 NULL이면 대체값으로 치환하는 함수로서 COL1이 NULL이면 3으로 대체하라는 쿼리이기 때문에 1,2,3,3이 나오게 된다.",3
599,,,다음 SQL 실행 결과로 알맞은 것은?,,"SELECT LENGTH(REGEXP_REPLACE('REGEXP \. ESCAPE CHARACTER, A|B : A OR B', '[A-z|0-9\. ]')) FROM DUAL;",5,4,3,2,"[A-z|0-9\. ] 패턴은 영문 또는 | 또는 숫자 또는 \ 또는 . 그리고 공백을 모두 지칭하는 패턴이다. 따라서 이들을 모두 지우면 ,과 :만 남게 된다.",4
600,,,다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?,,"CREATE TABLE TAB1( COL1 VARCHAR(10) PRIMARY KEY, COL2 NUMBER NOT NULL, COL3 CHAR(10) NOT NULL, COL4 DATE NOT NULL);","INSERT INTO TAB1 VALUES('0003', 40, 'CCC', '2024/01/01');","INSERT INTO TAB1 VALUES('0002', '30', '1000', CURRENT_DATE);","INSERT INTO TAB1 VALUES('0001', '20', 'BBB', SYSTIMESTAMP);","INSERT INTO TAB1 VALUES(1, 10, 'AAA', SYSDATE);",1번에서 COL4의 값은 문자상수이므로 날짜 변환 후 입력을 해야 한다. DBMS의 기본 날짜 포맷이 YYYY/MM/DD가 아닌 경우는 이 문장은 에러가 발생한다.,1
601,,,"테이블 A, B, C가 있다. 다음 중 DELETE FROM A 쿼리를 수행한 후에 테이블 C 테이블에 남아 있는 데이터로 가장 올바른 것은?",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j347-1.png,"CREATE TABLE A (C INTEGER PRIMARY KEY, D INTEGER); CREATE TABLE B (B INTEGER PRIMARY KEY, C INTEGER REFERENCES A(C) ON DELETE CASCADE); CREATE TABLE C (A INTEGER PRIMARY KEY, B INTEGER REFERENCES B(B) ON DELETE SET NULL);","(1,1)","(2,2)","(1,NULL)과(2,NULL)","(1,NULL)과(2,2)",DELETE FROM A 이후 A 테이블은 모두 삭제된다. C 테이블은 Cascade 옵션에 의해서 A의 첫번째 행을 참조하는 두 건 모두 삭제된다. 그리고 B 테이블이 삭제됨에 따라 B 테이블의 B칼럼을 참조하는 C 테이블의 B 칼럼값은 SET NULL 옵션에 의해서 NULL 값으로 변경된다.,3
602,,,다음은 데이터베이스 모델링에 대한 설명으로 가장 올바른 것은?,,"증권회사에서 주문을 발주할 때 해당 종목에 대한 호가단위가 있다. 즉, 주문은 10호가를 기준으로 발주할 수가 있어서 어떤 종목을 주문할 때 1003원과 같은 금액으로는 발주할 수 없다. 이처럼 데이터베이스에서 값이 가질 수 있는 조건을 정의하는 것이다.",도메인,선텍도,다중 값 속성,시스템 카탈로그,도메인은 속성이 가질 수 있는 값의 범위이다.,1
603,,,다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?,,"모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.",업무에서 처리하는 일의 방법에 따라 데이터가 어떻게 영향을 받는지 분석,업무를 처리할 수 있는 프로그램 구성을 어떻게 해야 하는지 분석,업무에서 실제로 하는 일은 무엇인지 또는 무엇을 해야 하는지 분석,업무가 어떤 데이터와 관련이 있는지 분석,"모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.",2
604,,,다음은 식별자의 특징 중 무엇을 설명하고 있는가?,,사원번호 없는 회사직원은 있을 수 없음,존재성,불변성,최소성,유일성,존재성이란 주식별자가 지정되면 반드시 값이 존재해야 하며 널을 허용하지 않는 특성을 말한다. 따라서 사원 번호가 없을 수 없다는 것은 널을 허용하지 않는 특징이므로 존재성에 해당한다.,1
605,,,아래 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j740-1.png,SELECT COUNT(COL1) FROM TAB1 WHERE NOT EXISTS(SELECT 'X' FROM TAB2 WHERE TAB1.COL2 = TAB2.COL2);,4,3,2,1,"NOT EXISTS는 서브쿼리 조건이 거짓인 경우 메인쿼리의 결과가 출력된다. 따라서 TAB2의 COL2와 일치하지 않는 값은 1이며, NULL은 TAB1과 TAB2가 모두 존재하지만 EQUAL(=) 연산 결과가 항상 거짓이므로, NOT EXISTS에 의 해 출력된다. 따라서 COUNT 결과는 2이다.",3
606,,,다음 SQL문의 실행 결과는 무엇인가?,,"SELECT COALESCE(NULL,'2','1') FROM DUAL;",,3,2,1,"COALESCE 함수는 NULL이 아닌 첫 번째 값을 리턴하는 함수이다. 즉, 위의 문제에서 첫 번째는 NULL이고 두 번째는 '2'이다. 따라서 '2'가 리턴된다.",3
607,,,다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?,,주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.,존재성,단일성,최소성,유일성,주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성하는 특성은 최소성이다.,3
608,,,다음이 설명하는 데이터 무결성의 종류는?,,테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.,NULL 무결성,도메인 무결성,참조 무결성,개체 무결성,"개체 무결성에 대한 설명이다. 참조 무결성은 왜래키 값이 NULL이거나 참조 테이블의 기본키 값과 동일해야 하는 특성이고, 도메인 무결성은 주어진 속성 값이 정의된 도메인에 속한 값이어야 하는 특성을 말한다. NULL 무결성은 특정 속성에 대해 NULL을 허용하지 않는 특징을 의미한다.",4
609,,,아래 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j696-1.png,SELECT COUNT(TAB1.COL1) AS CNT FROM TAB1 LEFT OUTER JOIN TAB2 ON TAB1.COL2 = TAB2.COL2 AND TAB1.COL1 = TAB2.COL1;,6,5,4,3,,2
610,,,다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?,,부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계,선택관계,필수관계,비식별관계,식별관계,부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계는 식별관계이다.,4
611,,,다음 중 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항을 모두 고른 것은?,,"가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가? 나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가? 다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가? 라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb) 가 있 는가?","가,나다,라","가,나,다","가,나,라","가,다,라",,1
612,,,다음 2개의 SQL문이 같은 결과를 조회할 수 있도록 빈칸을 작성하시오.,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j438-1.png,"SELECT ProductName, SUM(Price) FROM Mytest WHERE ProductName = '비디오' GROUP BY ROLLUP(ProductName); SELECT ProductName, SUM(Price) FROM Mytest WHERE ProductName = '비디오' GROUP BY GROUPING SETS( );","ProductName, ()","ProductName, Price",(),ProductName,두 SQL문은 모두 ProductName '비디오'에 대한 집계이다. ProductName '비디오' 에 대한 전체 합계가 조회되어야 한다.,1
613,,,다음 SQL문의 실행 결과는 무엇인가?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j520-1.png,"SELECT AVG(NVL(COL2,0)) FROM test48;",25,24,23,22,NVL 함수로 NULL은 0으로 대체되고 평균이 계산된다.,2
614,,,다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?,,"테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.",DROP,ALTER,GRANT,CREATE,,3
615,,,주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?,,"SELECT JOB, COUNT(*) AS ROWCNT FROM TEST40 GROUP BY JOB;",ORDER BY 3,ORDER BY COUNT(*),ORDER BY CNT DESC,ORDER BY JOB,"지문의 SQL문은 SELECT구에 칼럼(JOB,ROWCNT)이 2개 있다. ①번은 칼럼의 수가 2개뿐인데 3번째 칼럼이 존재하지 않기 때문에 사용할 수 없다.",1
616,,,다음 중 아래 SQL문의 결괏값으로 올바른 것은?,,"SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;",67,65,43,45,"substr 함수의 입력값에 음수를 주면 뒤에서 시작하게 된다. 즉, 뒤에서 4번째 자릿값인 6부터 두 개의 글자인 67이 반환된다.",1
617,,,주어진 데이터에서 아래의 SQL문을 수행된 결과로 옳은 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j451-1.png,"SELECT COALESCE(COL1, COL2 * 50,50) FROM sqld_12;",,,,,COALESCE 함수는 함수 내 비교식에서 NULL 값이 아닌 값으로 연산을 수행한다.,4
618,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j694-1.png,"SELECT EMPNO FROM EMP ORDER BY TO_CHAR(TO_NUMBER(SUBSTR(JUMIN, 3, 2)));",,,,,"SUBSTR(JUMIN, 3, 2)은 태어난 월을 추출하기 때문에, 순서대로 12, 11, 06, 01, 08의 문자 유형으로 출력된다. 이를 TO_NUMBER를 사용하여 숫자 형태로 변환하면 12, 11, 6, 1, 8이 되는데, 이를 다시 TO_CHAR로 변환하게 되면 문자값의 비교 규칙에 따라 1 < 11 < 12 < 6 < 8 순서대로 출력된다. (문자는 가장 왼쪽부터 비교하여 값이 작을수록 작은값이 된다)",3
619,,,다음의 SQL문을 CASE문을 사용해서 변경하시오.,,"SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;",SELECT CASE EMPNO WHEN 'A' ELSE 'B' END FROM EMP;,SELECT CASE EMPNO WHEN 1 THEN 'B' ELSE 'A' END FROM EMP;,SELECT CASE EMPNO WHEN 1 THEN 'A' ELSE 'B' END FROM EMP;,SELECT CASE EMPNO WHEN 'A' THEN 'B' END FROM EMP;,위의 DECODE문은 EMPNO가 1과 같으면 'A'를 출력하고 그렇지 않으면 'B'를 출력한다.,3
620,,,다음이 설명하는 모델링 개념으로 가장 적절한 것은?,,"사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로 전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.",내부 스키마,논리 스키마,개념 스키마,외부 스키마,"스키마의 3단계 구조인 외부, 개념, 내부 스키마 중 개념 스키마에 대한 설명이다.",3
621,,,"날짜값을 2020, 02와 같이 조회되도록 SQL문을 완성하시오.",https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j356-1.png,"SELECT EXTRACT (YEAR FROM SYSDATE), LPAD(EXTRACT(month from sysdate), (ㄱ), (ㄴ)) FROM Mytest;","ㄱ : 2, ㄴ : '0'","ㄱ : 2, ㄴ : '2'","ㄱ : 1, ㄴ : '2'","ㄱ : 1, ㄴ : '0'",COL1 값에서 Month값이 1이 두 자릿수 01로 출력되어야 하므로 LPAD 함수의 두 번째 인자 값에는 숫자 2이다. 세 번째 인자 값에는 문자 '0'이 와야 한다.,1
622,,,아래 각각 3개의 SQL 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j393-1.png,SELECT AVG(COL3) FROM SQLD01; SELECT AVG(COL3) FROM SQLD01 WHERE COL1 > 0; SELECT AVG(COL3) FROM SQLD01 WHERE COL1 IS NOT NULL;,"10, 10, 10","10, 20, 20","20, 10, 10","20, 20, 20","이 문제의 핵심은 그룹 함수(SUM, AVG, MAX, MIN)는 실행 시에 NULL이 제외된다는 것이다.",2
623,,,다음 개념에 해당하는 관계는 무엇인가?,,"부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.",외부 식별 관계,일반 속성 관계,비식별자 관계,식별자 관계,부모 엔터티로부터 속성을 받았지만 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 것은 비식별자 관계에 대한 설명이다.,3
624,,,다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은?,,"학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다.",속성사전,시스템카탈로그,릴레이션,도메인,도메인은 속성값이 갖는 범위를 의미한다.,4
625,,,다음 SQL문을 실행했을 때 오류가 발생하는 것은?,,"CREATE TABLE T_ORDER( C1 NUMBER(10), C2 DATE, C3 VARCHAR(10), C4 NUMBER DEFAULT 1000 );",UPDATE T_ORDER SET C1=1,DELETE FROM T_ORDER,DELETE T_ORDER,"INSERT INTO T_ORDER VALUES(2, SYSDATE-1, 'ABC')",④번 보기는 T_ORDER 테이블명 뒤에 특정 속성들을 지정하지 않았다. VALUES 뒤에는 테이블의 전체 속성값들이 부여되어야 하는데 VALUES 뒤에 속성값 중 하나가 모자라 에러가 뜬다.,4
626,,,아래 SQL의 결과로 가장 적절한 것은?,,"SELECT ROUND(TO_DATE('2024-08-24 12:00:00','YYYY-MM-DD HH24:MI:SS')) COL1, ROUND(TO_DATE('2024-08-24 12:00:01','YYYY-MM-DD HH:MI:SS')) COL2 FROM DUAL;",,,,,"HH24는 24시간 표현식이고, HH는 12시간 표현식이다. 시간은 정오를 기준으로 반올림 시 자리수가 바뀌는데, 둘 다 정오를 나타내므로 반올림 시 “일(DAY)”의 자리가 바뀌며 24년 8월 25일이 리턴된다.",3
627,,,다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?,,"s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)",주소,이름,환자,병원,,3
628,,,다음의 ERD에서 식별자 분류로 올바른 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j448-1.png,고객마스터 테이블의 고객번호는 대표성에 따른 식별자 분류로는 (ㄱ)이고 스스로 생성했는지 여부에 따라서는 (ㄴ)이다. 또한 계좌마스터의 고객번호는 스스로 생성 여부에 따라서 (ㄷ)이다.,"ㄱ-내부식별자, ㄴ-단일식별자, ㄷ-보조식별자","ㄱ-보조식별자, ㄴ-내부식별자, ㄷ-외부식별자","ㄱ-주식별자, ㄴ-내부식별자, ㄷ-외부식별자","ㄱ-보조식별자, ㄴ-외부식별자, ㄷ-단일식별자",식별자는 대표성에 따라서 주식별자와 보조식별자로 분류되고 생성 여부에 따라서는 내부 식별자와 외부 식별자로 분류된다. 또한 속성의 수에 따라서 단일 식별자와 복합 식별자로 분류된다.,3
629,,,데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?,,-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다. -전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.,추상적 데이터 모델링,개념적 데이터 모델링,논리적 데이터 모델링,물리적 데이터 모델링,"-전시적 관점에서 기업의 데이터를 모델링한다. -추상화 수준이 가장 높은 모델링이다. -계층형 데이터 모델, 네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링을 한다.",2
630,,,다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?,,UPDATE A_User.TB_A SET col1='AAA' WHERE col2=3,"GRANT SELECT, UPDATE ON A_User.TB_A TO B_User;",DENY UPDATE ON A_User.TB_A TO B_User;,REVOKE SELECT ON A_User.TB_A FROM B_User;,"GRANT SELECT, UPDATE TO B_User;","권한을 부여하는 명령어는 GRANT이며, WHERE 조건의 데이터를 찾기 위한 SELECT 권한과 데이터 변경을 위한 UPDATE 권한이 필요하다.",1
631,,,다음 SQL 실행 결과로 가장 적절한 것은?,,"SELECT REGEXP_SUBSTR('123-234-4545-233', '((\d+)-(\d+))-((\d+)-(\d+))', 1, 1, NULL, 4) FROM DUAL;",4545,4545-233,234,233,서브그룹을 추출하는 문제이다. 서브그룹 순서는 ((A)-(B))-((C)-(D))에서 A-B -> A -> B -> C-D -> C -> D 순서대로 정해진다. 따라서 4번째 서브그룹은 뒤에 두 숫자집합의 결합인 4545-233 가 된다.,2
632,,,다음 중 아래 설명이 의마하는 데이터모델링의 유의점에 해당히는 특성은 무엇인가?,,데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.,일관성,비일관성,비유연성,중복,,3
633,,,"다음 중 아래 데이터모델링 개념에 대한 설명에서 (ㄱ),(ㄴ) 에 들어갈 단어로 가장 적절한 것은?",,"전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링을 진행하는 것을 (ㄱ) 데이터 모델링 이라고 한다. 이와 달리 실제로 데이터베이스에 이식 할 수 있도록 성능, 저장 등의 물리적인 성격을 고려한 데이터 모델링은 (ㄴ) 데이터모델링 이라고 한다.","ㄱ - 개념적, ㄴ - 논리적","ㄱ - 논리적, ㄴ - 물리적","ㄱ - 논리적, ㄴ - 개념적","ㄱ - 개념적, ㄴ - 물리적",,4
634,,,다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?,,"주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.",도메인(Domain),속성사전(Attribute Dictionary),용어사전(Word Dictionary),시스템카탈로그(System Catalog),,1
635,,,다음이 설명하는 모델링의 특징으로 가장 적절한 것은?,,누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것을 의미한다.,그룹화,단순화,추상화,명확화,"모델링의 특징은 단순화, 추상화, 명확화가 있다. 이 중 누구나 이해하기 쉽게 대상에 대한 애매모호함을 제거하고 정확하게 기술하는 것은 명확화에 해당된다.",4
636,,,다음 수행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j758-1.png,"SELECT SUM(SAL) FROM (SELECT ENAME, DEPTNO, SAL, NTILE(2) OVER(PARTITION BY DEPTNO ORDER BY SAL) AS GN FROM EMP) WHERE (DEPTNO = 10 AND GN = 1) OR (DEPTNO = 20 AND GN = 2);",10275,9750,8625,7300,"그룹으로 나눌 때 명학히 나눠지지 않으면 앞 그룹의 크기를 더 크게 나누므로 10번 부서의 1번 그룹원은 MILLER, CLARK이며, 20번 부서의 2번 그룹원은 SCOTT과 FORD 이므로 1300 + 2450 + 3000 + 3000 = 9750 이 된다.",2
637,,,다음이 설명하는 정규화로 가장 적절한 것은?,,테이블의 컬럼이 원자성(한 속성이 하나의 값을 갖는 특성)을 갖도록 테이블을 분해하는 단계,제 4 정규화,제 3 정규화,제 2 정규화,제 1 정규화,제 1 정규화는 한 속성이 하나의 값을 갖도록 이를 분해하는 단계를 말한다.,4
638,,,다음은 데이터베이스 파티션 기법에 대한 설명이다. 보기에서 설명하고 있는 파티션 기법은 무엇인가?,,-파티셔닝 할 항목을 관리자가 직접 지정하는 방법으로 제품에 대해서 파티션을 생성하였다. -데이터 보관 주기에 따라서 쉽게 데이터를 삭제할 수 없다.,HYBRID PARTITION,LIST PARTITION,HASH PARTITON,RANGE PARTITION,Range Partition은 데이터 값의 범위를 기준으로 파티션을 수행하고 List Partition은 특정 값을 지정해서 파티션을 수행한다. 또한 Hash Partition은 해시 함수를 적용하여 파티션을 수행하는 것이다. Composite Partition은 범위와 해시를 복합적으로 사용해서 파티션을 수행한다.,2
639,,,다음이 설명하는 용어로 가장 적절한 것은?,,"데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.",키,튜플,도메인,릴레이션,도메인은 엔터티에서의 각 속성에 허용되는 값의 범위를 의미한다.,3
640,,,다음 SQL 실행 결과로 가장 적절한 것은?,https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j739-1.png,"SELECT SUM(NULLIF(COL1,100) + COL2) FROM TAB1;",600,500,400,300,"NULLIF(COL1, 100)은 COL1 값이 100이면 NULL을 리턴하고, 같지 않으면 COL1값을 리턴한다. 따라서 COL1값은 순서대로 NULL, NULL, 200이 리턴되므로 COL2와의 합은 순서대로 NULL, NULL, 300이 되어 총 300이 출력된다.",4
641,2과목,집계 함수,,,"SELECT COUNT(COL1)
FROM TAB1 WHERE REGEXP_LIKE(COL1, '[XY-]+Z?');",5,4,3,2,,"1 [XY-]는 X 또는 Y 또는 -와 같다. 따라서 X, Y, - 중 하나가 여러 번 반복되면서 그 뒤에 Z값이 오거나 오지 않는 문자열 배열을 갖는 행은 전체이므로 총 5개가 출력된다."
642,2과목,집합 연산자,,,"SELECT SUM(C1+C2+C3+C4) FROM Mytest7
UNION ALL
SELECT SUM(C1) + SUM(C2) + SUM(C3) + SUM(C4)
FROM Mytest17;","NULL, NULL","50, 260","NULL, 260","50, NULL",,"2 1번째 경우는 4개의 칼럼(C1,C2,C3,C4)모두 NULL이 아닌 값을 가지는 행에 대해서만 합계가 계산되므로 첫 번째 행에서의 칼럼들의 합계만 계산된다. 2번째 경우는 4개의 칼럼에 대해서 각각의 합계가 계산되고 이후에 각 합계들의 최종적인 합계가 계산된다."
643,2과목,조인,,,"SELECT e.dno, d.dname, e.ename, e.score
FROM employee e, department d
WHERE e.dno = d.dno and (e.dno, score) IN
(SELECT dno, max(score)
FROM employee GROUP BY dno);","{(100,영업,Hong,80), (100,영업,Lee,90),(200,개발,Kim,90),(200,개발,Kim,95),(600,null,Hong,65)}","{(100,영업,Lee,90)}","{(100,영업,Lee,90),(200,개발,Kim,95)}","{(100,영업,Lee,90),(200,개발,Kim,90),(300,서비스,Hong,65)}",,"4 서브쿼리만 실행하면 DNO와 MAX(SCORE) 값이 {100,90},{300,65},{200,95} 이다. IN 문을 사용해서 조인을 하므로 {(100,영업,Lee,90),(200,개발,Kim,95),(300,서비스,Hong,65)}가 조회된다."
644,2과목,그룹 함수,,,"SELECT A.JUMIN, B.CUSTRANK
FROM (SELECT JUMUN, SUM(price)
AS TOTAL,
FROM T_ORDER
GROUP BY JUMUN) A, T_CUST B
WHERE 1=1
AND A.TOTAL BETWEEN B.MINPRICE AND B.MAXPRICE;",,,,,,4 위의 SQL문은 1번째 테이블에서 주문자별로 grouping 하였을 때 각 주문자별로 주문금액의 합계를 계산하고 그 값이 두 번째 테이블의 실적범위에 해당하는 곳에서 고객등급과 주문자 정보를 조회한다.
645,,,,,"SELECT *
FROM Mytest
START WITH ( ㄱ ) IS NULL
CONNECT BY PRIOR ( ㄴ )
AND today BETWEEN '2017-01-01' AND '2022-12-31'
ORDER SIBLINGS BY empid;",(ㄱ) mgrid (ㄴ) mgrid = empid,(ㄱ) mgrid (ㄴ) empid = mgrid,(ㄱ) empid (ㄴ) mgrid = empid,(ㄱ) empid (ㄴ) empid = mgrid,,2 mgrid가 NULL인 값을 시작해서 empid로 조회를 전개하는 순방향 조회를 하고 있다. 순방향 전개를 하면서 empid로 정렬한다.
646,,,,,"SELECT COUNT(C1)
FROM Mytest",4,3,2,1,,2 COUNT(C1)은 NULL 값은 제외된다. 따라서 3개가 된다.
647,,,,,"SELECT DEPTNO, JOB, SUM(SAL)
FROM T_TEST
GROUP BY ( );","CUBE(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","GROUPING SETS(DEPTNO, JOB)","DEPTNO, JOB",,"2 집계결과는 DEPTNO별 합계, JOB별 합계, DEPTNO 및 JOB별 합계, 전체합계가 조회되고 Rollup이 와야 한다."
648,,,,,"SELECT
( ) OVER(ORDER BY SAL DESC)
AS RANK, NAME, DEPTNAME, POSITION,
SAL
FROM TEST44;",NTILE(),ROW_NUMBER(),DENSE_RANK(),RANK(),,4 RANK() 함수는 동일한 점수면 같은 등수를 부여한다.
649,,,,,"SELECT SUM(SAL)
FROM EMP
WHERE HIREDATE > (SELECT HIREDATE
FROM TAB1
WHERE NAME = 'JAMES');",6900,5400,4100,3800,,"2 JAMES의 입사일보다 늦게 입사한 직원들의 급여 총 합을 구하는 문제이다. JAMES의 입사일인 1981/10/03 보다 늦게 입사한 직원은 ADAMS, FORD, MILLER 이며 이들의 급여 총합은 5400이다."
650,,,,,"INSERT INTO TAB1 VALUES(5, 'E', 3);
COMMIT;
UPDATE TAB1 SET COL2 = 3 WHERE NO = 2;
SAVEPOINT SAVE1;
INSERT INTO TAB1 VALUES(6, 'F', 5);
DELETE TAB1 WHERE NO = 4;
ROLLBACK TO SAVE1;
UPDATE TAB1 SET COL2 = 2 WHERE NO = 1;
ROLLBACK;
COMMIT;
SELECT SUM(COL2) FROM TAB1;",13,12,11,8,,"3 첫 INSERT문장은 COMMIT했기 때문에 영구 저장된다. 그 이후 UPDATE, INSERT, DELETE를 차례대로 하지만 SAVE1 지점으로 롤백하므로 INSERT와 DELETE는 실행 취소된다. 첫 UPDATE문장과 마지막 UPDATE문장은 모두 롤백되어 결과적으로는 첫 INSERT문장만 실행된다. 따라서 남은 행의 SUM(COL2) 결과는 11이다."
651,,,,,"SELECT 주문번호, 일자,
SUM(주문금액) OVER(ORDER BY 일자) AS 주문금액,
DENSE_RANK() OVER(PARTITION BY 지점 ORDER BY 주문금액) AS 순위
FROM 주문내역;",,,,,,"2 SUM의 경우 ORDER BY 사용 시 ORDER BY 컬럼 순서대로 누적 합을 계산하는데, 이때 범위는 RANGE가 기본이다. RANGE란 ORDER BY 절에 명시된 컬럼의 값이 같을 경우 하나의 그룹으로 묶어서 누적 합을 계산하는 범위를 말한다. 따라서 2024.01.02 값이 두 개이므로 각각 1000과 2000이 먼저 3000으로 결합되어 두 번째와 세 번째 행의 누적 합이 둘 다 4000이 된다. DENSE_RANK의 경우 동순위 발생 뒤 순위가 연속적으로 출력되므로 주문번호가 3인 행의 순위는 2위가 된다."
652,,,,,"BEGIN TRANSACTION;
SAVE TRANSACTION SP1;
UPDATE 상품마스터 SET 상품명 = 'LG-TV'
WHERE 상품ID ='001';
SAVE TRANSACTION SP2;
UPDATE 상품마스터 SET 상품명 = '평면-TV' WHERE 상품ID = '001';
ROLLBACK TRANSACTION SP2;
COMMIT;",없음,TV,평면-TV,LG-TV,,"4 ROLLBACK TRANSACTION SP2 문장에 의해 UPDATE 상품 SET 상품명 = '평면-TV' WHERE 상품ID = '001'이 ROLLBACK 되었고, 첫 번째 UPDATE 문장만 유효한 상태에서 COMMIT 되었으므로 첫 번째 UPDATE한 내역만 반영된다. 그러므로 LG-TV가 된다."
653,,,,,"(1)
SELECT A ID, B.ID
FROM MytestA A FULL OUTER JOIN
MytestB B
ON A.ID = B.ID

(2)
SELECT A ID, B.ID
FROM MytestA A LEFT OUTER JOIN
MytestB B
ON A.ID = B.ID
UNION
SELECT A ID, B.ID
FROM MytestA A RIGHT OUTER JOIN
MytestB B
ON A.ID = B.ID

(3)
SELECT A ID, B.ID
FROM MytestA A, MytestB B
WHERE A.ID = B.ID
UNION ALL
SELECT A.ID, NULL FROM MytestA A
WHERE NOT EXISTS (SELECT 1 FROM
MytestB B WHERE A.ID = B.ID)
UNION ALL
SELECT NULL, B.ID
FROM MytestB B
WHERE NOT EXISTS (SELECT 1 FROM
MytestA A WHERE B.ID = A.ID)","1,2,3","2,3","1,3","1,2",,"1 보기 3개 모두 FULL OUTER JOIN과 동일한 결과를 반환한다. 즉, 교집합과 MytestA 및 MytestB의 차집합 모두가 조회된다."
654,,,,,"SELECT COUNT(*)
FROM limbest.emp
WHERE JOB = 'CLERK'
OR (ENAME LIKE 'T%' AND SAL >= 3000);",8건,7건,6건,5건,,"2 ENAME은 모두 ""T""로 시작한다. 따라서 SAL이 3000이상인 사람이 3건이고 JOB이 ""CLERK""은 4건이다. 따라서 총 7건이 조회된다."
655,,,,,"SELECT COUNT(*) FROM TEST39 GROUP BY COL1
HAVING COUNT(*)>2;",6,5,3,,,"3 COL1 칼럼으로 GROUP BY를 할 경우 행 수가 2건 보다 많은 것은 4,5,6행이다."
656,,,,,"SELECT COUNT(*) AS RESULT FROM TAB1 WHERE COL1 = 200 GROUP BY COL1;
SELECT SUM(COL2) AS RESULT FROM TAB1 WHERE COL1 = 100;
SELECT COUNT(COL1) AS RESULT FROM TAB1 WHERE COL3 = 400;",,,,,,"1 첫 번째 문장은 COL1 = 200 조건에 만족하는 값이 없고, 공집합을 GROUP BY 하면 아무것도 출력되지 않는다. 따라서 공집합에 대한 COUNT 결과는 0 이 아닌 공집합이 출력되므로 컬럼명만 출력되는 형태로 리턴된다. 두 번째 문장은 첫 번째 행에 대한 SUM(COL2)를 출력하게 되는데, 첫 번째 행의 COL2 값이 NULL 이므로 NULL 이 출력된다. NULL 로만 구성된 데이터의 SUM, AVG, MIN, MAX 등의 결과는 NULL 이 리턴되며 COUNT 만 0 으로 출력된다. 따라서 세 번째 문장의 출력값은 0 이 된다."
657,,,,,"SELECT CASE
WHEN C1=1 THEN 10
WHEN C1=2 THEN 20
ELSE C1 END
FROM Mytest;","1,2,30","10,20,30","10,20,3","1,2,3",,3 CASE 문의 조건문에 따라서 1은 10으로 2는 20으로 입력된다.
658,,,,,"SELECT DNAME,
FIRST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE1,
LAST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE2
FROM TAB1;",,,,,,"1 FIRST_VALUE, LAST_VALUE는 ORDER BY 컬럼 순서대로 범위 내 가장 처음 값과 마지막 값을 리턴하는 함수인데, 이때 기본 범위는 RANGE UNBOUNDED PRECEDING AND CURRENT ROW이다. 따라서 같은 DNAME 내 SAL 순서대로 가장 앞에 있는 이름은 아시아지부의 경우 홍길동, 남유럽지부의 경우 김길동이 된다. 하지만 각 행마다 LAST_VALUE를 구할 때 범위가 처음부터 현재 행까지만 고려해서 마지막 값을 리턴하기 때문에 항상 현재 행의 값이 마지막 값이 되므로 각 행의 값이 리턴된다."
659,,,,,"SELECT COUNT(TAB1.COL1) AS CNT
FROM TAB1 LEFT OUTER JOIN TAB2
ON TAB1.COL2 = TAB2.COL2
AND TAB1.COL1 = TAB2.COL1;",6,5,4,3,,2
660,,,,,"SELECT NO,
RANK() OVER(ORDER BY JUMSU DESC) AS RANK1,
DENSE_RANK() OVER(ORDER BY JUMSU DESC) AS RANK2,
ROW_NUMBER() OVER(ORDER BY JUMSU DESC) AS RANK3
FROM STUDENT;",,,,,,"3 RANK는 동점일 경우 같은 등수로 표시하고 다음 순위는 동점인 순위의 수만큼 밀리므로 12245가 출력되지만 DENSE_RANK는 동점일 경우 동순위를 부여 뒤, 다음 순위가 바로 이어지므로 12234가 리턴된다. ROW_NUMER는 동점일 경우를 인정하지 않고 순서대로 나열하므로 12345가 최종 출력된다."
661,,,,,"SELECT COUNT(DATA1), COUNT(DATA2)
FROM (SELECT DISTINCT DATA1, DATA2 FROM Mytest);","1,1","2,2","2,1","1,3",,"2 인라인 뷰에 있는 DISTINCT구는 중복을 제거하기 때문에 1,A 와 1,B 두개의 행이 조회된다. 따라서 행 수를 계산하는 COUNT는 2,2가 조회된다."
662,,,,,"SELECT C1, C2,
CASE
WHEN C2 <= 100 THEN 'B'
WHEN C2 <= 300 THEN 'A'
ELSE 'S'
END GRADE
FROM test19
ORDER BY C2;",,,,,,"4 C2 값으로 오름차순 정렬하고 CASE문으로 B,A,S 등급을 부여한다. 전체등급이 300점을 넘는 등급이 없기 때문에 S등급은 없고 C1의 6번만 A등급을 받는다."
663,,,,,"UPDATE EMPLOYEE E1
SET SAL = (SELECT MAX(SAL)
FROM EMPLOYEE E2
WHERE E1.DNAME = E2.DNAME)
WHERE SAL <= (SELECT AVG(SAL)
FROM EMPLOYEE);",,,,,,"2 전체 평균(4000)보다 급여가 낮은 직원들의 급여만 수정되므로 김길동 두 명의 급여는 수정되지 않는다. SET절은 각 행의 급여 수정 시 부서명을 확인하여 서브쿼리에서 해당 부서의 최대 급여를 찾아 수정하는 구문이다. 따라서 아시아지부는 모두 3000으로, 남유럽지부는 8000으로 수정된다."
664,,,,,"SELECT COUNT(*)
FROM SQLD49, SQLD49_2
WHERE SQLD49.COL1 = SQLD49_2.COL1;",3,4,9,1,,3 INNER JOIN이므로 JOIN조건을 만족하는 행만 가져와서 조건을 수행한다.
665,,,,,"SELECT 사원번호, 이름, LEVEL
FROM 사원
WHERE 지역 = '경기'
START WITH 상위관리자코드 IS NULL
CONNECT BY 상위관리자코드 = PRIOR 사원번호;",,,,,,4 WHERE절은 출력 대상을 결정하기 때문에 서울 지역인 홍길동은 출력하지 않는다.
666,,,,,"SELECT COL1 AS C1, SUM(COL2) AS C2
FROM TAB1
GROUP BY COL1
HAVING SUM(COL2) >= 400;",,,,,,"3 GROUP BY 후 SUM(COL2) 연산 결과 (10, 300), (20, 400), (30, 500), (NULL, 600) 그룹이 출력된다. 이들 중 HAVING 조건에 만족하는 그룹은 (20, 400), (30, 500), (NULL, 600) 이다."
667,,,,,"SELECT *
FROM 고객
ORDER BY 포인트 DESC
OFFSET 2 ROWS
FETCH FIRST 2 ROWS ONLY;",,,,,,4 고객 테이블에서 포인트가 높은 순서대로 정렬을 한 후 2개의 행을 건너 뛰고 3번째부터 2개의 행을 뽑는다.
668,,,,,"select * from A1
union
select * from B1
minus
select * from C1;",4,3,2,1,,"2 select * from A union select * from B를 실행하면 1,2,3,4,5가 반환된다. 해당 결과에 MINUS 조인을 하면 4,5가 빠지기 때문에 최종적으로 1,2,3 이 된다."
669,,,,,"SELECT AVG(COL3) FROM SQLD01;
SELECT AVG(COL3) FROM SQLD01 WHERE COL1 > 0;
SELECT AVG(COL3) FROM SQLD01 WHERE COL1 IS NOT NULL;","10, 10, 10","10, 20, 20","20, 10, 10","20, 20, 20",,"2 이 문제의 핵심은 그룹 함수(SUM, AVG, MAX, MIN)는 실행 시에 NULL이 제외된다는 것이다."
670,,,,,"SELECT ID, PARENT_ID, NAME,
PARENT_NAME
FROM SQLD_13
WHERE PARENT_ID NOT IN (3)
START WITH PARENT_ID = 0
CONNECT BY PRIOR ID = PARENT_ID
ORDER SIBLINGS BY PARENT_ID ASC, ID ASC;",ORDER SIBLINGS BY를 하면 전체 테이블 기준으로 정렬한다.,중복이 생겼을 때 루프를 돌지 않기 위해 NO CYCLE 옵션을 사용할 수 있다.,순방향 전개다.,PARENT_ID가 0이라도 3이 포함되면 전개를 멈춘다.,,"1 ④의 경우, 계층쿼리는 일단 START WITH_CONNECT BY로 전개를 수행한 후에 WHERE로 필터링을 한다. 만약 CONNECT BY에 AND 조건을 PARENT_ID != 3 식이었다면 전개 중에 멈추겠지만 WHERE에서 필터링을 하는 것이므로 일단 전개를 완료한 후에 WHERE가 실행되는 것으로 볼 수 있다."
671,,,,,"SELECT 회원ID,
DENSE_RANK() OVER(ORDER BY (ㄱ) )
AS RANK, 주문금액
FROM SQLD7;",주문금액 1,주문금액 ASC,(주문금액),(주문금액) DESC,,4 결과 테이블은 주문금액이 큰 순서대로 순위를 부여하는 테이블로 주문금액 속성을 내림차순 정렬했을 때의 순위이고 같은 등수 다음에는 바로 다음 등수가 부여되었으므로 DENSE 랭크 함수가 들어가야 한다.
672,,,,,"SELECT SUM(COL2) + SUM(COL3) FROM TAB1;
SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 > 0;
SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 IS NOT NULL;
SELECT SUM(COL2) + SUM(COL3) FROM TAB1 WHERE COL1 IS NULL;","1000, NULL, 400, 600","1000, 100, 400, 600","500, NULL, 400, 600","500, 100, 400, 600",,"1 SUM(COL2)는 NULL 만 제외하고 총합을 리턴하므로 500 이 출력된다. 하지만 2 번 지문의 경우 COL1 > 0 조건에 만족하는 행은 첫 번째 행 하나이므로 SUM(COL2) + SUM(COL3) = NULL + 100 이 되며, 이때는 NULL 이 리턴된다."
673,,,,,"고객마스터 테이블의 고객번호는 대표성에 따른
식별자 분류로는 (ㄱ)이고 스스로 생성했는지
여부에 따라서는 (ㄴ)이다. 또한 계좌마스터의 고객번호는
스스로 생성 여부에 따라서 (ㄷ)이다.","ㄱ-내부식별자, ㄴ-단일식별자, ㄷ-보조식별자","ㄱ-보조식별자, ㄴ-내부식별자, ㄷ-외부식별자","ㄱ-주식별자, ㄴ-내부식별자, ㄷ-외부식별자","ㄱ-보조식별자, ㄴ-외부식별자, ㄷ-단일식별자",,3 식별자는 대표성에 따라서 주식별자와 보조식별자로 분류되고 생성 여부에 따라서는 내부 식별자와 외부 식별자로 분류된다. 또한 속성의 수에 따라서 단일 식별자와 복합 식별자로 분류된다.
674,,,,,"SELECT SUM(A.COL1)
FROM TAB1 A, TAB2 B WHERE A.COL2 <> B.COL2;",30,12,10,8,,"2 NULL은 같지 않다에 참이 리턴되지 않는다. 따라서 TAB1 기준 COL2가 A인 경우는 1개, NULL인 경우 0개, B인 경우 1개, C인 경우 2개가 리턴된다. 따라서 이들의 COL1에 대한 총 합은 12가 된다."
675,,,,,"SELECT *
FROM TAB1
UNPIVOT (_____ FOR _____ IN (""2023"", ""2024""));","판매량, 판매량","성별, 판매량","성별, 연도","판매량, 연도",,"4 첫 번째 밑줄은 10, 20, 30, 40 값이 쌓여 하나의 컬럼을 이룰 때 컬럼명을 나타내는 자리이므로 판매량, 두 번째 밑줄은 2023, 2024를 넣을 컬럼명을 의미하므로 연도가 적절하다."
676,,,,,"SELECT ID, AGE
FROM test20
ORDER BY (CASE WHEN ID = 10 OR
ID=13 THEN 1 ELSE 2 END), AGE DESC",,,,,,"4 CASE 문을 사용해서 정렬의 순서를 변경했고 그래서 ID가 13, 10번이 가장 먼저 조회된다. 즉, 10과 13번이 먼저 조회되고 AGE로 DESC이므로 13의 AGE가 50이라서 가장먼저 조회된다."
677,,,,,"SELECT DNMAE,JOB,SUM(SAL)
FROM Mytest
GROUP BY ( )",CUBE(JOB),GROUPING SETS(JOB),"ROLLUP(DNAME,JOB)","CUBE(DNAME,JOB)",,"4 결괏값을 보면 1.DNAME, JOB별 소계 2.DNAME별 소계 3.JOB별 소계 4.전체 집계 등 모든 조합 가능한 소계와 집계가 조회되었으므로 빈칸에 들어갈 그룹 함수는 CUBE이다."
678,,,,,"SELECT EMPNO, ENAME, DEPTNO, SAL,
SUM(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL
____________________) AS RESULT
FROM EMP;",ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING,ROWS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING,RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING,RANGE BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING,,"1 누적합의 범위가 각 행마다 이전행과 현재행, 다음행을 연산하고 있으므로(JONES 기준 1100 + 2975 + 3000 = 7075) 1 PRECEDING AND 1 FOLLOWING 이며, SAL이 같은 SCOTT과 FORD의 누적합이 각각 다르게 계산되었으므로 ROWS가 적절하다."
679,,,,,"SELECT SUM(SAL)
FROM EMPLOYEES
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
FROM EMPLOYEES
GROUP BY DEPTNO);",7500,4500,3000,1500,,"1 다중컬럼 서브쿼리를 사용하여 각 부서별로 최대급여를 받는 직원들의 급여 총합을 출력하고 있다. 10번 부서는 1500, 20번 부서는 3000이지만 FORD와 MILLER 둘 다 출력되므로 총 합은 7500이다."
680,,,,,"SELECT COL1, COL2, COL3,
LEAD(COL3, (ㄱ), (ㄴ)) OVER(PARTITION BY COL1 ORDER BY COL3 ) AS Result FROM Mytest","ㄱ : 1, ㄴ : 4","ㄱ : 1, ㄴ : 9","ㄱ : 2, ㄴ : 4","ㄱ : 2, ㄴ : 9",,"4 COL3 값에서 두 번째 다음값이 Result 값으로 출력되니 (ㄱ)에는 숫자 2가 와야 하고, 현재 COL3값의 두번째 다음값이 해당 파티션내에서 존재하지 않을 경우에는 기본값으로 9를 출력하니 (ㄴ)에는 숫자 9가 와야한다."
681,,,,,"SELECT DEPTNO, DNAME, LEVEL, CONNECT_BY_ROOT(DNAME) AS ROOT
FROM DEPARTMENT
START WITH PART IS NULL
CONNECT BY PRIOR PART = DEPTNO;",,,,,,"3 PRIOR의 위치가 PART에 있으므로 가장 최상위 학과(PART IS NULL)를 먼저 출력하고, 두 행의 PART를 DEPTNO 로 갖는 행을 찾지만 해당 행이 없으므로 최상위 학과인 공과대학과 인문대학만 출력된다."
682,,,,,"SELECT COUNT(CODE)
FROM TAB1
WHERE CODE LIKE '_1%' OR CODE LIKE '%A%';",8,7,5,4,,"3 _1%' 조건은 두 번째 값이 1 인 문자열을 나타내므로 A1C1, B1A0, C1A1, D1B2 총 4 개이고, '%A%' 조건은 A 를 포함하는 문자열이므로 A1C1, A2C2, B1A0, C1A1 총 4 개이다. OR 조건은 두 집합의 합집합(중복값은 한 번만)이므로 총 8 개에서 두 조건을 모두 만족하는 A1C1, B1A0, C1A1 을 제외하면 총 5 개이다."
683,,,,,"SELECT C1,C2
FROM SQLD_02
ORDER BY C1,C2 DESC ( );",NULL LAST,NULLS LAST,NULL IS LAST,IS NULL,,2 NULLS LAST는 NULL 값을 마지막에 정렬시키는 것이다.
684,,,,,"SELECT LPAD('**', (LEVEL-1)*2, ' ')||
EMPNO AS EMP, NAME
FROM TEST10
WHERE EMPNO <> 3
START WITH EMPNO = 3
CONNECT BY EMPNO = PRIOR MANAGER;",3,2,1,0,,2 위의 SQL에서 WHERE 조건에 의하여 EMPNO 3번은 조회에서 제외된다. 그리고 EMPNO가 3번으로 시작하여 계층형 조회를 한다. 따라서 EMPNO 1번과 2번 2개의 행이 조회된다.
685,,,,,"select count(*) from TEST11
where COL3 <> 3
start with COL3 = 4
connect by COL1 = prior COL2;",3,2,1,0,,1
686,,,,,"ALTER TABLE TAB2 ADD FOREIGN KEY(CLASS_NO) REFERENCES TAB1(NO) ON DELETE SET NULL;
DELETE FROM TAB1 WHERE NAME = 'C';",,,,,,2 ON DELETE SET NULL 옵션에 의해 TAB1 데이터 삭제 시 자식 데이터의 외래키 컬럼은 NULL로 수정된다.
687,,,,,"SELECT DEPTNO, JOB, SUM(SAL)
FROM SQLD_73
GROUP BY ( );","CUBE(DEPTNO, JOB)","DEPTNO, JOB","GROUPING SETS(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)",,"4 주어진 결괏값을 보면 1.DEPTNO별 합계, 2.DEPTNO, JOB별 합계, 3.전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다."
688,,,,,"SELECT *
FROM SQLD27 ( ) SQLD27_2
ON SQLD27.COL1 = SQLD27_2.COL1;",INNER JOIN,FULL OUTER JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,,3 주어진 두 개의 테이블에서는 같은 COL1 값을 갖는 튜플을 조회하고 우측 테이블에만 있는 값들이 추가로 조회되므로 RIGHT OUTER JOIN이다.
689,,,,,"[SQL]
SELECT CASE WHEN GROUPING(A.서비스ID) = 0 THEN A.서비스ID ELSE '합계', END AS 서비스ID
,CASE WHEN GROUPING (B.가입일자) = 0
THEN NVL (B.가입일자, '-') ELSE '소계' END AS 가입일자
,COUNT (B. 회원번호) AS 가입건수
FROM 서비스 A LEFT OUTER JOIN 서비스가입 B
ON (A.서비스ID = B. 서비스ID
AND B.가입일자 BETWEEN '2013-01-01' AND '2013-01-31')
GROUP BY ROLLUP (A.서비스ID, B.가입일자);",execute 'TRUNCATE TABLE DEPT';,execute immediate 'TRUNCATE TABLE DEPT';,DELETE FROM DEPT;,TRUNCATE TABLE DEPT;,,2 ROLLUP은 계층 구조를 가진 SUB TOTAL을 생성하는 함수로 나열된 컬럼의 순서가 변경되면 수행 결과도 변경된다. 위의 SQL문장은 서비스ID에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수 를 구하되 Outer Join을 수행하였으므로 가입내역이 없는 서비스ID(004)에 대해서도 SUB TOTAL을 출력하고 있다. ④은 서비스ID 에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수를 구한 것은 맞으나 LEFT OUTER JOIN이 아닌 INNER JOIN에 대한 결과로 서비스ID 004가 출력되지 않았다.
690,,,,,"CREATE TABLE MYTEST_TEMP (COL1 NUMBER(10));

UPDATE MYTEST SET COL1=130 WHERE COL2=10;
ROLLBACK;",AUTO COMMIT이 FALSE이므로 UPDATE구는 자동 COMMIT되지 않는다.,ORACLE에서 ROLLBACK을 실행하면 테이블은 생성되지 않는다.,ORACLE에서 ROLLBACK을 수행하면 UPDATE구는 취소된다.,SQL SERVER에서 ROLLBACK을 하는 경우 UPDATE구는 취소된다.,,2 CREATE TABLE 문구와 같은 DDL구는 ROLLBACK으로 취소되지 않는다.
691,,,,,"SELECT SUM(COL1)
FROM TAB1 T1
WHERE COL3 >= (SELECT AVG(COL3)
FROM TAB2 T2
WHERE T2.COL2 = T1.COL2);",23,9,0,,,"2 T2.COL2 값의 그룹별로 COL3의 평균보다 T1.COL3의 값이 큰 행을 찾고, 이들의 T1.COL1의 총 합을 구하는 질의절이다. T2에서 COL2의 값이 A인 그룹의 AVG(COL3)은 20이므로 T1에서 A그룹이면서 COL3의 값이 20보다 크거나 같은 대상을 찾으면 0건이 출력된다. 마찬가지로 T2에서 B그룹의AVG(COL3)을 구하면 20이고, T1의 B그룹중 COL3 의 값이 20보다 크거나 같은 행은 COL1의 값이 4,5인 행이므로 최종 결과는 9가 리턴된다."
692,,,,,"SELECT mgr, empno, ename, LEVEL, CONNECT_BY_ISLEAF, SYS_CONNECT_BY_PATH(ENAME,'-') ""PATH""
FROM limbest.EMP
START WITH mgr is null
Connect by prior empno = mgr;",LEVEL은 계층의 깊이를 의미하며 TEST1은 최상위 계층이다.,자식에서 부모로 가는 역방향이다.,"CONNECT_BY_ISLEAF는 LEAF이면 1을, 아니면 0을 반환한다.",EMPNO 1000번의 MGR은 NULL 값이다.,,2 위의 계층형 조회는 최상위 계층에서 하위 계층으로 검색하는 정방향 조회이다.
693,,,,,"SELECT COUNT(DISTINCT COL1)
FROM test31_1
WHERE COL3=
(SELECT COL3 FROM test31_2 WHERE
COL2 = 'A')",4,3,2,1,,3 서브쿼리는 COL2가 'A'인 것을 조회하므로 10이 나온다. 그리고 test31_1 테이블에서 COL3가 10인 것을 조회한다. 그러면 2건이 조회된다. 왜냐하면 DISTINCT는 COL1로 수행하므로 중복된 것이 없다.
694,,,,,"SELECT COUNT(TAB1.COL1)
FROM TAB1, TAB2
WHERE TAB1.COL2 = TAB2.COL2(+);",5,4,3,2,,"1 (+) 가 붙은 반대편 테이블이 기준이 되는 테이블로 TAB1 테이블을 기준 테이블로 LEFT OUTER JOIN이 수행된다. 즉, 조인 조건이 일치하지 않아도 TAB1은 생략되서는 안되므로 INNER JOIN의 결과에 TAB1의 COL2가 NULL, C인 경우 추가적으로 출력되므로 총 5건이 나온다."
695,,,,,"SELECT DISTINCT COL1, COL2
FROM MytestA
UNION ALL
SELECT COL1, COL2
FROM MytestB;",7,4,5,2,,"3 첫 번째 테이블에서 DISTINCT로 중복된 행이 제외되어 (1,2),(1,3) 두개의 행만 남고 두번 째 테이블과 UNION ALL로 중복을 포함하여 합쳐져 (1,2),(1,3),(1,2),(1,4),(1,5) 5개의 행이 조회된다."
696,,,,,"SELECT VAL, COUNT(*) AS CNT
FROM(
SELECT( ㄱ )(4) over (ORDER BY COL1) AS VAL
FROM Mytest
)
WHERE 1=1
GROUP BY VAL ORDER BY 1;",LAG,RANK,LEAD,NTILE,,"4 NTILE 함수는 expr에 명시된 값만큼 파티션을 균등하게 분할하는 함수로 expr에 명시된 숫자가 4이고 order by가 1이니 오름차순 정렬로 총 4개의 VAL속성값으로 파티션이 분할되며 각 파티션별로 행의 수가 균등하게 분할되어 3,3,2,2의 행의 수로 각각 분할된다."
697,,,,,"SELECT COUNT(A.COL2)
FROM TAB1 A JOIN TAB2 B
ON A.COL2 = B.COL2;",3,2,1,0,,"1 NULL 끼리는 동등비교 조건에 참으로 리턴되지 않는다. TAB1의 COL2값이 A인 경우 TAB2의 1건, B인 경우 2건, C의 경우 조건에 만족하는 값이 없으므로 INNER JOIN에서는 생략된다. 따라서 총 3건이 출력된다."
698,,,,,"SELECT EMPLOYEE_ID,
DEPARTMENT_ID, LAST_NAME, SALARY, LAG(SALARY,( )) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY) AS BEFORE_SALARAY
FROM EMPLOYEES
WHERE EMPLOYEE_ID < 110;",4,3,2,1,,"3 LAG 함수는 이전 행의 값을 반환하는 함수이다. LAG(SALARY, 2)라고 하면 이전 두 번째 행 값을 반환하게 된다."
699,,,,,"SELECT DNAME, JOB, SUM(SAL)
FROM TEST18
GROUP BY ( )",CUBE(DNAME),"GROUPING SETS(DNAME,JOB)","ROLLUP(DNAME,JOB)","CUBE(DNAME,JOB)",,"4 결괏값을 보면 1.DNAME, JOB별 소계 2.DNMAE 별 소계 3.JOB별 소계 4.전체 집계 등 모든 조합 가능한 소계와 집계가 조회되었으므로 빈칸에 들어갈 그룹 함수는 CUBE이다."
700,,,,,"SELECT COUNT(*) ROWCNT
FROM test36_1 a,test36_2 b
WHERE a.ename LIKE b.condition;",6,4,3,0,,3
701,,,,,"SELECT ENAME, SAL,
( ) as SM_CNT
FROM SQLD_11;",COUNT(*) OVER(ORDER BY CNT RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 0 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),MAX(SAL) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),,"3 먼저 위의 SQLD_11 테이블에서 결과값과 같이 반환되도록 'SAL' 속성을 기준으로 정렬을 수행하고, 각각의 행에서의 SAL 속성값을 기준으로 -50에서 +100범위 사이에 포함되는 SAL값을 가지는 모든 행의 수를 COUNT하여 SIM_CNT 속성값으로 조회한다."
702,,,,,"SELECT * FROM MytestA A INNER JOIN MytestB B ON (A.KEY1 = B.KEY2);
SELECT * FROM MytestA A LEFT OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2);
SELECT * FROM MytestA A RIGHT OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2);
SELECT * FROM MytestA A FULL OUTER JOIN MytestB B ON (A.KEY1 = B.KEY2);
SELECT * FROM MytestA A CROSS JOIN MytestB B;","2, 4, 3, 7, 12","2, 3, 4, 5, 12","2, 4, 5, 8, 12","2, 4, 3, 5, 12",,"4 -INNER JOIN은 B와 C가 같기 때문에 2건이다. -LEFT OUTER JOIN은 같은 것 2건과 D,E까지 포함해서 4건이 된다. -RIGHT OUTER JOIN은 같은 것 2건과 MytestB의 A까지 조회되어서 3건이 된다. -FULL OUTER JOIN은 같은 것 2건과 MytestA의 2건, MytestB의 1건 포함해서 5건이 된다. -CROSS JOIN은 MytestA의 4개의 행과 MytestB의 3개의 행을 곱해서 4*3=12건이다."
703,,,,,"SELECT
( ) AS A,
( ) AS B,
( ) AS C
from Mytest","max(COL1), max(COL2), max(COL1)","max(COL1), min(COL2), sum(COL2)","max(COL1), min(COL2), sum(COL1)","max(COL2), min(COL2), sum(COL1)",,"3 A 속성은 COL1의 최댓값, B 속성은 COL2의 최솟값, C 속성은 COL1 속성의 합이다."
704,,,,,"SELECT 사원번호, 이름, LEVEL
FROM 사원
START WITH 사원번호 IN (1006, 1001)
CONNECT BY PRIOR 상위관리자코드 = 사원번호;",,,,,,"2 START WITH 조건이 1006과 1001이므로 두 행이 1레벨이 되고, 해당 행의 상위관리자코드를 사원번호로 갖는 행을 찾으면 둘 다 홍길동이 출력된다. 따라서 정답은 3번이 된다."
705,,,,,"SELECT DISTINCT DEPARTMENT_ID
FROM HR.EMPLOYEES A
WHERE A.DEPARTMENT_ID <= ALL (30,50);","10,20,30,40,50","10,20,30,40","10,20,30","10,20",,3 ALL 연산자는 서브쿼리 값 모두가 조건에 만족하면 True를 반환한다.
706,,,,,"SELECT DNAME, JOB, COUNT(*) ""Total Emp"", SUM(SAL) ""Total Sal"" FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
GROUP BY CUBE(DNAME,JOB);",20건,18건,14건,10건,,2 DEPTNO로 조인을 하고 DNAME과 JOB으로 CUBE를 실행했다. CUBE는 전체합계와 각 칼럼별로 부분합계를 출력한다. CUBE는 입력된 칼럼들의 모든 조합으로 집계를 출력한다.
707,,,,,"SELECT COUNT(DEPTNO)
FROM EMPLOYEES
WHERE DEPTNO <= ALL(SELECT DEPTNO
FROM EMPLOYEES
WHERE HIREDATE >= TO_DATE('2020/02', 'YYYY/MM'));",5,4,3,2,,"3 서브쿼리 결과가 먼저 실행되어 2020년 2월 1일보다 입사일이 큰 행의 DEPTNO(30, 40, 50)가 출력되고 ALL이 작다와 결합되어 이들 중 30보다 작거나 같은 조건으로 전달된다. 따라서 DEPTNO가 10, 20, 30인 EMPNO의 수는 총 3개이다."
708,,,,,"SELECT * FROM TEST1
UNION ALL
SELECT * FROM TEST2
MINUS
SELECT * FROM TEST3;",5,4,3,2,,1 UNION ALL에 의해서 총 9개의 행이 반환된다. 그리고 MINUS로 차집합을 만든다.
709,,,,,"SELECT COUNT(*)
FROM TAB1, TAB2
WHERE NAME LIKE RULE_NAME;",3,2,1,0,,"1 TAB1을 RULE_NAME에 매핑되는 규칙으로 TAB2에 조인을 수행했기 때문에, 각 행마다 LIKE 조건이 일치하면 TAB2 값이 출력된다. 즉, SCOTT은 %O%와, FORD는 %O%와 F% 둘 다 매핑되어 행이 두 개로 출력된다. 따라서 총 행의 수는 3건이 리턴된다."
710,,,,,"SELECT SUM(CASE WHEN COL1 ='A'
THEN 1 END) AS SUM1,
SUM(CASE WHEN COL3 < 20000 THEN 1 END) AS SUM2
FROM Mytest;","4,8","3,7","2,6","1,5",,"2 SUM1은 COL1 ='A'조건을 만족하는 1,2,3행을 각각 1로 되돌리고 합계를 계산하기 때문에 3이 된다. COL2 < 20000 조건은 모든 행이 만족하고 1을 되돌리므로 합계는 7이 된다."
711,,,,,"SELECT count(*)
FROM student
GROUP BY department
HAVING count(*) > 2;",3,2,1,0,,"1 SELECT문을 보면 department로 GROUP BY한다. 그러면 총 3개의 그룹이 만들어진다. computer, physics, math이다. 3개의 그룹 중에서 개수가 2개 초과인 것을 조회하기 위해서 ""HAVING count(*) >2"" 문을 사용했다. 따라서 2개 초과인 것은 math이고 math는 총 3개가 있으므로 3이 된다."
712,,,,,"SELECT b.grade, a.StudentNo, SUM(b.grade)
FROM TEST44_1 a, TEST44_2 b
GROUP by
( );","GROUPING SETS(a.studentno, (b.grade, a.studentno));","GROUPING SETS(b.grade, (b.grade, a.studentno));","GROUPING SETS(b.grade, (a.studentno, b.grade));","GROUPING SETS(b.grade, (a.studentno));",,"2 결괏값을 보면 1.b.Grade, a.StudentNo에 대한 집계, 2.b.grade에 대한 집계가 있고 전체 집계는 없다."
713,,,,,"DELETE FROM TAB1
WHERE CODE IN (SELECT CODE
FROM TAB2
WHERE STATUS = 'OPEN');
SELECT SUM(FARE)
FROM TAB1;",800,600,400,100,,"2 TAB2의 STATUS가 OPEN인 CODE는 0002와 0004이므로 TAB1에서 이들을 삭제하면 AAA,BBB만 남는다. 이들의 FARE 총합은 600이다."
714,,,,,"SELECT ID FROM test29
GROUP BY ID
HAVING COUNT(*) = 2
ORDER BY (CASE WHEN ID = 1000 THEN 0 ELSE ID END);",,,,,,"4 CASE문으로 ID가 1000인 것은 0 으로 변경하고 나머지는 ID값으로 ASC(오름차순) 한다. 단, COUNT 함수로 2건만 조회된다. 따라서 3000, 9999의 값이 2건이라서 3000, 9999만 조회된다."
715,,,,,"SELECT PRODUCT_NO, GOGAK_NO, SUM(QTY) AS TOTAL_QTY
FROM JUMUN
GROUP BY GROUPING SETS(PRODUCT_NO, GOGAK_NO, ());",,,,,,"4 GROUPING SETS(PRODUCT_NO, GOGAK_NO, ())에서 PRODUCT_NO별 SUM(QTY) 결과, GOGAK_NO별 SUM(QTY)연산 결과가 출력된 것과 ()으로 인해 SUM(QTY)의 전체 총 합이 출력된 것을 찾는 문제이다."
716,,,,,"CREATE TABLE A
(C INTEGER PRIMARY KEY,
D INTEGER);

CREATE TABLE B
(B INTEGER PRIMARY KEY,
C INTEGER REFERENCES A(C) ON DELETE CASCADE);

CREATE TABLE C
(A INTEGER PRIMARY KEY,
B INTEGER REFERENCES B(B) ON DELETE SET NULL);","(1,1)","(2,2)","(1,NULL)과(2,NULL)","(1,NULL)과(2,2)",,3 DELETE FROM A 이후 A 테이블은 모두 삭제된다. C 테이블은 Cascade 옵션에 의해서 A의 첫번째 행을 참조하는 두 건 모두 삭제된다. 그리고 B 테이블이 삭제됨에 따라 B 테이블의 B칼럼을 참조하는 C 테이블의 B 칼럼값은 SET NULL 옵션에 의해서 NULL 값으로 변경된다.
717,,,,,"SELECT SUM(COL1+COL2+COL3+COL4)
FROM test23;
SELECT SUM(COL1) + SUM(COL2) + SUM(COL3) + SUM(COL4) FROM tset23;","Null, Null","50, 240","Null, 240","50, Null",,"2 첫 번째 SQL문의 첫 번째 행인(10,10,10,20)은 NULL 값이 없으므로 합계 50이 조회된다. 그리고 두 번째 SQL문에서는 240의 합계가 조회된다. 즉, SUM 집계함수에서 NULL은 자동으로 제외한다."
718,,,,,"SELECT COL1, COL2, SUM(COL3)
FROM Mytest
GROUP BY ( );","GROUPING SETS(COL1,(COL2,COL1))","GROUPING SETS(COL1,(COL2,COL3))","GROUPING SETS(COL1,(COL2,COL3))","GROUPING SETS(COL1,(COL1,COL2))",,4
719,,,,,"SELECT ProductName, SUM(Price)
FROM Mytest
WHERE ProductName = '비디오'
GROUP BY ROLLUP(ProductName);

SELECT ProductName, SUM(Price)
FROM Mytest
WHERE ProductName = '비디오'
GROUP BY GROUPING SETS( );","ProductName, ()","ProductName, Price",(),ProductName,,1 두 SQL문은 모두 ProductName '비디오'에 대한 집계이다. ProductName '비디오' 에 대한 전체 합계가 조회되어야 한다.
720,,,,,"SELECT EXTRACT
(YEAR FROM SYSDATE),
LPAD(EXTRACT(month from sysdate), (ㄱ), (ㄴ))
FROM Mytest;","ㄱ : 2, ㄴ : '0'","ㄱ : 2, ㄴ : '2'","ㄱ : 1, ㄴ : '2'","ㄱ : 1, ㄴ : '0'",,1 COL1 값에서 Month값이 1이 두 자릿수 01로 출력되어야 하므로 LPAD 함수의 두 번째 인자 값에는 숫자 2이다. 세 번째 인자 값에는 문자 '0'이 와야 한다.
721,,,,,"SELECT *
FROM TEST46_1 ( ) TEST46_2
ON TEST46_1.COL1 = TEST46_2.COL1;",CROSS JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,SELF JOIN,,"3 결과 테이블을 보면 TEST46_1 테이블에만 있는 3번행(COL1, COL2)만 조회되고 TEST46_2 테이블에는 3번행이 없으므로 NULL로 조회되었다. 따라서 LEFT OUTER JOIN을 실행한 것이다."
722,,,,,"SELECT SUM(SAL)
FROM TAB1
WHERE NO NOT IN (SELECT NO
FROM TAB2
GROUP BY NO);",700,600,,0,,3 NOT IN문의 서브쿼리 결과 중 NULL이 포함되는 경우 데이터가 출력되지 않는다. NULL은 논리적으로 비교할 수 없는 연산이기 때문에 NULL을 비교하는 연산자로 인해 전체조건이 거짓이 된다. 조건에 만족하는 값이 없으므로 SUM 결과는 NULL이 된다.
723,,,,,"SELECT COUNT(COL1) RESULT FROM TAB1 WHERE COL3 < 100 GROUP BY COL1;
SELECT COUNT(COL1) RESULT FROM TAB1 WHERE COL1 IS NOT NULL GROUP BY COL1
HAVING SUM(COL2) > 500;",,,,,,"2 첫 번째 문장은 조건에 만족하는 COL1값이 NULL이므로 NULL 그룹이 리턴된다. 따라서 COUNT를 하면 0이 출력되며, 두 번째 문장은 HAVING 조건에 만족하는 그룹이 없으므로 공집합이 출력되어 COUNT 결과가 NULL이 된다."
724,,,,,"SELECT A.jumin as ""주문"", B.custrank as ""고객등급""
FROM (SELECT jumun, SUM(price)
AS Total
FROM test34_1
GROUP BY jumun) A, test34_2 B
WHERE A.Total BETWEEN B.minprice AND B.maxprice;",,,,,,"2 먼저 FROM절에 있는 inline view의 실행 결과는 20, 7500과 10, 5000의 합계가 조회된다. 그리고 test34_2의 BETWEEN구로 조회하면 10번 VIP가 조회된다."
725,,,,,"SELECT * FROM TAB1 A INNER JOIN TAB2 B ON (A.KEY1 = B.KEY2)
SELECT * FROM TAB1 A LEFT OUTER JOIN TAB2 B ON (A.KEY1 = B.KEY2)
SELECT * FROM TAB1 A FULL OUTER JOIN TAB2 B ON (A.KEY1 = B.KEY2)
SELECT * FROM TAB1 A CROSS JOIN TAB2 B
SELECT * FROM TAB1 A NATURAL JOIN TAB2 B",3 6 8 12 4,3 5 6 16 3,2 5 6 16 4,2 4 6 8 3,,"2 INNER JOIN은 값이 같으면 모두 출력되므로 TAB1의 KEY1의 값이 BB인 경우 2건, CC와 DD는 일치하는 값이 없으므로 생략, EE는 한 건이 출력되어 총 3건이 리턴된다. LEFT OUTER JOIN은 TAB1의 KEY1의 값이 모두 출력돼야 하므로 앞의 INNER JOIN 결과에 CC와 DD가 추가적으로 리턴되어 총 5건이 된다. FULL OUTER JOIN은 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과의 합집합(중복 값은 한 번만 출력)이므로 총 6건이며 CROSS JOIN의 경우는 모든 발생 가능한 조합이므로 4X4, 16건이 리턴된다. NATURAL JOIN에 의해 COL1, COL2 값이 같은 값만 출력되며 이때 NULL은 같다고 볼 수 없기 때문에 제외되어 총 3건이 출력된다."
726,,,,,"SELECT COUNT(TAB1.NO) FROM TAB1 LEFT OUTER JOIN TAB2 ON TAB1.NO = TAB2.NO;
SELECT COUNT(DISTINCT TAB1.CODE) FROM TAB1 RIGHT OUTER JOIN TAB2 ON TAB1.NO = TAB2.NO;","9, 3","9, 2","7, 3","7, 2",,"4 LEFT OUTER JOIN의 결과 TAB1의 NO값이 1, 2, 4, 4, 6, 7, 3인 총 7개의 행이 나오게 되고, RIGHT OUTER JOIN의 결과로 TAB1의 CODE값이 A, B, B, B, NULL, NULL, NULL이 출력되어 DISTINCT 수는 총 2건이다.(NULL은 세지 않는다)"
727,,,,,"SELECT EMPNO
FROM EMP
ORDER BY TO_CHAR(TO_NUMBER(SUBSTR(JUMIN, 3, 2)));",,,,,,"3 SUBSTR(JUMIN, 3, 2)은 태어난 월을 추출하기 때문에, 순서대로 12, 11, 06, 01, 08의 문자 유형으로 출력된다. 이를 TO_NUMBER를 사용하여 숫자 형태로 변환하면 12, 11, 6, 1, 8이 되는데, 이를 다시 TO_CHAR로 변환하게 되면 문자값의 비교 규칙에 따라 1 < 11 < 12 < 6 < 8 순서대로 출력된다. (문자는 가장 왼쪽부터 비교하여 값이 작을수록 작은값이 된다)"
728,,,,,"SELECT *
FROM (SELECT COL1, COL2
FROM TAB1
UNION
SELECT COL1, COL2
FROM TAB2)
MINUS
SELECT COL1, COL2
FROM TAB3;",,,,,,3 먼저 TAB1과 TAB2의 UNION 결과는 아래와 같다. 이들 중 TAB3의 결과를 빼면 3번 결과가 같다.
729,,,,,"SELECT SUM(T1.COL2)
FROM TAB1 T1
WHERE T1.COL2 = (SELECT MAX(COL2)
FROM TAB1 T2
WHERE T1.COL1 = T2.COL1);",100,90,,에러,,"1 서브쿼리 조건절은 TAB1의 각 행의 COL1을 확인하여 같은 값을 갖는 행들 중 COL2의 최대값과 일치하는 행을 찾아 COL2의 총 합을 묻는 질의절이다. 즉, COL1별 COL2 값이 최대인 행들의 COL2의 총 합을 리턴하는 문장이므로 A그룹에서는 30,30, B그룹에서는 40이 리턴되어 총 100이 출력된다."
730,,,,,"SELECT DEPTNO, JOB, SUM(SAL)
FROM Mytest
GROUP BY ( );","CUBE(DEPTNO, JOB)","ROLLUP(DEPTNO, JOB)","GROUPING SETS(DEPTNO, JOB)","DEPTNO, JOB",,"2 주어진 결괏값을 보면 1, DEPTNO별 합계, 2.DEPTNO,JOB별 합계, 3.전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다."
731,,,,,"SELECT NTILE2, COUNT(*) AS CNT
FROM(
SELECT COL1, COL2, COL3, NTILE(3)
OVER(ORDER BY COL3) AS NTILE2
FROM Mytest )
GROUP BY NTILE2;","ㄱ : 3, ㄴ : 2","ㄱ : 1, ㄴ : 3","ㄱ : 2, ㄴ : 3","ㄱ : 3, ㄴ : 1",,"2 주어진 테이블에서 COL3 속성의 값 7개를 2,2,2로 균등하게 3등분하고 남은 값을 앞에서부터 순차적으로 할당하므로 3,2,2개씩 파티션이 분할된다. 그러면 NTILE2에서는 각각 분할된 파티션별 번호인 1,2,3이 할당되고 CNT에서는 각각에 분할된 파티션별 행의 수가 카운트 되어 3,2,2가 반환된다."
732,,,,,"SELECT COUNT(*)
FROM TEST29_1 A
WHERE A.COL NOT IN(SELECT COL FROM TEST29_2);",6,3,1,0,,4 NOT IN 안에 NULL이 들어가면 아무것도 출력되지 않는다. 이 때 COUNT는 0을 출력하게 된다.
733,,,,,"SELECT
( ) OVER(ORDER BY sal desc)
as rank, name, deptname, position, sal FROM test44;",NTILE(),ROW_NUMBER(),DENSE_RANK(),RANK(),,2 위의 결괏값에 동일한 RANK가 없으므로 ROW_NUMBER()가 되어야 한다.
734,,,,,"SELECT *
FROM Mytest
START WITH MGRID IS NULL
CONNECT BY PRIOR EMPID = MGRID
AND today BETWEEN '2017-01-01' AND '2022-12-31'
ORDER SIBLINGS BY EMPID;",,,,,,4 MGRID가 NULL인 값에서 시작해서 EMPID로 조회를 전개하는 순방향 조회를 하고 있다. 순방향 전개를 하면서 EMPID로 정렬한다.
735,,,,,"SELECT ENAME, DEPTNO, SAL
FROM EMP
ORDER BY DEPTNO, SAL DESC;",,,,,,"2 DEPTNO가 작은순서대로, DEPTNO가 같은 경우 SAL이 큰 순서대로 정렬하여 출력한다. NULL이 마지막에 출력되는게 기본 순서이지만DESC로 내림차순 정렬하면 NULL이 젤 먼저 출력된다."
736,,,,,"SELECT COL1
FROM TAB1
ORDER BY CASE WHEN MOD(COL2, 3) = 0 THEN 'A'
ELSE 'B'
END, COL1;",,,,,,"3 CASE문 결과를 1차 정렬로 한 뒤, 이 값이 같을 경우 COL1의 값으로 2차 정렬을 수행한다. 이렇게 정렬된 COL1의 값은 SCOTT, ALLEN, FORD, SMITH 순으로 출력된다."
737,,,,,"SELECT COUNT(COL1), COUNT(COL2)
FROM (
SELECT DISTINCT COL1, COL2
FROM TEST40
);","3,3","2,2","2,1","1,2",,"1 DISTINCT 명령어로 중복된 COL1, COL2값은 제외되어 COL1, COL2이 (조조,1), (조조,2),(조조,3)이 된다."
738,,,,,"SELECT Count(*) FROM(
SELECT DISTINCT COL1
FROM mytesta
UNION ALL
SELECT COL1
FRM mytestb );",11,12,10,4,,"1 1번째 테이블에서 10,20,25,30,50,60이 반환되고 2번째 테이블에서 10,20,30,40,50이 반환되기 때문에 총 행 수는 11이 된다."
739,,,,,"SELECT COUNT(*) FROM(
SELECT COUNT(*)
FROM Mytest
GROUP BY ROLLUP(DATA1), DATA2);",8,6,4,3,,1 총 행 수는 8개 조회된다.
740,,,,,"SELECT COUNT(COL1) AS RESULT
FROM TAB1
WHERE COL2 >= 30 GROUP BY COL1;",,,,,,2 WHERE절의 비교 연산 결과 COL2의 30과 40만 해당되고 그에 해당하는 COL1은 모두 NULL이다. GROUP BY에 의해 COL1이 NULL인 한 그룹이 생성되지만 NULL은 COUNT하지 않기 때문에 0이 출력된다.
741,,,,,"SELECT SUM(A.N1)
FROM MytestA A, MytestB B
WHERE A.V1 <> B.V1;",9,12,32,10,,2
742,,,,,"SELECT NVL(COL2,COL3) AS 금액A,
COALESCE(COL2,COL3) AS 금액B,
NULLIF(COL2,COL3) AS 금액C,
CASE WHEN COL2 IS NOT NULL
THEN COL2 ELSE COL3 END AS 금액D
FROM Mytest",금액D,금액C,금액B,금액A,,"2 ②번 보기에서의 연산자인 NULLIF는 COL2와 COL3이 동일하면 NULL을, 동일하지 않으면 COL2를 반환하는데 3번째 행에서 COL2, COL3 값이 다르므로 해당 행에서의 COL2 값인 NULL 값을 반환한다."
743,,,,,"SELECT C2, SUM(C3)
FROM SQLD_01
GROUP BY C2
HAVING COUNT(*) >= 2;",,,,,,3 주어진 테이블에서 C2 칼럼으로 그룹화 했을 때 C2 칼럼별 튜플의 수가 2개 이상인 C2칼럼에 대해서 C3의 합계를 계산한다.
744,,,,,"SELECT E.*, LEVEL
FROM 사원 E
START WITH 매니저사원번호 IS NULL
CONNECT BY PRIOR 사원번호 = 매니저사원번호 AND EXTRACT(MONTH FROM 입사일자) >= 7
ORDER SIBLINGS BY 이름;",,,,,,"3 매니저 사원번호가 NULL인 지점을 시작으로 레벨 1을 부여, 나사장의 사원번호를 매니저 사원번호로 가지면서 하반기 입사자인 행을 찾아 레벨 2를 부여한다. 이렇게 연결된 행으로부터 CONNECT 절의 조건을 만족하는 행을 계속 이어 나간다. 이때, START WITH 절은 CONNECT BY에 있는 조건에 따라 생략되지 않기 때문에 나사장이 상반기 입사자라도 출력된다."
745,,,,,"ALTER TABLE TAB1 ADD COL4 CHAR(5);
ALTER TABLE TAB1 MODIFY COL4 DEFAULT 'AAA';
INSERT INTO TAB1 VALUES(4, 'D', 40, NULL);
INSERT INTO TAB1(COL1, COL2, COL3) VALUES(5,'E',50);",,,,,,"2 COL4 컬럼 추가 시, 기존 세 개의 행의 값은 NULL이 삽입된다. 그 이후 DEFAULT 값을 변경해도 이전에 삽입된 행은 반영되지 않고, 이후 삽입되는 행에 대해 적용된다. COL3에 DEFAULT 값이 설정되어 있다 하더라도 NULL을 직접 입력하면 NULL이 삽입되며, 마지막 INSERT 문장처럼 COL3의 값이 아예 입력되지 않을 경우만 DEFAULT VAULE로 삽입된다."
746,,,,,"SELECT DNAME, JOB, COUNT(*) ""Total EMP"", SUM(SAL) ""Total Sal"" FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO
GROUP BY CUBE(DNAME,JOB);",20건,18건,14건,10건,,"2 두 개의 테이블을 조인하면 14개의 행이 나오게 된다. 이를 CUBE로 집계를 하면 전체합계 1건, JOB별 집계 5건, DEPTNO별 집계 3건, DEPTNO에서의 JOB별 집계가 3건씩 9건으로 총 18건이 출력된다."
747,,,,,"SELECT ( ) OVER
(ORDER BY 급여 desc)
as 순위, 이름, 급여
FROM Mytest;",ROW(),ROW_NUMBER(),DENSE_RANK(),RANK(),,3 결괏값에서 중복된 등수 2등 다음에 바로 다음 등수인 3등이 왔으므로 빈칸에는 DENSE_RANK가 와야 한다.
748,,,,,"SELECT CASE WHEN SUM (COL1 + COL2)
IS NULL THEN 0
ELSE SUM(COL1 + COL2)
END AS 합계
FROM TEST32;",25,22,12,,,2
749,,,,,"SELECT ENAME, SAL, ( ) as CNT
FROM Mytest;",COUNT(*) OVER(ORDER BY CNT RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 0 PRECEDING 100 FOLLOWING),COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),MAX(SAL) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING),,"3 먼저 위의 Mytest 테이블에서 결괏값과 같이 반환되도록 ''SAL"" 속성을 기준으로 정렬을 수행하고 각각의 행에서의 SAL 속성값을 기준으로 -50에서 +150 범위 사이에 포함되는 SAL값을 가지는 모든 행의 수를 COUNT하여 CNT 속성값으로 조회한다."
750,,,,,"SELECT COUNT(*)
FROM TAB1
WHERE EXISTS (SELECT 1
FROM TAB2
WHERE TAB2.COL1 = 'A');",3,1,0,,,3 서브쿼리 결과가 항상 거짓이므로 조건에 만족하는 행이 없다. 이 경우 COUNT는 NULL이 아닌 0을 리턴한다.
751,,,,,"SELECT E1.EMPNO, E1.ENAME, E1.HIREDATE, COUNT(E2.EMPNO) AS CNT
FROM EMP E1 LEFT OUTER JOIN EMP E2
ON E1.HIREDATE > E2.HIREDATE
GROUP BY E1.EMPNO, E1.ENAME, E1.HIREDATE
ORDER BY E1.HIREDATE;",,,,,,"3 셀프조인을 사용하여 EMP에서의 각 직원별로 입사일이 빠른 직원의 수를 계산하는 질의절이다. 이 때, LEFT OUTER JOIN을 수행하였기 때문에 입사일이 가장 빠른 SMITH의 경우도 CNT가 0으로 출력된다."
752,,,,,"SELECT ROUND(TO_DATE('2024-02-20 14:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'MONTH') AS D1,
TRUNC(TO_DATE('2024-09-12 09:00:00', 'YYYY-MM-DD HH24:MI:SS')) AS D2 FROM DUAL;",,,,,,"2 ROUND와 TRUNC는 각각 날짜의 반올림과 버림을 수행할 수 있다. 두 번째 인수 생략 시 ""일"" 단위로의 반올림/버림이 진행되며, 'MONTH'의 경우 ""월"" 단위로의 반올림/버림이 진행된다. 즉, ""일"" 단위에서 반올림을 진행하게 된다."
753,,,,,"Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)",SELECT deptno FROM Dept WHERE deptno <> ANY (SELECT deptno FROM Emp);,SELECT b.deptno FROM Emp a RIGHT OUTER JOIN Dept b ON a.deptno = b.deptno WHERE empno IS NULL;,SELECT deptno FROM Dept a WHERE NOT EXISTS (SELECT * FROM Emp b WHERE a.deptno = b.deptno);,SELECT deptno FROM Dept WHERE Deptno NOT IN (SELECT deptno FROM Emp);,,1 ①의 결과는 모든 DEPTNO가 조회된다.
754,,,,,"SELECT (A)
FROM (B) a
WHERE a.col = (C)",A : 인라인 뷰 B : 스칼라 서브쿼리 C : 서브쿼리,A : 스칼라 서브쿼리 B : 인라인 뷰 C : 서브쿼리,A : 서브쿼리 B : 스칼라 서브쿼리 C : 인라인 뷰,A : 스칼라 서브쿼리 B : 서브쿼리 C : 인라인 뷰,,"2 큰 의미에서는 모두 서브쿼리이다. SELECT구에 사용하면 스칼라 서브쿼리, FROM구에 사용하면 인라인 뷰, WHERE구에 사용하면 서브쿼리로 구분한다."
755,,,,,"insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
on a1.col1=a2.col1;","(4), (1)","(3), (4)","(2), (3)","(1), (2)",,"1 FULL Outer Join은 총 6개의 행이 조회되고, LEFT와 RIGHT Outer Join은 총 4개의 행이 조회된다. 그리고 보기 1번의 Inner 조인은 2개의 행이 조회된다."
756,,,,,"[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))",(ㄱ) : NOT EXISTS (ㄴ) : 사번 <> 부양사번,(ㄱ) : NOT EXISTS (ㄴ) : 사번 = 부양사번,(ㄱ) : EXISTS (ㄴ) : 사번 <> 부양사번,(ㄱ) : EXISTS (ㄴ) : 사번 = 부양사번,,"2 ‘현재 부양하는 가족들이 없는 사원들의 이름을 구하라’를 구현하는 방법은 가족 테이블에 부양사번이 없는 사원 이름을 사원 테이블에서 추출 하면 되고, SQL 문장으로 NOT EXISTS, NOT IN , LEFT OUTER JOIN을 사용하여 구현 할 수 있다. 1. NOT EXISTS SELECT 이름 FROM 사원 WHERE NOT EXISTS (SELECT * FROM 가족 WHERE 사번 = 부양사번) 2. NOT IN SELECT 이름 FROM 사원 WHERE 사번 NOT IN (SELECT 부양사번 FROM 가족) 3.LEFT OUTER JOIN SELECT 이름 FROM 사원 LEFT OUTER JOIN 가족 ON (사번 = 부양사번) WHERE 부양사번 IS NULL"
757,,,,,"가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.","가,나,마","나,다,라","가,나,라","나,라,마",,"3 다) 서브쿼리의 결과가 복수 행 결과를 반환하는 경우에는 IN, ALL, ANY 등의 복수 행 비교 연산자와 사용하여야 한다. 마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인 쿼리의 조건과 비교되는 데, SQL Server에서는 현재 지원하지 않는 기능이다."
758,,,,,"SELECT DEPTNO, ENAME, SAL, ( ㄱ ) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) as PCT
FROM EMP;",CUME_DIST(),LAG(),LEAD(),NTILE(),,1 CUME_DIST 함수는 주어진 그룹에 대한 상대적인 누적분포도 값을 반환하는 것으로 분포도 값은 0 초과 1 이하 사이의 값이다.
759,,,,,"SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION;
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION;
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG;
HR) GRANT CREATE VIEW TO HONG;
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR;
SYSTEM) REVOKE CREATE VIEW FROM HR;",HR 유저에게 부여된 EMP 테이블 입력 권한 회수 시 HONG에게 부여된 권한도 함께 회수되었다.,HR이 HONG에게 부여한 EMP 테이블의 조회 권한은 SYSTEM 계정에서 직접 회수가 가능하다.,HR 유저에게 부여된 CREATE TABLE 권한 회수 시 HONG에게 부여된 CREATE TABLE 권한도 함께 회수되었다.,HR 계정에게 부여된 SCOTT.EMP에 대한 SELECT 권한도 함께 회수된다.,,"1 중간관리자가 WITN GRANT OPTION으로 부여 받은 권한을 제 3자에게 부여한 경우, 관리자가 제 3자의 권한을 직 접 회수할 수 없다. 하지만 중간관리자 권한을 회수하면 제 3자에게 부여한 권한도 함께 회수된다. 반대로 WITH ADMIN OPTION으로 부여할 경우 중간관리자 권한 회수 시 제 3자에게 부여한 권한은 함께 회수되지 않는다."
760,,,,,"UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;","GRANT SELECT, UPDATE ON A_User, TB_A TO TEST;","REVOKE UPDATE ON A_User, TB_A TO TEST;","REVOKE SELECT ON A_User, TB_A FROM TEST;",GRANT UPDATE TO TEST;,,1 GRANT privileges ON object TO user;
761,,,,,"증권회사에서 주문을 발주할 때 해당 종목에
대한 호가단위가 있다. 즉, 주문은 10호가를 기준으로
발주할 수가 있어서 어떤 종목을 주문할 때 1003원과 같은
금액으로는 발주할 수 없다. 이처럼 데이터베이스에서 값이 가질
수 있는 조건을 정의하는 것이다.",도메인,선텍도,다중 값 속성,시스템 카탈로그,,1 도메인은 속성이 가질 수 있는 값의 범위이다.
762,,,,,"- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마",논리스키마,내부스키마,개념스키마,외부스키마,,3
763,,,,,"-사용자 관점 또는 사용자 뷰를 표현한다.
-업무상 관련이 있는 데이터만 접근(권한 설정)한다.
-관련된 데이터베이스의 일부만 표시한다.",논리 스키마,내부 스키마,개념 스키마,외부 스키마,,4
764,,,,,"CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER);

INSERT INTO TAB1 VALUES(1,10);
INSERT INTO TAB1 VALUES(2,20);
INSERT INTO TAB1 VALUES(3,30);
COMMIT;

ALTER TABLE TAB1 ADD (COL3 NUMBER);

INSERT INTO TAB1 VALUES(4,40,100);
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1;
DELETE TAB1 WHERE COL1 = 3;

ALTER TABLE TAB1 DROP COLUMN COL1;

ROLLBACK;

SELECT SUM(COL2 + COL3) FROM TAB1;",140,130,120,110,,"1 처음 INSERT 3개의 문장은 COMMIT을 수행했으므로 영구 저장된다. 이후 COL3을 추가하면 이미 입력된 세 개의 행에 대해 NULL을 갖게 된다. 그 뒤 수행하는 INSERT, UPDATE, DELETE 문장은 이어서 실행하는 ALTER TABLE DROP COLUMN 문장으로 인해 자동 확정된다.(DDL AUTO COMMIT). 따라서 ROLLBACK을 수행해도 취소되지 않는다."
765,,,,,"CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY,
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL );
[SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1;
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11');
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = '';
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL;","SQL Server에서 (ㄴ)과같이 데이터를 입력하고, (ㄹ)과 같이 조회하였을 때, 데이터는 조회되지 않는다.","ORACLE에서 (ㄴ)과같이 데이터를 입력하고, (ㄷ)과 같이 조회하였을 때, 데이터는 조회된다.","ORACLE에서 (ㄴ)과같이 데이터를 입력하였을 때, 서비스명 컬럼에 공백문자 데이터가 입력된다.",서비스번호 컬럼에 모든 레코드 중에서 '001'과 같은 숫자형식으로 하나의 레코드만이라도 입력되어 (ㄱ)은 오류 없이 실행된다.,,1
766,,,,,"SELECT LTRIM('ORACLE', 'A') AS C1,
SUBSTR('SQL-SERVER', 3, 3) AS C2,
LENGTH(REPLACE('SQL-SERVER', 'E')) AS C3
FROM DUAL;",,,,,,"2 LTRIM은 왼쪽에서부터 특정 문자열를 지우며, 중간에 있는 문자열은 삭제되지 않는다. 따라서 LTRIM('ORACLE','A'은 왼쪽에 A가 없으므로 ORACLE 그대로 리턴된다. SUBSTR('SQL-SERVER', 3, 3)은 세 번째 위치에서 3개 문자열 을 추출하기 때문에 L-S가 출력된다. 또한, REPLACE에 의해 E가 삭제된 문자열의 길이는 8이 된다."
767,,,,,"Create table Mytest(COL1 number(10));
INSERT INTO Mytest VALUES(2);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET COL1=7 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE CO1=7;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(20);
ROLLBACK TO SV2;
COMMIT;
SELECT * FROM mytest;","7,7,9","7,9,11,9","7,9,11","1,2",,"1 위의 SQL문 면 하단에서 ROLLBACK TO SV2 명령어를 수행하면, SAVEPOINT SV2 지점까지 변경된 것을 모두 취소한다."
768,,,,,"SELECT DEPTNO, SUM(SAL) AS SUM_SAL
FROM EMP
GROUP BY DEPTNO
UNION ALL
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL
FROM EMP;
SELECT DEPTNO, SUM(SAL) AS SUM_SAL
FROM EMP
GROUP BY _______________;","ROLLUP(DEPTNO, ())","ROLLUP(DEPTNO, SAL)",ROLLUP(SAL),ROLLUP(DEPTNO),,"4 ROLLUP은 전체 소계를 함께 출력한다. 즉, ROLLUP(A) => GROUP BY A 결과에 전체 소계 출력"
769,,,,,"SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE ( );",P.사원번호 IS NULL,P.사원번호 IS NOT NULL,P.사원번호 > 0,P.사원번호 = NULL,,1 NOT EXISTS는 OUTER JOIN으로 변경할 경우 NOT NULL칼럼에 대해서 IS NULL로 검사하여 NOT EXISTS를 구현한다.
770,,,,,"UPDATE A_User.TB_A
SET col1='AAA'
WHERE col2=3","GRANT SELECT, UPDATE ON A_User.TB_A TO B_User;",DENY UPDATE ON A_User.TB_A TO B_User;,REVOKE SELECT ON A_User.TB_A FROM B_User;,"GRANT SELECT, UPDATE TO B_User;",,"1 권한을 부여하는 명령어는 GRANT이며, WHERE 조건의 데이터를 찾기 위한 SELECT 권한과 데이터 변경을 위한 UPDATE 권한이 필요하다."
771,,,,,"SELECT * FROM Orders
WHERE ( ㄱ ) (SELECT * FROM Customers WHERE ( ㄴ ));",ㄱ: NOT EXISTS ㄴ: Customers. id <> Orders. id,ㄱ: NOT EXISTS ㄴ: Customers. id = Orders. id,ㄱ: EXISTS ㄴ: Customers. id <> Orders. id,ㄱ: EXISTS ㄴ: Customers. id = Orders. id,,"2 Customers 테이블에서 존재하지 않은 고객id를 식별하기 위해서는 NOT EXISTS를 사용하고 WHERE구에 ""Customers. id = Orders. id""를 사용해야 한다."
772,,,,,"가. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
나. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
다. 데이터베이스 용량산정을 수행한다.
라. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
마. 성능관점에서 데이터 모델을 검증한다.
바. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.",가-다-라-나-바-마,가-다-라-바-나-마,가-나-다-라-바-마,가-나-다-라-마-바,,1
773,,,,,"가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1:M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.","가,나,다,라","가,나,다","가,나",가,,3
774,,,,,"SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);",Looping Sub Query,Correlated Sub Query,Early Filter형 Sub Query,Service Sub Query,,"2 상호연관 서브쿼리는 메인쿼리 값을 서브쿼리가 사용하고 서브쿼리의 값을 받아서 메인쿼리가 계산되는 쿼리이다. 문제에 나온 SQL문에서 EMP 테이블은 메인쿼리이고 EMP_T 부분은 서브쿼리이다. 즉, EMP_T의 서브쿼리가 실행되어서 1이 나오면 메인쿼리의 WHERE절 조건과 비교된다."
775,,,,,"SELECT ( ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;",Deptno 와 Sal,Sal,Deptno,Empno,,4 SELECT구에는 GROUP BY절에 있는 칼럼만 나와야 한다.
776,,,,,"ㄱ : SELECT SUM(SAL) FROM EMP
GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
GROUP BY ROLLUP(DEPTNO);",ㄱ의 SQL문은 전체합계는 출력되지 않는다.,ㄴ은 부서별 합계와 전체합계가 출력된다.,ㄱ과 ㄴ의 결과 행 수는 동일하다.,ㄱ은 부서별 합계를 출력한다.,,3 ㄱ과 ㄴ의 SQL문의 행 수는 다르다. 왜냐하면 ROLLUP은 전체합계가 추가적으로 출력된다.
777,,,,,"SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;",ORDER BY 3,ORDER BY COUNT(*),ORDER BY CNT DESC,ORDER BY JOB,,"1 지문의 SQL문은 SELECT구에 칼럼(JOB,ROWCNT)이 2개 있다. ①번은 칼럼의 수가 2개뿐인데 3번째 칼럼이 존재하지 않기 때문에 사용할 수 없다."
778,,,,,"SELECT COUNT(DECODE(DEPTNO,10,1)) AS ""10"",
COUNT(DECODE(DEPTNO,20,1)) AS ""20"",
COUNT(DECODE(DEPTNO,30,1)) AS ""30""
FROM EMP;"," SELECT * FROM EMP UNPIVOT (COUNT(*) FOR DEPTNO IN (10,20,30));","SELECT * FROM EMP UNPIVOT (COUNT(DEPTNO) FOR DEPTNO IN (10,20,30));","SELECT * FROM (SELECT EMPNO, JOB, DEPTNO FROM EMP) PIVOT (COUNT(DEPTNO) FOR EMPNO IN (10,20,30));","SELECT * FROM (SELECT EMPNO, DEPTNO FROM EMP) PIVOT (COUNT(EMPNO) FOR DEPTNO IN (10,20,30));",,"4 10, 20, 30번 부서원의 수를 각 컬럼별로 표현한 것은 LONG -> WIDE로의 변환을 수행하는 PIVOT의 결과로 대체할 수 있다. PIVOT 절에서 IN 앞의 컬럼은 서로 다른 컬럼으로 분해할 대상이 명시되어야 하므로 DEPTNO가 들어가야 한다."
779,,,,,"SELECT LEVEL,
LPAD(' '.4 * (LEVEL-1) || EMPNO,
MGR, () AS ISLEAF FROM SCOTT.EMP
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;",CONNECT_BY_ROOT,SYS_CONNECT_BY_PATH,CONNECT_BY_ISCYCLE,CONNECT_BY_ISLEAF,,4
780,,,,,"create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 번호 필드에 널(NULL)값이 존재할 수 있기 때문이다.","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 월급 필드에 널(NULL)값이 존재할 수 있기 때문이다.",SQL A와 SQL B의 결과는 항상 다르다.,SQL A와 SQL B의 결과는항상 같다.,,"2 count()는 행 수를 계산하는 집계함수이다. 집계함수의 특성은 NULL 값을 제외한다는 것이다. 그래서 NULL 값이 존재하는 경우 집계 결과는 달라질 수 있다. 번호 칼럼은 PK이므로 값이 무조건 들어있다. 즉, COUNT(번호)는 모든 행의 개수를 출력한다. 반면에 월급 칼럼에 NULL이 들어있을 경우에는 WHERE 월급>=100000 OR 월급<100000 이 부분에서 NULL은 정상적인 비교가 되지않아 행이 조회되지 않는다. 즉 출력되는 행의 개수가 달라질 수 있다는 의미이다."
781,,,,,"SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'",SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B ON A.DEPTNO = B.DEPTNO WHERE 1=1 AND B.DNAME = 'KIM';,SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'KIM') WHERE 1=1;,SELECT * FROM SCOTT.EMP A RIGHT OUTER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'KIM') WHERE 1=1;,SELECT * FROM SCOTT.EMP A LEFT OUTER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'KIM') ;,,1 조인 조건과 조회 조건이 분리되어야 하므로 조회 조건은 WHERE절로 분리되어야 한다. OUTER JOIN이 아닌 INNER JOIN이므로 INNER JOIN에 조회 조건 분리가 된 ①번이 맞다.
782,,,,,"CREATE TABLE SQLD_29 (N1 NUMBER);
INSERT INTO SQLD_29 VALUES(1);
INSERT INTO SQLD_29 VALUES(2);
CREATE TABLE TMP_SQLD_29 (N1 NUMBER);
INSERT INTO TMP_SQLD_29 VALUES(1);
TRUNCATE TABLE TMP_SQLD_29;
ROLLBACK;
COMMIT;
SELECT SUM(N1) FROM SQLD_29;",4,3,1,,,"2 CREATE, TRUNCATE 같은 DDL은 묵시적으로 COMMIT을 수행하므로 ROLLBACK 명령어를 수행하면 마지막 COMMIT을 수행한 6번째 행으로 이동한다."
783,,,,,"(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","가, 다, 라, 마","가, 나, 다, 라","가, 나, 다","가, 다, 라",,1
784,,,,,"SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
ORDER BY PLAYER_NAME, POSITION, BACK_NO DESC;","ORDER BY 1 DESC, 2, 백넘버","ORDER BY PLAYER_NAME ASC, 2, 3","ORDER BY 선수명, 2, DESC 백넘버","ORDER BY 선수명 ASC, 포지션, 3 DESC",,4 ORDER BY절에서 정렬 기준이 생략되면 fault로 ASC 정렬이 된다. ORDER BY절에는 칼럼명 대신에 SELECT절에 기술한 칼럼의 순서번호나 칼럼의 ALIAS명을 사용할 수 있다.
785,,,,,"가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.","가,다","나,라","가,라","가,나",,3 데이터베이스 식별자는 대표성 여부에 따라서 주식별자와 보조 식별자로 구분된다. 주식별자는 후보키 중에서 엔터티를 대표하는 식별자로 다른 엔터티와 참조하여 연결할 수 있는 식별자이다.
786,,,,,"SELECT *
FROM SQLD_33
WHERE EMP_NAME LIKE 'A%'",테이블의 EMP_NAME이 A 또는 a로 끝나는 모든 ROW,테이블의 EMP_NAME이 A로 끝나는 모든 ROW,테이블의 EMP_NAME이 A로 시작하는 모든 ROW,테이블의 EMP_NAME이 A 또는 a로 시작하는 모든 ROW,,3 특정 문자로 시작하는 것을 조회하기 위해서는 like문을 사용해야 한다. 그리고 'A%'는 A로 시작하는 것을 조회한다.
787,,,,,"CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER);
INSERT INTO TAB1 VALUES(100, 100);
COMMIT;",ALTER TABLE TAB1 DROP COLUMN COL4;,ALTER TABLE TAB1 MODIFY COL2 DEFAULT 100 NOT NULL;,ALTER TABLE TAB1 ADD COL5 NUMBER NOT NULL;,"ALTER TABLE TAB1 ADD (COL3 NUMBER, COL4 VARCHAR2(10));",,3 새로운 컬럼 추가 시 기존 데이터의 새 컬럼 데이터는 NULL로 삽입된다. 따라서 DEFAULT 값 선언 없이는 NOT NULL 속성을 갖는 컬럼 추가는 불가능하다.
788,,,,,"1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다.",차수,인스턴스,도메인,카디날리티,,"3 예를 들어 도메인이란, 성별이라는 속성에서 값이 가질 수 있는 허용 범위를 나타낸다. 즉, 성별의 경우 남자는 'M', 여자는 'F'의 값을 가진다."
789,,,,,"Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park;
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","Kim : INSERT INTO R VALUES(500, 600);",Park : DELETE FROM R WHERE B = 800;,"Park : INSERT INTO R VALUES(400, 600);",Park : SELECT * FROM R WHERE A = 400;,,"2,4 1. Lee : GRANT SELECT, INSERT, DELETE ON R TO Kim WITH GRANT OPTION; -> Kim에게 테이블 R에 SELECT, INSERT, DELETE 권한을 주면서, Kim 이 다른 유저에게 테이블 R에 동일한 권한을 줄 수 있다. 2. Kim : GRANT SELECT, INSERT, DELETE ON R TO Park; -> Kim이 테이블 R에 Lee에게 받은 권한을 Park에게 준다. 3.Lee : REVOKE DELETE ON R FROM Kim; -> Kim에서 테이블 R의 DELETE 권한을 취소한다. 4. Lee : REVOKE INSERT ON R FROM Kim CASCADE; -> Kim과 Park에서 INSERT 권한을 취소한다. WITH GRANT OPTION으로 Kim으로부터 받은 Park의 권한은 CASCADE 명령어로 받은 권한을 취소 할 수 있다."
790,,,,,"-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.",추상적 데이터 모델링,개념적 데이터 모델링,논리적 데이터 모델링,물리적 데이터 모델링,,"2 -전시적 관점에서 기업의 데이터를 모델링한다. -추상화 수준이 가장 높은 모델링이다. -계층형 데이터 모델, 네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링을 한다."
791,,,,,"SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;",FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY,FROM -> WHERE -> GROUP BY -> SELECT -> HAVING -> ORDER BY,FROM -> WHERE -> HAVING -> GROUP BY -> ORDER BY -> SELECT,FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> SELECT,,1 FROM 절에서 테이블 목록을 가져오고 WHERE 절에서 검색 조건에 불일치하는 행을 제외한 후 GROUP BY 절에서 명시된 행의 값을 그룹화한다. HAVING 절은 GROUP BY 절로 정렬이 된 데이터를 대상으로 조건을 정의한 후 SELECT 절에서 조회 후 ORDER BY 절에서 명시한 칼럼값을 기준으로 정렬하여 출력한다.
792,,,,,"SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;",4,3,"3,5","3,4",,3 ROUND 함수의 첫 번째 인자값인 3.47을 소수 첫째 자리까지 반올림한다.
793,,,,,"Update emp set sal=1000
where deptno=100;",grant create table on 홍길동 on emp;,"revoke select, update on emp;","grant select, update on emp;","grant select, update on emp to 홍길동;",,4 grant는 권한을 부여하는 SQL문이고 revoke는 권한을 삭제하는 SQL문이다. grant구의 문법은 grant 권한 on 테이블 to 사용자이다.
794,,,,,"SELECT 1 FROM DUAL
UNION
SELECT 2 FROM DUAL
UNION
SELECT 1 FROM DUAL;","1,2,1","2,1","1,2",1,,3
795,,,,,"select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);",select * from Mytest where COL1 = 1 or (COL2 = 3 or COL2 = 4);,"select * from Mytest where COL1 in (1,3) or COL2 in (1,4);","select * from Mytest where COL1 in (1,3) and COL2 in (1,4);",select * from Mytest where COL1 = 1 and (COL2 = 3 or COL2 = 4);,,"4 주어진 SQL문은 COL1, COL2 값이 각각(1,3) (1,4)인 행들만 조회되는 SQL문이다. 이와 같은 값을 반환하는 보기는 COL1이 1이면서 COL2가 3 또는 4인 값을 조회하는 ④번 보기이다."
796,,,,,"SELECT *
FROM TAB1 JOIN TAB2
ON TAB1.COL1 = TAB2.COL1
LEFT OUTER JOIN TAB3
ON TAB1.COL2 = TAB3.COL2;","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2(+);","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2(+);","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2;","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2;",,2 TAB1과 LEFT OUTER JOIN인 테이블은 TAB3이므로 TAB1과 TAB3의 관계에만 TAB3의 컬럼에 (+)를 붙여주면 된다.
797,,,,,"SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, ( ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;",CONNECT_BY_LEAF,SYS_CONNECT_BY_PATH,CONNECT_BY_ISCYCLE,CONNECT_BY_ISLEAF,,"2 -CONNECT_BY_ISLEAF : 전개 과정에서 해당 데이터가 리프 데이터면 1, 아니면 0을 반환한다. -CONNECT_BY_ISCYCLE : 전개 과정에서 자식을 갖는데, 해당 데이터가 조상으로 존재하면1, 그렇지 않으면 0을 반환한다. 여기서 조상이란 자신으로부터 루트까지의 경로에 존재하는 데이터를 말한다. -SYS_CONNECT_BY_PATH : 하위 레벨의 칼럼까지 모두 표시해준다."
798,,,,,"SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;",CNT 칼럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000사이에 존재하는 상품의 개수를 구한 것이다.,CNT 칼럼은 분류코드별 평균상품가격을 서로 비교하여 -10000 ~ 10000 사이에 존재하는 분류코드의 개수를 구한 것이다.,WINDOW FUNCTION의 ORDER BY 절로 인하여 문법오류이다.,WINDOW FUNCTION을 GROUP BY(분류코드)절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다.,,2 CNT 칼럼은 분류코드를 GROUPING된 집합을 원본집합으로 하여 분류코드별 평균상품가격을 서로 비교하고 현재 읽혀진 상품분류코드의 평균가격 대비 -10000 ~ +10000 사이에 존재하는 분류코드의 개수를 구한 것이다.
799,,,,,"SELECT 10 + 20 * (( )NULL, 0.1, 0.2))
FROM DUAL;
결과 : 14",COALESCE,NVL2,NVL,ISNULL,,2 위의 SQL문에서 NVL2 함수의 첫 번째 인자값이 NULL이기 때문에 0.2를 반환한다. 그리고 10+20*0.2가 되어 14를 반환한다.
800,,,,,"Create table test20 (col1 number(10));
INSERT INTO test20 VALUES(1);
INSERT INTO test20 VALUES(4);
SAVEPOINT SV1;
UPDATE test20 SET COL1=8 WHERE COL1=2;
SAVEPOINT SV1;
DELETE test20 WHERE COL1 > =2;
ROLLBACK TO SV1;
INSERT INTO test20 VALUES(3);
SELECT MAX(COL1) FROM test20;",,,,,,2 SAVEPOINT가 동일할 때 ROLLBACK을 수행하면 가장 마지막 시점의 SAVEPOINT 지점으로 ROLLBACK 된다.
801,,,,,"SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","ORDER BY, SELECT, WHERE, GROUP BY, FROM","SELECT, FROM, WHERE, GROUP BY, ORDER BY","FROM, WHERE, GROUP BY, SELECT, ORDER BY","WHERE, GROUP BY, ORDER BY, FROM, SELECT",,3
802,,,,,"가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb) 가 있 는가?","가,나다,라","가,나,다","가,나,라","가,다,라",,1
803,,,,,"ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","ㄱ:8, ㄴ:8","ㄱ:8, ㄴ:10","ㄱ:10, ㄴ:8","ㄱ:10, ㄴ:10",,3 COUNT(칼럼명)을 실행하면 NULL 값은 제외된다.
804,,,,,"(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.",일반속성 - 기본키 속성 - 외래키 속성,파생속성 - 외래키 속성 - 기본키 속성,외래키속성 - 기본키 속성 - 파생 속성,기본키 속성 - 외래키 속성 - 일반 속성,,4 기본키는 엔터티를 대표하는 키로 최소성과 유일성을 만족해야 한다. 외래키는 두 개의 테이블 간에 연결을 설정하기 위한 키이다.
805,,,,,"[테이블]
고객(고객번호(PK), 이름, 등급)
구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK))
* 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다.
[SQL 문장]
SELECT A.이름 , A.등급
FROM 고객 A
(ㄱ)
GROUP BY A.이름 ,A.등급
(ㄴ)",(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : WHERE B.구매번호〉=3,(ㄱ) : LEFT OUTER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B.구매번호) >=3,(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING COUNT(B. 구매번호) >=3,(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B. 구매번호)〉=3,,3
806,,,,,"SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;","EMP, DEPT, SALARY","EMPNO, DEPTNO, SALARY","EMP, DEPT, SAL","EMPNO, DEPTNO, salary",,4 세 번째 칼럼명 Alias를 사용했으므로 salary가 된다. 또한 deptno는 oracle에서 대문자로 조회되고 SQL Server에서는 칼럼명 그대로 조회된다.
807,,,,,"SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;",SAL의 마지막 행은 급여가 가장 작은 사람이다.,SAL의 값에 따라서 데이터를 4등분으로 분류해서 DATA 필드로 조회된다.,SAL이 큰 순으로 조회된다.,DATA 필드가 가질 수 있는 값의 범위는 0~3까지이다.,,4 NTILE 윈도우 함수는 데이터를 ARGUMENT 값으로 N등분하는 함수이다. 위의 예처럼 NTILE(4)는 1부터 4까지 4등분한다.
808,,,,,"insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;","4,2,3","2,2,3","2,1,3","2,3,4",,"2 ㄱ은 COUNT(COL1)을 사용하므로 NULL은 제외되기 때문에 2가 된다. 그리고 ㄴ은 IN구를 사용해서 NULL까지 조건으로 넣었지만, 12,10만 조회된다. 즉, NULL은 제외된다. 그리고 ㄷ은 COL1로 GROUP BY하였으므로 3건이 된다."
809,,,,,"가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.",가 -> 라 -> 나 -> 마 -> 다,나 -> 가 -> 마 -> 라 -> 다,가 -> 나 -> 라 -> 마 -> 다,가 -> 나 -> 다 -> 라 -> 마,,4 가->나->다->라->마 순서대로 해시 조인을 실행한다.
810,,,,,"[SQL]
SELECT 상품분류코드
,AVG(상품가격) AS 상품가격
,COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING
AND 10000 FOLLOWING) AS 유사개수
FROM 상품
GROUP BY 상품분류코드;",유사개수 컬럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품의 개수를 구한 것이다.,유사개수 컬럼은 상품분류코드별 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품분류코드의 개수를 구한 것이다.,WINDOW FUNCTION의 ORDER BY절에 AVG 집계 함수를 사용하였으므로 위의 SQL은 오류가 발생한다.,WINDOW FUNCTION을 GROUP BY 절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다.,,"2 GROUP BY 절의 집합을 원본으로 하는 데이터를 WINDOW FUNCTION과 함께 사용한다면 GROUP BY 절과 함께 WINDOW FUNCTION을 사용한다고 하더라도 오류가 발생하지 않으며, 유사개수 컬럼 은 상품분류코드로 GROUPING된 집합을 원본집합으로 하여 상품분류코드별 평균상품가격을 서로 비교하여 현재 읽혀진 상품분류코드의 평균가격 대비 -10000 ~ +10000사이에 존재하는 상품분류코 드의 개수를 구한 것이다."
811,,,,,"MytestA 테이블 칼럼: NO, C1
MytestB 테이블 칼럼: NO, C2","SELECT A.NO, A.C1, B.C2 FROM MytestA A JOIN MytestB B ON (A.NO = B.NO);","SELECT A.NO, A.C1, B.C2 FROM MytestA A CROSS JOIN MytestB B;","SELECT NO, A.C1, B.C2 FROM MytestA A CROSS JOIN MytestB B;","SELECT NO, A.C1, B.C2 FROM MytestA A NATURAL JOIN MytestB B;",,"2 ①,③,④번 보기는 두 개의 테이블에서 동일한 이름을 가지는 칼럼에 대해서 조인을 수행하는 방식이고 ②번 보기는 두 테이블의 모든 데이터에 대해서 조인을 수행하는 CROSS JOIN방식이다."
812,,,,,"회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다.
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다.",개인회원 또는 법인회원 둘 중 하나로 주문 가능할 경우 고객과 주문 엔터티는 상호포함적 관계이다.,고객과 주문내역 엔터티 간의 '주문' 관계는 행위에 의한 관계이다.,부서와 사원 엔터티 간의 '소속' 관계는 존재적 관계이다,관계는 존재적 관계와 행위에 의한 관계로 나누어 볼 수 있다.,,1 개인 회원 또는 법인 회원 중 하나만 주문이 가능한 경우 두 엔터티의 관계는 상호배타적 관계이다.
813,,,,,"-파티셔닝 할 항목을 관리자가 직접 지정하는 방법으로 제품에 대해서 파티션을 생성하였다.
-데이터 보관 주기에 따라서 쉽게 데이터를 삭제할 수 없다.",HYBRID PARTITION,LIST PARTITION,HASH PARTITON,RANGE PARTITION,,2 Range Partition은 데이터 값의 범위를 기준으로 파티션을 수행하고 List Partition은 특정 값을 지정해서 파티션을 수행한다. 또한 Hash Partition은 해시 함수를 적용하여 파티션을 수행하는 것이다. Composite Partition은 범위와 해시를 복합적으로 사용해서 파티션을 수행한다.
814,,,,,"SELECT * FROM Mytesta a full outer join Mytestb b
on a.col1 = b.col1;",SELECT * FROM Mytesta a left outer join Mytestb b on a.col1 = b.col1 union SELECT * FROM Mytesta a right outer join Mytestb b on a.col1 = b.col1;,SELECT * FROM Mytesta a cross join Mytestb b on a.col1 = b.col1,SELECT * FROM Mytesta a left outer join Mytestb b on a.col1 = b.col1 union all SELECT * FROM Mytesta a left outer join Mytestb b on a.col1 = b.col1;,SELECT * FROM Mytesta group by col1;,,1 위의 SQL문에서 FULL OUTER JOIN의 결과값은 'LEFT OUTER JOIN' 결과와 'RIGHT OUTER JOIN'결과를 UNION 연산하는 결괏값과 동일하다.
815,,,,,"CREATE TABLE TAB1(
COL1 VARCHAR(10) PRIMARY KEY,
COL2 NUMBER NOT NULL,
COL3 CHAR(10) NOT NULL,
COL4 DATE NOT NULL);","INSERT INTO TAB1 VALUES('0003', 40, 'CCC', '2024/01/01');","INSERT INTO TAB1 VALUES('0002', '30', '1000', CURRENT_DATE);","INSERT INTO TAB1 VALUES('0001', '20', 'BBB', SYSTIMESTAMP);","INSERT INTO TAB1 VALUES(1, 10, 'AAA', SYSDATE);",,1 1번에서 COL4의 값은 문자상수이므로 날짜 변환 후 입력을 해야 한다. DBMS의 기본 날짜 포맷이 YYYY/MM/DD가 아닌 경우는 이 문장은 에러가 발생한다.
816,,,,,"[PL/SQL]
create or replace procedure insert_dept authid_current_user
as
begin
(ㄱ)
INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
SELECT DEPTNO, DNAME, LOC
FROM TMP_DEPT;
commit;
end;",execute 'TRUNCATE TABLE DEPT';,execute immediate 'TRUNCATE TABLE DEPT';,DELETE FROM DEPT;,TRUNCATE TABLE DEPT;,,2 PL/SQL 에서는 동적 SQL 또는 DDL 문장을 실행할 때 EXECUTE IMMEDIATE 사용하여야 한다. ③번은 ROLLBACK이 가능하도록 삭제하는 것이 아니므로 옳은 답이 아니다.
817,,,,,"SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;",에러가 발생한다.,22 - 04 - 30 00 : 00 : 00 2022,2022/04/30 00 : 00 : 00 2022,2022 - 04 - 30 00 : 00 : 00 2022,,1 SYSDATE는 Oracle에서 오늘의 날짜와 시간을 가지고 있는 Date 타입이다.따라서 Date 타입을 다시 TO_DATE로 형 변환을 하면 동일 타입을 변환하기 때문에 오류가 발생한다. 즉 이러한 경우는 TO_CHAR를 사용해서 문자형 타입으로 변환해야 한다.
818,,,,,"가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.",가->나->다->마->바->라,가->나->라->다->마->바,나->가->다->라->마->바,가->나->다->라->마->바,,4
819,,,,,"SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;",실행 결과로 아무것도 출력되지 않는다.,위의 SQL문은 실행되지 않는다.,UNION ALL을 사용해서 합집합을 만들고 중복을 제거한다.,"위의 SQL문 실행 결과는 A, 1, 1 ,A가 조회된다.",,2 ①오류 발생으로 실행되지 않는다. ③UNION의 설명이다. ④조회되는 데이터의 구조가 다르기 때문에 오류가 발생한다.
820,,,,,"SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2
FROM DUAL;","8,3","8,1","2,3","2,1",,"3 둘 다 숫자(\d)가 2회 이상 나열된 단어의 수를 찾는 문제이므로 C1은 2, C2는 3개가 리턴된다."
821,,,,,"CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);",4,3,2,1,,1 (1)번은 NAME에 DATE 타입의 데이터를 입력하여 오류가 발생한다. (2)번은 AGE가 NOT NULL인데 null을 입력하여 오류가 발생한다. (3)번은 ID의 기본키 값을 입력하지 않아서 오류가 발생한다.
822,,,,,"CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);",UPDATE T_ORDER SET C1=1,DELETE FROM T_ORDER,DELETE T_ORDER,"INSERT INTO T_ORDER VALUES(2, SYSDATE-1, 'ABC')",,4 ④번 보기는 T_ORDER 테이블명 뒤에 특정 속성들을 지정하지 않았다. VALUES 뒤에는 테이블의 전체 속성값들이 부여되어야 하는데 VALUES 뒤에 속성값 중 하나가 모자라 에러가 뜬다.
823,,,,,"SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY ROLLUP (COL1, COL2);

SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY GROUPING SETS ( )",UNION ALL,MINUS,EXPECT,UNION,,"1 ROLLUP은 그룹된 칼럼의 Subtotal 생성하기 위해서 사용된다. 그룹의 수가 N개일 때 N+1개의 Subtotal이 생성된다. 그리고 GROUPING SETS은 여러 그룹질의를 UNION ALL과 같은 결과를 만들어서 소계, 합계를 집계할 수 있다."
824,,,,,"CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;",SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY 2;,SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY N2;,SELECT * FROM MYTEST ORDER BY 2;,SELECT N1 FROM MYTEST ORDER BY N2;,,1 ①번 보기에서 ORDER BY 항목은 반드시 SELECT 목록에 있는 칼럼의 자릿수를 사용해야 한다.
825,,,,,"집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}",Product,Intersection,Difference,Union,,"2 집합 C는 집합 A와 집합 日의 교집합이며, 데이터베이스에서 교집합 기능을 하는 집합 연산 Intersection 이다."
826,,,,,"SELECT * FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNAME = 'SALES';",SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B ON A.DEPTNO = B.DEPTNO WHERE 1=1 AND B.DNAME = 'SALES';,SELECT * FROM SCOTT.EMP A CROSS JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'SALES');,SELECT * FROM SCOTT.EMP A RIGHT OUTER JOIN SCOTT.DEPT B ON (A.DEPTNO = B.DEPTNO AND B.DNAME = 'SALES');,SELECT * FROM SCOTT.EMP A LEFT OUTER JOIN SCOTT.DEPT B ON(A.DEPTNO = B.DEPTNO AND B.DNAME 'SALES');,,1 OUTER JOIN 혹은 CROSS JOIN이 아닌 INNER JOIN이므로 ①번이 된다.
827,,,,,"1. Nested loops
2. Hash join
3. TABLE ACCESS (FULL) TABLE1
4. TABLE ACCESS (FULL) TABLE2
5. TABLE ACCESS (BY ROWID) TABLE3
6. INDEX (UNIQUE SCAN) PK_TABLES3","6,5,4,3,2,1","3,4,6,2,5,1","1,2,3,4,5,6","3,4,2,6,5,1",,4 SQL 문장에서 실행 계획을 읽는 순서는 우선 안에서 밖으로 읽으면서 같은 레벨에서는 위에서 아래로 읽는다.
828,,,,,"CREATE TABLE MYTEST (N1 NUMBER(10), N2 NUMBER(10));
INSERT INTO MyTEST VALUES (100, 200);
INSERT INTO MyTEST VALUES (200, 300);
SAVEPOINT T1;
UPDATE MYTEST SET N1=300 WHERE N2=200;
SAVEPOINT T1;
DELETE MYTEST WHERE N1>=200;
ROLLBACK TO SAVEPOINT T1;
SELECT MAX(N1) FROM MYTEST;",200,100,300,,,"3 SAVEPOINT가 중복될 경우 ROLLBACK TO SAVEPOINT을 수행하면, 중복된 SAVEPOINT 중 맨 뒤에 있는 SAVEPOINT 지점으로 ROLLBACK 된다."
829,,,,,"SELECT * FROM EMP
WHERE EMPNO LIKE '100%';",기능상으로는 문제가 없지만 성능 문제가 있다.,EMP 테이블을 FULL SCAN한 것은 인덱스가 없어서이다.,"LIKE 조건을 사용하지 말고 "">""를 사용해야 한다.",내부적으로 형변환이 발생했다.,,2 EMPNO는 기본키이므로 자동으로 인덱스가 생성된다. FULL SCAN이 된 것은 LIKE 조건에서 숫자 칼럼과 문자값 간에 형 변환이 발생해서이다.
830,,,,,"INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1,8,9","1,8,11,8","1,8,11","1,2",,1 위의 SQL문의 맨 하단의 ROLLBACK TO SV2 명령어를 수행하면 SAVEPOINT SV2 지점까지 변경된 것을 모두 취소한다.
831,,,,,"SELECT PLAYER_NAME 선수명, E_PLAYER_NAME 선수영문명
FROM PLAYER
WHERE E_PLAYER_NMAE_LIKE '_A%';",위치에 상관없이 선수의 영문 이름에 A를 포함하는 선수들의 이름,선수의 영문 이름이 A로 시작하는 선수들의 이름,선수의 영문 이름이 A나 a로 시작하는 선수들의 이름,선수의 영문 이름의 두 번째 문자가 A인 선수들의 이름,,"4 ""_""와 ""%""는 와일드카드로 하나의 글자 또는 모든 문자를 대신하여 사용이 되므로 두 번째 문자가 대문자 A인 경우만 출력된다."
832,,,,,"SELECT 학생.이름 학생명, 교수.이름 교수명
FROM 학생 _________ 교수
ON 학생.교수번호 = 교수.교수번호;",INNER JOIN,FULL OUTER JOIN,RIGHT OUTER JOIN,LEFT OUTER JOIN,,"4 왼쪽에 배치된 학생 테이블 기준, 지도 교수가 없어도 교수 정보를 NULL로 출력하려면 LEFT OUTER JOIN이 수행 되어야 한다."
833,,,,,"INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1,2","1,9,11,9","1,9,11","1,7,9",,4 SQL문의 맨 하단에서 ROLLBACK TO SV2명령어를 수행하면 SAVEPOINT SV2 지점까지 변경 된 것을 모두 취소한다.
834,,,,,"-다른 속성에 영향을 받아 발생하는 속성으로서 보통 계산된 값들이 이에 해당한다.
-다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많다.
-가급적 속성을 적게 정의하는 것이 좋다.",파생 속성,설계 속성,기본 속성,연관 속성,,1 다른 속성으로부터 계산이나 변형이 되어 생성되는 속성을 파생속성이라고 한다.
835,,,,,"가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.","가,나,다,라","나,다,라","가,나,라","가,나,다",,1
836,,,,,"가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 "">"", ""<"", "">="", ""<=""를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.",라,다,나,가,,"2 Non-EQUI join은 "">"",""<"","">="",""<=""를 사용하는 조인으로 대부분의 데이터베이스에서 잘 사용하지 않는 조인이다."
837,,,,,"SELECT * FROM test24
minus
SELECT 1 FROM DUAL;",1,"1,2","2,3","1,2,3",,"3 MINUS는 Oracle에서 차집합을 구하는 것이다. 즉 위의 SQL에서 1을 제외하게 되므로 2,3이 된다."
838,,,,,"create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;","3,null","3,3","3,2","3,1",,"4 ""select count(학번) from 학생""은 학생 테이블에 총 3개를 삽입했으므로 3이 된다. 그리고 ""delete from 학과 where 학과번호 =2""를 삭제한다. 학과 테이블에서 학과번호 ""2""를 삭제하면 학생 테이블과 외래키 관계로 있고 ""on delete cascade""가 설정되어 있다. 따라서 학생 테이블에 학과번호 2번은 모두 자동 삭제된다. 그러면 학생 테이블에는 학과번호 ""1""번만 남게 되기 때문에 1개이다."
839,,,,,"SQL1) SELECT COUNT(GRADE) FROM EMP;
SQL2) SELECT GRADE FROM EMP WHERE GRADE IN('차장', '부장', '널');
SQL3) SELECT GRADE, COUNT(*) FROM EMP GROUP BY GRADE;","670, 40, 6","645, 15, 6","645, 40, 5","670, 15, 5",,2 SQL1) 645건 : 사원 500명 + 대리 100명 + 과장 30명 + 차장 10명 + 부장 5명 SQL2) 15건 : 차장10명 + 부장 5명 SQL3) 6건 : 5개 직급 + NULL
840,,,,,"SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;",오늘 날짜로부터 6일 후 두 번째 월요일을 출력한다.,오늘 날짜로부터 6개월 후 첫 번째 월요일을 출력한다.,오늘 날짜로부터 6개월 후 두 번째 월요일을 출력한다.,오늘 날짜로부터 6일 후 첫 번째 월요일을 출력한다.,,"2 ADD_MONTHS 함수는 6개월을 더하고 NEXT_DAY 함수는 지정된 요일의 첫 번째 날짜를 출력한다. 즉, 문제에서는 6개월 후 첫 번째 월요일을 출력한다."
841,,,,,"가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.","가,마","다,라","다,마","가,나",,"1 성능을 고려한 데이터베이스 모델링 시에도 가장 먼저 정규화를 수행해서 데이터 모델의 독립성을 향상시켜야 한다. 그리고 필요에 따라서 트랜잭션 유형, 반정규화 등을 수행하고 제일 마지막에는 성능관점에서 데이터 모델을 검증해야 한다."
842,,,,,"(1) SELECT A.ID, B.ID
FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2) SELECT A.ID, B.ID
FROM TBL1 A LEFT OUTER JOIN TBL2 B
ON A.ID = B.ID
UNION
SELECT A.ID, B.ID
FROM TBL1 A RIGHT OUTER JOIN TBL2 B
ON A.ID = B.ID
(3) SELECT A.ID, B.ID
FROM TBL1 A, TBL2 B
WHERE A.ID = B.ID
UNION ALL
SELECT A. ID, NULL
FROM TBL1 A
WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
UNION ALL
SELECT NULL, B.ID
FROM TBL2 B
WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","1,2,3","2,3","1,3","1,2",,2
843,,,,,"ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT
WHERE DEPT = '영문학과';","ㄱ:200, ㄴ:200, ㄷ:50","ㄱ:200, ㄴ:3, ㄷ:50","ㄱ:200, ㄴ:3, ㄷ:1","ㄱ:3, ㄴ:3, ㄷ:1",,"2 ㄱ은 STUDENT 테이블을 조건없이 조회하는 것이므로 200=50+100+50이 된다. 그리고 ㄴ은 ""DISTINCT""를 사용했으므로 학과명이 중복되면 한 번만 출력한다. 문제에서는 영문학과, 법학과, 수학과가 있으므로 3이 되고 ㄷ은 WHERE절에 ""영문학과""만 조회하므로 50이 된다."
844,,,,,"Create table Mytest
(
A number(10) primary key,
B number(10),
C date,
D varchar2(10)
);","INSERT into Mytest values(4,32,20220420,'004')","INSERT into Mytest values(3,200,sysdate-10,'004')","INSERT into Mytest values(2,1111,to_date('20230101','YYYYMMDD'),'003')","INSERT into Mytest values(1,12,sysdate,002)",,1 ①의 경우 20220420이라는 숫자형 값을 바로 DATE에 넣어 데이터타입 불일치 에러가 발생한다. TO_DATE(20220420)으로 바꾸어야 한다.
845,,,,,"가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","나, 라","다, 라","가, 다","가, 나",,3
846,,,,,"SELECT REGEXP_SUBSTR('ORA-00600 Oracle SQL-Server 50', '[^0-9]+') ""REGEXPR_SUBSTR""
FROM DUAL;",ORA- Oracle SQL-Server,ORA-,00600 50,50,,2 [^0-9]+ 는 숫자가 아닌 값이 여러 개 반복되는 문자열을 의미한다. REGEXP_SUBSTR은 이 패턴에 해당하는 값을 처음부터 찾아 단 하나의 문자열을 추출하므로 ORA-만 추출된다.
847,,,,,"INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;",6,5,3,2,,3
848,,,,,"SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';",테이블의 EMP_NAME이 A 또는 a로 끝나는 모든 행이 검색된다.,테이블의 EMP_NAME이 K로 끝나는 모든 행이 검색된다.,테이블의 EMP_NAME이 K로 시작하는 모든 행이 검색된다.,테이블의 EMP_NAME이 K 또는 k로 시작하는 모든 행이 검색된다.,,3 LIKE문의 'K%'는 K로 시작하는 모든 행을 검색하는 것이다.
849,,,,,"employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","SELECT e.eno, e.ename, count(*) FROM employee e, dependent d WHERE e.eno = d.eno GROUP BY e.eno, e.name HAVING count(*) >= 3;","SELECT e.eno, e.ename, t.cnt FROM employee e, (SELECT eno, count(*) as cnt FROM dependent GROUP BY eno HAVING count(*) >= 2) t WHERE e.eno = t.eno;","SELECT e.eno, e.ename, count(*) FROM employee e, dependent d WHERE EXISTS (SELECT * FROM dependent GROUP BY eno HAVING count(*) >=2) GROUP BY e.eno, e.ename;","SELECT eno, ename, count(*) FROM employee e, dependent d WHERE e.eno = d.eno and count(*) >= 2 GROUP BY d.eno;",,"2 위의 문제는 GROUP BY ~ HAVING절을 파악하는 것으로 GROUP BY에 조건을 걸기 위해서는 HAVING절을 사용해야 하며 ④번의 경우 count(*) 조건을 사용하기 위해서 HAVING절을 사용해야 한다. ③번은 서브쿼리 SELECT문에 집계함수가 존재하지 않는다. ①번은 HAVING count(*)의 ""3""이 2가 되면 올바르게 실행된다."
850,,,,,"가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.",가->나->다->마->바->라,가->나->라->다->마->바,가->나->다->라->마->바,나->가->다->라->마->바,,3 1)엔터티를 그린다. 2)엔터티를 적절하게 배치한다. 3)엔터티 간의 관계를 설정한다. 4)관계명을 기술한다. 5)관계의 참여도를 기술한다. 6)관계의 필수 여부를 기술한다.
851,,,,,"SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK
FROM EMP;",PARTITION문을 사용해서 해당 파티션 내에서 순위를 계산한다.,"RANK() 함수를 사용했으므로 급여가 동일한 사람이 있다면, 조회 순서에 따라서 1등과 2등으로 표시된다.",JOB별로 SAL이 큰 등수가 조회된다.,SAL칼럼은 급여가 큰 순으로 조회된다.,,2 RANK()함수를 사용할 경우 급여가 동일한 사람이 있을 때 같은 등수로 조회된다.
852,,,,,"SELECT LEVEL,
EMPNO,
MGR,
_____________ AS 리프노드여부
FROM SCOTT.EMP
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;",CONNECT_BY_ROOT,SYS_CONNECT_BY_PATH,CONNECT_BY_ISCYCLE,CONNECT_BY_ISLEAF,,4 각 행이 리프 노드 데이터인지 여부를 출력해주는 계층형 질의절의 가상 함수 CONNECT_BY_ISLEAF이다.
853,,,,,"[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*) FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호) AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014') B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);","FROM 절의 서브쿼리는 동적 뷰(Dynamic View)라고도 하며, SQL문장 중 테이블 명이 올 수 있는 곳에서 사용할 수 있다.",WHERE 절의 서브쿼리에 사원 테이블 검색 조건으로 입사년도 조건을 FROM절의 서브쿼리와 동일하게 추가해야 원하는 결과를 추출할 수 있다.,"SELECT절에 사용된 서브쿼리는 스칼라 서브쿼리라고도하며, 이러한 형태의 서브쿼리는 JOIN 으로 동일한 결과를 추출할 수도 있다.","위 SQL에는 다중 행 연관 서브쿼리, 단일 행 연관 서브쿼리, Inline View 가 사용되었다",,"2 2014년에 입사한 사원들의 사원, 부서 정보와 부양가족수를 추출하는 SQL이다. SELECT 절에 사용된 서브쿼리는 단일행 연관 서브쿼리로 JOIN 으로도 변경이 가능하며, FROM 절에 사용된 서브쿼리는 Inline View 또는 Dynamic View 이고, WHERE 절에 사용된 서브쿼리는 다중행 연관 서브쿼리 이다. ②번 보기의 경우 이미 FROM절에 Inline View로 사원 테이블의 입사년도 조건을 명시하였으므로 WHERE 절의 EXISTS 조건은 부서와 사원 테이블간의 JOIN 조건에 의해 결과에 어떠한 영향도 미치 지 못하므로 삭제되어도 무방하다."
