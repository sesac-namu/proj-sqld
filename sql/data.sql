USE sqld;

insert into quiz (id, category, tags, title, content_img, content_text, choices_1, choices_2, choices_3, choices_4, multiple, answer_explanation) values
(1, 1, '데이터 무결성', '테이블 생성 시 주의 사항으로 옳지 않은 것은?', '', '', '컬럼에 대한 제약조건을 추가하는 경우 CONSTRAINT를 사용한다.', '날짜 유형은 별도로 크기를 지정하지 않아도 된다.', '문자 데이터 유형은 별도로 크기를 지정하지 않아도 된다.', '테이블 생성시 대소문자 구분은 하지 않아도 된다.', FALSE, '해설: 문자 유형은 반드시 최대 크기를 지정해야 한다.'),
(2, 1, 'ER 모델링', '속성에 대한 설명으로 가장 적절하지 않은 것은?', '', '', '엔터티에 속한 속성은 엔터티에 대한 추상적인 값을 갖는다.', '업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소의 데이터 단위를 말한다.', '정해진 주식별자에 함수적 종속성을 가져야 한다.', '하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다.', FALSE, '해설: 속성은 엔터티에 속한 엔터티에 대한 자세하고 구체적인 정보를 나타낸다.'),
(3, 1, 'ER 모델링', '다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?', '', '가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다. 나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다. 다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다. 라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.', '가,다', '나,라', '가,라', '가,나', FALSE, '해설: 데이터베이스 식별자는 대표성 여부에 따라서 주식별자와 보조 식별자로 구분된다. 주식별자는 후보키 중에서 엔터티를 대표하는 식별자로 다른 엔터티와 참조하여 연결할 수 있는 식별자이다.'),
(4, 1, 'ER 모델링', '아래의 IE 표기법에서 고객 엔터티의 고객번호와 계좌마스터의 고객번호는 어떤 식별자에 해당되는가?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j361-1.png', '', '단일 식별자, 복합 식별자', '단일 식별자, 인조 식별자', '내부 식별자, 외부 식별자', '본질 식별자, 복합 식별자', FALSE, '해설: 내부 식별자란, 엔터티 내부에서 스스로 생성되는 식별자이고 외부 식별자는 다른 엔터티의 관계로 인하여 만들어지는 식별자이다.'),
(5, 1, 'ER 모델링', '다음 중 ERD에 대한 설명으로 가장 올바르지 않은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j406-1.png', '', '고객은 개인고객이면서 동시에 기업고객이 되는 포괄적 관계이다.', '고객 구분은 개인고객과 기업고객을 구분하는 차별자이다.', '고객, 개인고객, 기업고객 3개 엔터티를 3개의 테이블로 생성하여 사용하면 다수의 조인이 발생하여 조회속도가 떨어진다.', '고객, 개인고객, 기업고객 간의 관계는 Super Type과 Sub Type 관계이다.', FALSE, '해설: Super Type과 Sub Type은 베타적 관계와 포괄적 관계가 있는데 본 예제의 관계는 베타적 관계 모델링이다. 베타적 관계는 한순간에 하나만 될 수 있기 때문에 한순간에 개인고객이 되거나 아니면 기업고객이 된다.'),
(6, 1, '데이터 무결성', '컬럼 변경 시 주의 사항으로 옳지 않은 것은?', '', '', '컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미친다.', '컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.', '컬럼이 NULL 값만 가지고 있으면 데이터 유형을 변경할 수 있다.', '컬럼의 크기를 늘릴 수는 있지만 줄일 수는 없다.', FALSE, '해설: 컬럼 크기를 늘리는 것은 언제든지 가능하며 반대로 줄이는 것은 해당 컬럼의 최대 길이만큼 줄일 수 있다.'),
(7, 1, '데이터 모델링 기법', '다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?', '', '', '데이터 모델링을 할 때 분석 단계에서부터 반정규화를 수행한다.', '데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.', '데이터베이스 용량 산정을 수행한다.', '이력모델의 조정, 기본키/외래키 조정, 슈퍼타입/서브타입 조정 등을 수행한다.', FALSE, '해설: 성능을 고려한 데이터 모델링을 할 때 첫 번째 단계는 정규화를 적용한 데이터 모델을 만드는 것이다.'),
(8, 1, 'ER 모델링', '자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?', '', '', '관계 속성', '파생 속성', '기본 속성', '설계 속성', FALSE, '해설: 파생 속성은 다른 속성을 이용하여 계산된 속성으로 자신의 고유값을 갖지 않고 파생, 유추되어 재산정될 수 있는 속성이다.'),
(9, 1, '데이터 무결성', '관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?', '', '', '데이터베이스의 부하를 분석하기 쉽다.', '기존의 작성된 스키마를 수정하기 어렵다.', '데이터를 분류, 정렬, 탐색하는 속도가 빠르다.', '데이터의 무결성을 보장할 수 있다.', FALSE, '해설: 데이터베이스의 크기나 복잡한 관계 및 다양한 쿼리 패턴 등의 이유로 부하를 분석하기가 어렵다.'),
(10, 1, '데이터 무결성', '다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.', '', '', '외래키 값은 참조 무결성 제약을 받을 수 있다.', '한 테이블에 하나만 존재해야 한다.', '외래키 값은 널 값을 가질 수 없다.', '테이블 생성시 설정할 수 있다.', TRUE, '해설: None'),
(11, 2, '집합 연산자', '다음에서 주어진 Mytest 테이블에서 SQL문을 실행했을 때 결괏값과 같은 SQL문은?(단 union은 정렬도 진행하는 것으로 한다)', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j293-1.png', '', 'select * from (select job_id, max(salary) from Mytest group by salary union all select job_id, min(salary) from Mytest group by salary );', 'select * from (select job_id, max(salary) from Mytest group by job_id union all select job_id, min(salary) from Mytest group by job_id );', 'select * from (select job_id, max(salary) from Mytest group by salary union select job_id, min(salary) from Mytest group by salary );', 'select * from (select job_id, max(salary) from Mytest group by job_id union select job_id, min(salary) from Mytest group by job_id );', FALSE, '해설: 결괏값은 주어진 테이블에서 JOB_ID 별로 그룹화하였을 때 각 JOB_ID별 salary의 최댓값과 최솟값이 반환되는 결괏값이다. 그런데 JOB_ID 별 salary 값이 하나의 속성값으로 통일되었으므로 union 연산자를 이용한다.'),
(12, 2, '윈도우 함수', '다음의 PREV_SAL은 어떤 윈도우 함수를 사용해야 하는가?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j247-1.png', '', 'LAST_VALUE', 'NTILE', 'LAG', 'LEAD', FALSE, '해설: LAG() 윈도우 함수는 이전 행의 몇 번째 행 값을 가지고 올 수 있다.'),
(13, 2, '서브쿼리', '다음 중 아래의 ERD를 참조하여 아래 SQL과 동일한 결과를 출력하는 SQL로 가장 부적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j116-1.png', '', 'SELECT A.회원번호, A.회원명 FROM 회원 A, 동의항목 B WHERE A.회원번호 = B.회원번호 AND B.동의여부 = \'N\' GROUP BY A.회원번호, A.회원명 ORDER BY A.회원번호;', 'SELECT A.회원번호, A.회원명 FROM 회원 A WHERE 0 < (SELECT COUNT(*) FROM 동의항목 B WHERE B.동의여부 = \'N\') ORDER BY A. 회원번호;', 'SELECT A.회원번호, A.회원명 FROM 회원 A WHERE A. 회원번호 IN (SELECT B.회원번호 FROM 동의항목 B WHERE B. 동의여부 = \'N\') ORDER BY A. 회원번호;', 'SELECT A.회원번호, A.회원명 FROM 회원 A WHERE EXISTS (SELECT 1 FROM 동의항목 B WHERE A.회원번호 = B.회원번호 AND B. 동의여부 = \'N\') ORDER BY A. 회원번호;', FALSE, '해설: 위의 SQL은 약관항목 중 단 하나라도 동의를 하지 않은 회원을 구하는 SQL이다. HAVING 절에서 동의여부가 N인 데이터가 한 건이라도 존재하는 데이터를 추출한다. ①는 HAVING절로 처리되던 조건을 WHERE절에 위치시켜 더 간편하게 Join으로 처리하였다. 또한 회원과 동의항목은 1:N 관계이므로 JOIN된 결과는 N건으로 발생됨에 따라 GROUP BY를 추가하여 중복을 제거 하였다. ②의 회원 테이블과 동의항목 테이블간에 회원번호 컬럼으로 연관 서브쿼리로 처리되어야 정상적으로 처리할 수 있다. ③는 동의항목 테이블에서 동의여부가 N인 한 건이라도 존재하는 회원을 추출하여 회원테이블과 IN 연산을 수행한다. ④은 회원 테이블과 동의항목 테이블의 회원번호 컬럼으로 연관 서브쿼리를 수행하여 동의여부 컬럼의 값이 N인 데이터가 한 건이라도 존재하면 회원 데이터를 출력하게 된다.'),
(14, 2, '윈도우 함수', 'PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?', '', '', 'PIVOT 시 FOR 앞에는 반드시 집계함수(SUM, AVG 등)의 형태여야 한다.', 'UNPIVOT시 쌓을 컬럼을 지정할 수 없다.', 'UNPIVOT은 LONG 데이터를 WIDE 데이터로 변환하는 기법이다.', 'PIVOT은 교차표 형태의 데이터를 TIDY 데이터로 변경하는 문법이다.', FALSE, '해설: PIVOT 시에는 IN절에 나열한 값들을 갖는 행들이 결합되어 출력되므로 반드시 FOR 앞에는 집계함수 형태로 전달 되어야 한다.'),
(15, 2, 'DML', '아래 SQL 수행 결과로 가장 적절한 것은? (단, DBMS는 오라클)', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j695-1.png', 'SELECT ENAME, DEPTNO, SAL FROM EMP ORDER BY DEPTNO, SAL DESC;', '', '', '', '', FALSE, '해설: DEPTNO가 작은순서대로, DEPTNO가 같은 경우 SAL이 큰 순서대로 정렬하여 출력한다. NULL이 마지막에 출력되는게 기본 순서이지만DESC로 내림차순 정렬하면 NULL이 젤 먼저 출력된다.'),
(16, 2, '윈도우 함수', '다음 중 파티션에 대한 설명으로 올바르지 않은 것은?', '', '', 'AVG(SAL) OVER (PARTITION BY MGR ORDER BY TODAY ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) : 각 MGR 별로 앞의 한 건, 현재 행, 뒤의 한 건 사이에서 SAL의 평균을 계산한다.', 'COUNT(*) OVER (ORDER BY SAL) RANGE BETWEEN 10 PRECEDING AND 150 FOLLOWING) : SAL을 기준으로 현재 행에서의 SAL의 -10에서 +150사이의 급여를 가지는 행의 수를 계산한다.', 'SUM(SAL) OVER (PARTITION BY MGR ORDER BY SAL RANGE UNBOUNDED PRECEDING) :각 MGR별 현재 행부터 파티션 내 첫 번째 행까지의 SAL의 합계를 계산한다.', 'RANK() OVER (PARTITION BY JOB ORDER BY SAL ASC) JOB_RANK :각 JOB 별 SAL이 낮은 순서대로 순위가 부여된다.', FALSE, '해설: ①번 보기는 각 MGR별로 SAL의 평균을 계산하기 전에 TODAY를 기준으로 정렬을 수행한 다음에 SAL의 평균을 계산한다. 즉, 각 MGR별 TODAY 기준으로 정렬하였을 때 파티션 내에서 앞의 한 건, 현재 행, 뒤의 한 건 사이의 급여의 평균을 계산한다.'),
(17, 2, 'NULL', '다음 설명 중 올바르지 않은 것은?', '', '', 'Oracle에서 인덱스 구성 칼럼이 모두 null인 레코드는 인덱스에 저장하지 않는다.', 'SQL Server는 인덱스 구성 칼럼이 모두 null인 레코드도 인덱스에 저장한다.', 'Oracle에서 인덱스 구성 칼럼 중 하나라도 null이 아닌 레코드는 인덱스에 저장한다.', 'SQL Server는 null 값을 인덱스 맨 뒤에 저장한다.', FALSE, '해설: SQL Server는 null값을 인덱스 맨 옆에 저장하고, Oracle은 맨 뒤에 저장한다.'),
(18, 2, '집계 함수', '아래 수행 결과로 알맞은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j641-1.png', 'SELECT COUNT(COL1) AS RESULT FROM TAB1 WHERE COL2 >= 30 GROUP BY COL1;', '', '', '', '', FALSE, '해설: WHERE절의 비교 연산 결과 COL2의 30과 40만 해당되고 그에 해당하는 COL1은 모두 NULL이다. GROUP BY에 의해 COL1이 NULL인 한 그룹이 생성되지만 NULL은 COUNT하지 않기 때문에 0이 출력된다.'),
(19, 2, 'JOIN', '다음은 Oracle 데이터베이스에서 사용하는 Outer Join의 예제이다. 빈칸을 채워 Oracle의 Outer Join을 표준 ANSI SQL로 변경하시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j304-1.png', '', 'CROSS JOIN', 'RIGHT OUTER JOIN', 'LEFT OUTER JOIN', 'FULL OUTER JOIN', FALSE, '해설: Oracle OUTER JOIN에서 (+)가 왼쪽 테이블 옆에 위치해 있으므로 우측 테이블에서는 조인을 수행하지 않는 테이블의 행들은 그대로 유지되며, 좌측 테이블에서는 조인을 수행하지 않는 테이블의 행들은 null값으로 추가되는 Rights OUTER JOIN이 수행된다.'),
(20, 2, 'JOIN', '다음은 Oracle 데이터베이스에서 사용하는 Outer Join의 예제이다. 빈칸을 채워 Oracle의 Outer Join을 표준 ANSI SQL로 변경하시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j305-1.png', '', 'CROSS JOIN', 'RIGHT OUTER JOIN', 'LEFT OUTER JOIN', 'FULL OUTER JOIN', FALSE, '해설: None'),
(21, 2, 'JOIN', '다음 중 아래 테이블들을대상으로 SQL 문장을 수행한 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j95-1.png', '', '', '', '', '', FALSE, '해설: None'),
(22, 2, '단일행 함수', '아래 함수 결과로 가장 적절하지 않은 것은?', '', '', 'RTRIM(\'ABCAA\', \'A\') : BC', 'TO_CHAR(1000,\'9,999\') : 1,000', 'SUBSTR(\'Sql Developer\', -5, 2) : lo', 'UPPER(\'Sql Developer\') : SQL DEVELOPER', FALSE, '해설: RTRIM(\'ABCAA\', \'A\') 는 오른쪽에서부터 A를 연속적으로 지우고 지울 대상이 아닌 문자를 만나면 더 이상 글자를 지우지 않는다.'),
(23, 2, '계층형 질의', '다음 수행 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j710-1.png', 'SELECT DEPTNO, DNAME, LEVEL, CONNECT_BY_ROOT(DNAME) AS ROOT FROM DEPARTMENT START WITH PART IS NULL CONNECT BY PRIOR PART = DEPTNO;', '', '', '', '', FALSE, '해설: PRIOR의 위치가 PART에 있으므로 가장 최상위 학과(PART IS NULL)를 먼저 출력하고, 두 행의 PART를 DEPTNO 로 갖는 행을 찾지만 해당 행이 없으므로 최상위 학과인 공과대학과 인문대학만 출력된다.'),
(24, 2, 'JOIN', '아래의 테이블 스키마 정보를 참고하여, 다음 중 \'구매 이력이 있는 고객 중 구매 홧수가 3회 이상인 고객의 이름과 등급을 출력하시오\'라는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 구문으로 가장 적절한 것은?', '', '[테이블] 고객(고객번호(PK), 이름, 등급) 구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK)) * 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다. [SQL 문장] SELECT A.이름 , A.등급 FROM 고객 A (ㄱ) GROUP BY A.이름 ,A.등급 (ㄴ)', '(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : WHERE B.구매번호〉=3', '(ㄱ) : LEFT OUTER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B.구매번호) >=3', '(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING COUNT(B. 구매번호) >=3', '(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호 (ㄴ) : HAVING SUM(B. 구매번호)〉=3', FALSE, '해설: None'),
(25, 2, 'DDL', '유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?', '', '', '권한 부여를 편리하게 관리하기 위해 만들어진 권한의 집합인 ROLE 이 있다', '테이블의 소유자는 해당 테이블의 DML 권한을 다른 유저에게 부여 할 수 있다.', 'DBA 권한을 가진 유저만이 권한을 부여 할 수 있다', '사용자가 실행하는 모든 DDL 문장은 그에 해당하는 적절한 권한이 있어야만 문장을 실행 할 수 있다.', FALSE, '해설: 테이블 소유자의 경우 소유한 테이블에 대한 조회, 수정 권한을 다른 유저에게 부여할 수 있다. 또한 WITH ADMIN OPTION 등을 통해 권한을 위임 받은 유저도 해당 권한에 대해 권한 부여가 가능하다.'),
(26, 2, '단일행 함수', '다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) : ASCII 값 → 줄바꿈을 의미)', '', '', '6', '5', '3', '2', FALSE, '해설: None'),
(27, 2, '윈도우 함수', '다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?', '', 'SELECT 분류코드 AVG(상품가격) AS 상품가격, COUNT(*) OVER(ORDER BY AVG(상품가격) RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT FROM 상품 GROUP BY 분류코드;', 'CNT 칼럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000사이에 존재하는 상품의 개수를 구한 것이다.', 'CNT 칼럼은 분류코드별 평균상품가격을 서로 비교하여 -10000 ~ 10000 사이에 존재하는 분류코드의 개수를 구한 것이다.', 'WINDOW FUNCTION의 ORDER BY 절로 인하여 문법오류이다.', 'WINDOW FUNCTION을 GROUP BY(분류코드)절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다.', FALSE, '해설: CNT 칼럼은 분류코드를 GROUPING된 집합을 원본집합으로 하여 분류코드별 평균상품가격을 서로 비교하고 현재 읽혀진 상품분류코드의 평균가격 대비 -10000 ~ +10000 사이에 존재하는 분류코드의 개수를 구한 것이다.'),
(28, 2, '서브쿼리', '다음 과일 테이블에 대한 SQL문 내의 비교조건을 해석한 것으로 올바르지 않은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j248-1.png', '', '"19=ALL(SELECT 과일코드 FROM 과일)" 거짓이다.', '"15<ALL(SELECT 과일코드 FROM 과일)"은 참이다.', '"19<ANY(SELECT 과일코드 FROM 과일)"은 거짓이다.', '"21 NOT IN (SELECT 과일코드 FROM 과일)"은 참이다.', FALSE, '해설: ALL은 전부 일치하는 것만 출력하는 것으로 AND라고 생각하면 되고 ANY는 OR로 생각하면 된다. 그러므로 보기②번은 15보다 큰 것이 모두 일치해야 하는데 과일 테이블에 있는 15, 키위는 값이 크지 않고 같다.'),
(29, 2, '윈도우 함수', '다음 SQL 실행 결과로 가장 알맞은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j609-1.png', 'SELECT DNAME, FIRST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE1, LAST_VALUE(NAME) OVER(PARTITION BY DNAME ORDER BY SAL) AS VALUE2 FROM TAB1;', '', '', '', '', FALSE, '해설: FIRST_VALUE, LAST_VALUE는 ORDER BY 컬럼 순서대로 범위 내 가장 처음 값과 마지막 값을 리턴하는 함수인데, 이때 기본 범위는 RANGE UNBOUNDED PRECEDING AND CURRENT ROW이다. 따라서 같은 DNAME 내 SAL 순서대로 가장 앞에 있는 이름은 아시아지부의 경우 홍길동, 남유럽지부의 경우 김길동이 된다. 하지만 각 행마다 LAST_VALUE를 구할 때 범위가 처음부터 현재 행까지만 고려해서 마지막 값을 리턴하기 때문에 항상 현재 행의 값이 마지막 값이 되므로 각 행의 값이 리턴된다.'),
(30, 2, '집합 연산자', '다음 주어진 테이블에서 해당 SQL문을 실행한 결과로 알맞은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j496-1.png', 'SELECT * FROM SQLD5 WHERE COL1 IN (1,2,NULL);', '', '', '', '', FALSE, '해설: NULL은 비교에서 애초에 제외되어 IN 연산자 안에 NULL이 있어도 비교 연산을 수행하지 않는다. 주어진 테이블의 COL1 속성값 1,2값을 갖는 튜플만 조회된다.'),
(31, 2, '윈도우 함수', '주어진 테이블에 대해서 아래와 같은 결괏값이 나오도록 SQL 빈칸을 완성하시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j397-1.png', 'SELECT EMPLOYEE_ID, DEPARTMENT_ID, LAST_NAME, SALARY, LAG(SALARY,( )) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY) AS BEFORE_SALARAY FROM EMPLOYEES WHERE EMPLOYEE_ID < 110;', '4', '3', '2', '1', FALSE, '해설: LAG 함수는 이전 행의 값을 반환하는 함수이다. LAG(SALARY, 2)라고 하면 이전 두 번째 행 값을 반환하게 된다.'),
(32, 2, '단일행 함수', '다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?', '', 'SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),\'월요일\') FROM EMP;', '각 직원의 입사날짜로부터 6개월 후 두 번째 월요일에 해당하는 날짜', '각 직원의 입사날짜로부터 6개월 후 첫 번째 월요일에 해당하는 날짜', '각 직원의 입사날짜로부터 6일 후 두 번째 월요일에 해당하는 날짜', '각 직원의 입사날짜로부터 6일 후 첫 번째 월요일에 해당하는 날짜', FALSE, '해설: ADD_MONTHS는 지정한 날짜에서 n개월 이후 날짜를 출력하는 함수이다. NEXT_DAY(날짜,요일) 는 지정한 날짜 뒤 의 첫 번째 지정요일에 해당하는 날짜를 리턴한다.'),
(33, 2, '데이터 무결성', '다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?', '', '데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.', '외래키', '후보키', '수퍼키', '인조키', FALSE, '해설: 후보키는 유일성과 최소성을 만족하는 키이다.'),
(34, 2, '윈도우 함수', '다음 SQL문의 실행 결과로 가장 알맞은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j659-1.png', 'SELECT * FROM 고객 ORDER BY 포인트 DESC OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY;', '', '', '', '', FALSE, '해설: 고객 테이블에서 포인트가 높은 순서대로 정렬을 한 후 2개의 행을 건너 뛰고 3번째부터 2개의 행을 뽑는다.'),
(35, 2, '계층형 질의', '아래 SQL 실행 결과로 가장 알맞은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j612-1.png', 'SELECT E.*, LEVEL FROM 사원 E START WITH 매니저사원번호 IS NULL CONNECT BY PRIOR 사원번호 = 매니저사원번호 AND EXTRACT(MONTH FROM 입사일자) >= 7 ORDER SIBLINGS BY 이름;', '', '', '', '', FALSE, '해설: 매니저 사원번호가 NULL인 지점을 시작으로 레벨 1을 부여, 나사장의 사원번호를 매니저 사원번호로 가지면서 하반기 입사자인 행을 찾아 레벨 2를 부여한다. 이렇게 연결된 행으로부터 CONNECT 절의 조건을 만족하는 행을 계속 이어 나간다. 이때, START WITH 절은 CONNECT BY에 있는 조건에 따라 생략되지 않기 때문에 나사장이 상반기 입사자라도 출력된다.'),
(36, 2, 'JOIN', '다음 SQL의 실행 결과로 맞는 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j89-1.png', '', '6', '4', '2', '0', FALSE, '해설: None'),
(37, 2, '집합 연산자', 'SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?', '', '', 'EXCEPT', 'MINUS', 'INTERSECT', 'UNION', FALSE, '해설: SET OPERATOR :합집합은 UNION, 교집합은 INTERSECT, 차집합은 MINUS/EXCEPT 이다.'),
(38, 2, '집합 연산자', '(SQL Server) 다음 중 아래의 SQL과 동일한결과를 추출하는 SQL은?(단, 테이블 TAB1, TAB2의 PK 컬럼은 A, B 이다.)', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j100-1.png', '', 'SELECT TAB1.A, TAB1.B FROM TAB1 WHERE NOT EXISTS (SELECT \'X\' FROM TAB2 WHERE TAB1.A = TAB2.A AND TAB1.B = TAB2.B);', 'SELECT TAB2.A, TAB2.B FROM TAB1, TAB2 WHERE TAB1.A = TAB2.A AND TAB1.B = TAB2.B', 'SELECT TAB1.A, TAB1.B FROM TAB1 WHERE TAB1.A NOT IN (SELECT TAB2.A FROM TAB2) AND TAB1.B NOT IN (SELECT TAB2.B FROM TAB2);', 'SELECT TAB2.A, TAB2.B FROM TAB1, TAB2 WHERE TAB1.A〈〉TAB2.A AND TAB1.B〈〉TAB2.B', FALSE, '해설: None'),
(39, 2, 'DML', '주어진 테이블에서 아래의 SQL문과 다른 값을 반환하는 SQL문을 고르시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j283-1.png', 'SELECT * FROM Mytest WHERE (COL1, COL2) IN ((\'x\',\'y\'),(\'kk\',\'BB\'))', 'SELECT * FROM Mytest WHERE (COL = \'x\' or COL1 = \'KK\') and (COL2 = \'y\' or COL2 =\'BB\');', 'SELECT * FROM Mytest WHERE (COL1 = \'x\' and COL2 = \'KK\') or (COL1 = \'y\' and COL2 =\'BB\');', 'SELECT * FROM Mytest WHERE (COL1 = \'x\' and COL2 = \'y\') or (COL1 = \'KK\' and COL2 =\'BB\');', 'SELECT * FROM Mytest WHERE NOT (COL1, COL2) in ((\'A\', \'B\'), (\'x\', \'KK\'), (\'a\',\'b\'),(\'1\',\'2\'), (\'y\',\'BB\'));', FALSE, '해설: 위의 SQL문은 COL1과 COL2값으로 각각 (x,y),(KK,BB)를 갖는 행들이 반환되지만 ②번 보기는 COL1 과 COL2 값으로 각각 (x,KK),(y,BB)값을 갖는 행들이 반환된다.'),
(40, 2, 'View', '다음 중 VIEW에 대한 설명으로 올바르지 않은 것은?', '', '', '보안성 : 직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면 뷰를 생성할 때 해당 칼럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다.', '물리성 : 실제 데이터를 가지고 있어서 물리적인 관리가 가능하다.', '편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. 또한 해당 형태의 SQL문을 자주 사용할 때 뷰를 이용하면 편리하게 사용할 수 있다.', '독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다.', FALSE, '해설: VIEW는 논리적으로 존재하는 가상 테이블로서 물리적으로 실제 데이터를 저장하지 않는다.'),
(41, 2, 'DML', '다음의 테이블이 있을 경우 SQL을 수행하였을 때 출력결과를 순서대로 나열한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j429-1.png', 'SELECT CASE WHEN C1=1 THEN 10 WHEN C1=2 THEN 20 ELSE C1 END FROM Mytest;', '1,2,30', '10,20,30', '10,20,3', '1,2,3', FALSE, '해설: CASE 문의 조건문에 따라서 1은 10으로 2는 20으로 입력된다.'),
(42, 2, '서브쿼리', '다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?', '', '', 'EXISTS는 TRUE와 FALSE만 되돌린다.', '여러 개의 행을 되돌리는 서브쿼리는 다중 행 연산자를 사용해야 한다.', '메인쿼리를 작성할 때 서브쿼리에 있는 칼럼을 자유롭게 사용할 수 있으면 편리하다.', '서브쿼리에서는 정렬을 수행하기 위해서 내부에 ORDER BY를 사용하지 못한다.', FALSE, '해설: 서브쿼리 내부에서는 메인쿼리의 칼럼을 사용할 수 있지만 반대로 메인쿼리에서 서브쿼리의 칼럼을 사용할 수 없다.'),
(43, 2, '집계 함수', '다음 문제에 주어진 결괏값을 반환하는 SQL문은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j289-1.png', '', 'SELECT COUNT(CASE WHEN CLASS =\'A\' THEN 1 END) AS "Result" COUNT(CASE WHEN CLASS =\'B\' THEN 1 END) AS B, COUNT(CASE WHEN CLASS =\'C\' THEN 1 END) AS C FROM Mytest;', 'SELECT CLASS, count(1) AS "Result" FROM Mytest GROUP BY CLASS;', 'SELECT CLASS, count(distinct NAME) AS "Result" FROM mytest GROUP BY CLASS;', 'SELECT CLASS, count(*) AS "Result" FROM Mytest GROUP BY CLASS;', FALSE, '해설: ③번 보기에서 주어진 테이블을 \'CLASS\' 속성별로 그룹화한 다음 각 \'CLASS\' 속성별 행의 수를 count하는데 DISTINCT 인자로 중복되는 NAME 값은 제외하고 count를 수행하여 결괏값이 반환된다.'),
(44, 2, '계층형 질의', '주어진 테이블에 대해서 아래의 SQL문을 수행한 결과로 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j491-1.png', 'select count(*) from TEST11 where COL3 <> 3 start with COL3 = 4 connect by COL1 = prior COL2;', '3', '2', '1', '0', FALSE, '해설: None'),
(45, 2, 'SP', '다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?', '', '', 'Procedure 내부에 작성된 절차적 코드는 PL/SQL엔진이 처 리하고 일반적인 SQL 문장은 SQL실행기가 처리한다.', 'PL/SQL로 작성된 Procedure, User Defined Fimction은 전체가 하나의 트랜젝션으로 처리되어야 한다', 'Procedure, User Defined Function, Trigger 객체를 PL/SQL로 작성할 수 있다.', '변수와 상수 등을 사용하여 일반 SQL 문장을 실행할 때 WHERE절의 조건 등으로 대입할 수 있다.', FALSE, '해설: PL/SQL로 작성된 Procedure, User Defined Function은 작성자의 기준으로 트랜젝션을 분할할 수 있으며, 또한 프로시저 내에서 다른 프로시저를 호출할 경우에 호출 프로시저의 트랜젝션과는 별도로 PRAGMA AUTONOMOUS_TRANSACTION을 선언하여 자율 트랜젝션 처리를 할 수 있다.'),
(46, 2, 'JOIN', '다음 SQL문에서 ( )에 들어갈 알맞은 명령어는 무엇인가?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j244-1.png', '', 'CROSS JOIN', 'RIGHT OUTER JOIN', 'LEFT OUTER JOIN', 'FULL OUTER JOIN', FALSE, '해설: DEPT 테이블에 있는 40번이 조회되고 EMP테이블은 NULL로 조회되므로 RIGHT OUTER JOIN이다.'),
(47, 2, '계층형 질의', 'Mytest 테이블에 대해서 SQL문을 실행햇을 때 결과로 올바른 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j352-1.png', 'SELECT * FROM Mytest START WITH MGRID IS NULL CONNECT BY PRIOR EMPID = MGRID AND today BETWEEN \'2017-01-01\' AND \'2022-12-31\' ORDER SIBLINGS BY EMPID;', '', '', '', '', FALSE, '해설: MGRID가 NULL인 값에서 시작해서 EMPID로 조회를 전개하는 순방향 조회를 하고 있다. 순방향 전개를 하면서 EMPID로 정렬한다.'),
(48, 2, '윈도우 함수', '다음 SQL 구문 결과와 같은 결과를 갖는 SQL은?', '', 'SELECT COUNT(DECODE(DEPTNO,10,1)) AS "10", COUNT(DECODE(DEPTNO,20,1)) AS "20", COUNT(DECODE(DEPTNO,30,1)) AS "30" FROM EMP;', ' SELECT * FROM EMP UNPIVOT (COUNT(*) FOR DEPTNO IN (10,20,30));', 'SELECT * FROM EMP UNPIVOT (COUNT(DEPTNO) FOR DEPTNO IN (10,20,30));', 'SELECT * FROM (SELECT EMPNO, JOB, DEPTNO FROM EMP) PIVOT (COUNT(DEPTNO) FOR EMPNO IN (10,20,30));', 'SELECT * FROM (SELECT EMPNO, DEPTNO FROM EMP) PIVOT (COUNT(EMPNO) FOR DEPTNO IN (10,20,30));', FALSE, '해설: 10, 20, 30번 부서원의 수를 각 컬럼별로 표현한 것은 LONG -> WIDE로의 변환을 수행하는 PIVOT의 결과로 대체할 수 있다. PIVOT 절에서 IN 앞의 컬럼은 서로 다른 컬럼으로 분해할 대상이 명시되어야 하므로 DEPTNO가 들어가야 한다.'),
(49, 2, 'JOIN', '아래 결괏값은 주어진 2개 테이블을 특정 JOIN하여 나타난 결과이다. 어떤 조인인지 고르시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j477-1.png', 'SELECT * FROM SQLD27 ( ) SQLD27_2 ON SQLD27.COL1 = SQLD27_2.COL1;', 'INNER JOIN', 'FULL OUTER JOIN', 'RIGHT OUTER JOIN', 'LEFT OUTER JOIN', FALSE, '해설: 주어진 두 개의 테이블에서는 같은 COL1 값을 갖는 튜플을 조회하고 우측 테이블에만 있는 값들이 추가로 조회되므로 RIGHT OUTER JOIN이다.'),
(50, 2, '트랜잭션 관리', '다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?', '', '', 'Oracle에서 INSERT를 실행하면 자동적으로 COMMIT까지 완료된다.', '암시적(묵시적) 트랜잭션 처리는 트랜잭션이 자동으로 시작되며 자동으로 완료 혹은 취소되는 것이다.', '명시적 트랜잭션의 시작과 끝은 모두 SQL을 실행하는 사용자가 지정한다.', 'SQL의 DML과 DDL을 실행할 때 COMMIT을 자동으로 처리하는 것이 AUTO COMMIT이다.', FALSE, '해설: 오라클에서 기본적으로 AUTO COMMIT은 설정되지 않는다. SQL Server는 기본 설정이 ATUO COMMIT이다.'),
(51, 1, 'ER 모델링', '다음은 ABC 증권회사의 데이터베이스 모델링이다. 모델링은 고객과 계좌 간의 관계를 표현한 것이다. 보기 중에서 그 설명이 올바르지 않은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j446-1.png', '', '한 명의 고객에게 하나의 고객등급만 부여된다.', '고객마스터와 계좌마스터의 관계는 식별 관계이다.', '계좌번호는 전체 고객마다 유일한 번호가 부여된다.', '계좌를 개설하지 않은 고객은 ABC증권회사의 고객이 될 수가 없다.', FALSE, '해설: 계좌마스터의 기본키가 계좌번호와 고객번호이므로 전체 고객에게 유일한 번호가 할당되는 것은 아니다. 즉, 고객별 유일한 계좌번호가 된다.'),
(52, 1, 'ER 모델링', '식별자의 대체 여부에 따라 분류하는 방식은?', '', '', '단일 식별자 - 복합 식별자', '주식별자 - 보조 식별자', '내부 식별자 - 외부 식별자', '본질 식별자 - 인조 식별자', FALSE, '해설: 식별자를 대체할 수 있는 성격에 따라 구분한 개념은 본질 식별자 - 인조 식별자이다.'),
(53, 1, 'ER 모델링', '엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.', '', '', '엔터티 하나의 인스턴스는 다른 엔터티의 인스턴스 간 관계인 Pariring을 가진다.', '한 개의 엔터티는 두 개 이상의 속성을 갖는다.', '하나의 속성은 하나 이상의 속성값을 가진다.', '한 개의 엔터티는 두 개 이상의 인스턴스 집합이어야 한다.', FALSE, '해설: 하나의 속성은 하나의 속성값을 가지며 하나 이상의 속성값을 가지는 경우 정규화가 필요하다.'),
(54, 1, 'ER 모델링', '다음 중 데이터모델링을 할 때 속성의 명칭을 부여하는 방법으로 가장 부적절한 것은?', '', '', '데이터모델링 대상에서 사용하는 용어도 있고 외부에서 사용하는 용어도 있어 중복이 있을 때, 가급적 해당 업무에서 자주 사용하는 이름을 이용하도록 한다.', '직원 엔터티의 이름, 고객 엔터티의 이름과 같이 각 엔터티별로 동일한 속성명을 사용하여 데이터모델의 일관성을 가져가는 것이 좋다.', '속성의 이름에는 서술식 용어는 사용하지 않도록 한다.', '속성의 이름에 약어를 사용할 경우 그 의미를 명확하게 이해할 수 없고 혼돈을 초래하여 커뮤니케이션의 혼란을 야기할수 있으므로 지나친 약어 사용은 가급적 제한하도록 한다.', FALSE, '해설: None'),
(55, 1, '데이터 무결성', '다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.', '', '', '외래키 값은 참조 무결성 제약을 받을 수 있다.', '한 테이블에 하나만 존재해야 한다.', '외래키 값은 널 값을 가질 수 없다.', '테이블 생성시 설정할 수 있다.', TRUE, '해설: None'),
(56, 1, 'NULL', '다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?', '', '', 'MIN', 'AVG', 'SUM', 'COUNT', FALSE, '해설: COUNT는 0이 리턴된다.'),
(57, 1, 'ER 모델링', '다음의 ERD에 대한 설명으로 가장 올바르지 않은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j404-1.png', '', '학생 엔터티의 기본키는 학번이고 이름,나이,주소는 속성이다.', '학생과 과목 엔터티를 조인 시에 카텐시안 곱이 발생하여 2명의 학생이 2개의 과목과 조인하면 2개의 행이 조회된다.', '학생과 과목 간의 관계에서 수강 신청이라는 엔터티를 추가해서 M:N을 1:N, N:1로 해소해야 한다.', '한 명의 학생은 여러 개의 과목과 매핑된다.', FALSE, '해설: M:N 관계는 카텐시안 곱이 발생하고 2개 행과 2개의 행을 조인하면 2*2 = 4개의 행이 조회된다.'),
(58, 1, 'ER 모델링', '다음 중 ERD에 대한 설명으로 가장 부적절한 것은?', '', '', '가장 중요한 엔터티를 오른쪽 상단에 배치하고 추가 발생되는 엔터티들을 왼쪽 편과 하단에 배치하는 것이 원칙이다.', '관계의 명칭은 관계 표현에 있어서 매우 중요한 부분에 해당한다.', '일반적으로 ERD를 작성하는 방법은 엔터티 도출 -> 엔터티 배치 -> 관계 설정 -> 관계명 기술의 흐름으로 작업을 진행한다.', '1976년 피터첸(Peter Chen)에 의해 Entity-Relationship Model(E-R Model) 이라는 표기법이 만들어졌다.', FALSE, '해설: None'),
(59, 1, '데이터베이스 개념', '다음은 데이터베이스 모델링에 대한 설명으로 가장 올바른 것은?', '', '증권회사에서 주문을 발주할 때 해당 종목에 대한 호가단위가 있다. 즉, 주문은 10호가를 기준으로 발주할 수가 있어서 어떤 종목을 주문할 때 1003원과 같은 금액으로는 발주할 수 없다. 이처럼 데이터베이스에서 값이 가질 수 있는 조건을 정의하는 것이다.', '도메인', '선텍도', '다중 값 속성', '시스템 카탈로그', FALSE, '해설: 도메인은 속성이 가질 수 있는 값의 범위이다.'),
(60, 1, '식별자', '다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?', '', '', '지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.', '주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.', '주식별자로 지정되더라도 속성 값으로 NULL이 들어갈 수 있다.', '주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.', FALSE, '해설: 주식별자는 NULL값이 들어갈 수 없다.'),
(61, 2, '집합 연산자', '다음 주어진 테이블에서 해당 SQL문을 실행한 결과로 알맞은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j496-1.png', 'SELECT * FROM SQLD5 WHERE COL1 IN (1,2,NULL);', '', '', '', '', FALSE, '해설: NULL은 비교에서 애초에 제외되어 IN 연산자 안에 NULL이 있어도 비교 연산을 수행하지 않는다. 주어진 테이블의 COL1 속성값 1,2값을 갖는 튜플만 조회된다.'),
(62, 2, 'SP', '아래는 임시부서(TMP_DEPT) 테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?', '', '[PL/SQL] create or replace procedure insert_dept authid_current_user as begin (ㄱ) INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC) SELECT DEPTNO, DNAME, LOC FROM TMP_DEPT; commit; end;', 'execute \'TRUNCATE TABLE DEPT\';', 'execute immediate \'TRUNCATE TABLE DEPT\';', 'DELETE FROM DEPT;', 'TRUNCATE TABLE DEPT;', FALSE, '해설: PL/SQL 에서는 동적 SQL 또는 DDL 문장을 실행할 때 EXECUTE IMMEDIATE 사용하여야 한다. ③번은 ROLLBACK이 가능하도록 삭제하는 것이 아니므로 옳은 답이 아니다.'),
(63, 2, '윈도우 함수', 'PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?', '', '', 'PIVOT 시 FOR 앞에는 반드시 집계함수(SUM, AVG 등)의 형태여야 한다.', 'UNPIVOT시 쌓을 컬럼을 지정할 수 없다.', 'UNPIVOT은 LONG 데이터를 WIDE 데이터로 변환하는 기법이다.', 'PIVOT은 교차표 형태의 데이터를 TIDY 데이터로 변경하는 문법이다.', FALSE, '해설: PIVOT 시에는 IN절에 나열한 값들을 갖는 행들이 결합되어 출력되므로 반드시 FOR 앞에는 집계함수 형태로 전달 되어야 한다.'),
(64, 2, '단일행 함수', '다음 중 순수 관계 연산자에 해당하지 않는 것은?', '', '', 'DIVIDE', 'JOIN', 'DELETE', 'SELECT', FALSE, '해설: 순수 관계 연산자란, 관계형 데이터베이스에 적용할 수 있도록 개발한 관계 연산자를 의미한다.'),
(65, 2, 'JOIN', '다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은?', '', '', 'INNER JOIN은 줄여서 JOIN으로 전달할 수 있다.', 'NATURAL JOIN시 같은 이름의 컬럼이 여러 개인 경우 USING절을 사용하여 원하는 컬럼을 선택할 수 있다.', 'FULL OUTER JOIN은 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과를 UNION한 것과 같다.', 'CROSS JOIN인 두 테이블의 조인 컬럼의 값과 상관없이 항상 모든 경우의 수를 출력한다.', FALSE, '해설: NATURAL JOIN은 USING, ON, WHERE 절에서 조건 정의가 불가하다.'),
(66, 2, '그룹 함수', 'EMP 테이블의 급여합계에 대해서 결합 가능한 모든 조건의 합계를 계산하는 것은?', '', '', 'CUBE(DEPTNO, JOB)', 'ROLLUP(DEPTNO, JOB)', 'GROUPING SETS(DEPTNO, JOB)', 'GROUP BY DEPTNO, JOB', FALSE, '해설: CUBE는 CUBE 함수에 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산한다.'),
(67, 2, 'DDL', '다음 중 아래와 같은 상황에서 사용할 수 있는 SQL 명령어는?', '', '우리가 관리하는 데이터베이스의 "매출" 테이블이 너무나 많은 디스크 용량을 차지하여 "매출” 테이블에서 필요한 데이터만을 추출하여 별도의 테이블로 옮겨 놓았다. 이후 "매출" 원본 테이블의 데이터를 모두 삭제함과 동시에, 디스크 사용량도 초기화 하고자 한다.(단, "매출" 테이블의 스키마 정의는 유지한다.)', 'DELETE TABLE FROM 매출;', 'DROP TABLE 매출;', 'DELETE FROM 매출;', 'TRUNCATE TABLE 매출;', FALSE, '해설: None'),
(68, 2, 'DML', '다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?', '', '', 'SELECT ENAME, SAL, COMM AS SAL_COMM', 'SELECT ENAME, SAL, JOB AS "JOB**"', 'SELECT ENAME, SAL, DEPTNO AS DEPT NUMBER', 'SELECT ENAME 이름, SAL AS Salary', FALSE, '해설: 컬럼 별칭 정의 시 _를 제외한 특수기호를 포함하는 경우 쌍따옴표로 묶어서 전달해야 한다. 또한, 컬럼 별칭에 공백(띄어쓰기)을 포함하는 경우 쌍따옴표로 묶어서 전달해야 한다.'),
(69, 2, '계층형 질의', 'BSC는 기업의 성과를 균형있게 관리하는 성과관리 시스템이다. BSC는 KPI를 사용해서 기업을 평가하는데 KPI는 상위, 중위, 하위 등의 KPI로 세분화 된다. 다음의 KPIPOOL 테이블에서 특정 하나의 값에 대한 자신의 상위 KPI를 검색하는 SQL문으로 올바른 것은?(이때, 자신의 KPI는 SUBKPI이고, 상위 KPI는 MAINKPI이다.)', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j469-1.png', '', 'Select * from kpipool where subkpi = 30 start with mainkpi = 0 connect by prior subkpi = mainkpi;', 'Select * from kpipool start with mainkpi = 100 connect by prior subkpi = mainkpi;', 'Select * from kpipool where subkpi = 30 start with mainkpi = 0 connect by prior mainkpi = subkpi;', 'Select * from kpipool start with mainkpi = 0 connect by prior subkpi = mainkpi;', FALSE, '해설: mainkpi가 0부터 출발하여 subkpi를 탐색한다. 그리고 subkpi가 30이면 출력시킨다. 이 때 subkpi 30에 대한 mainkpi 20번이 같이 출력된다.'),
(70, 2, '집합 연산자', '다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)', '', '', 'MINUS 연산자는 조회 결과에 대한 차집합을 의미한다.', 'INTERSECT 연산자는 조회 결과에 대한 교집합을 의미한다.', 'UNION ALL 연산자는 조회 결과를 정렬하고 중복되는 데이터를 한 번만 표현한다.', 'UNION 연산자는 조회 결과에 대한 합집합을 나타내며 정렬된 결과를 출력해준다.', FALSE, '해설: UNION ALL은 중복된 데이터를 모두 출력하며 정렬은 발생하지 않는다.'),
(71, 2, '계층형 질의', '다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?', '', '', 'CONNECT_BY_ISLEAF에서 해당 데이터가 리프 데이터면 1, 그렇지 않으면 0을 반환한다.', 'CONNECT BY는 부모 자식을 설명하는 것이다.', '계층형 쿼리는 계층형 형태로 데이터를 질의할 때 사용된다.', 'PRIOR 자식 = 부모 형태를 사용하면 계층 구조에서 순방향 전개를 수행한다.', FALSE, '해설: CONNECT BY는 부모 계층형 쿼리에서 부모 노드와 자식 노드 사이의 특정한 관계를 나타내는데 사용된다.'),
(72, 2, 'DML', '다음 SQL의 실행 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j84-1.png', '', '', '', '', '', FALSE, '해설: None'),
(73, 2, '그룹 함수', '다음 중 GROUP 함수에 대한 설명으로 올바른 것은?', '', '', 'ROLLUP은 CUBE에 비해서 시스템에 부하를 많이 발생시키므로 반드시 튜닝해야 한다.', 'ROLLUP, CUBE, GROUPING SETS은 정렬이 가능하지만, 하나의 칼럼에 대해서만 사용할 수 있다.', 'ROLLUP은 전체합계만을 구하고 싶을 때 사용한다.', 'CUBE는 결합 가능한 모든 값에 대하여 다차원 집계를 생성하는 것이 특징이다.', FALSE, '해설: CUBE는 CUBE 함수에 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산한다.'),
(74, 2, '계층형 질의', '다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?', '', '', '오라클의 계층형 질의문에서 PRIOR 키워드는 CONNECT BY 절에만 사용할 수 있으며 \'prior 자식 = 부모\' 형태로 사용하면 순방향 전개로 수행 된다.', '오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용된다.', 'SQL Server에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다.', 'SQL Server에서의 게층형 질의문은 CTE(Common Table Expression)를 재귀 호출함으로써 계층 구조를 전개한다.', FALSE, '해설: 오라클 계층형 질의문에서 PRIOR 키워드 SELECT, WHERE 절에서도 사용할 수 있다.'),
(75, 2, '계층형 질의', '다음과 같은 결괏값을 조회하기 위해서 SQL 문의 ( )에 알맞은 것을 넣으시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j309-1.png', 'SELECT ENAME, SAL, ( ) as CNT FROM Mytest;', 'COUNT(*) OVER(ORDER BY CNT RANGE BETWEEN 50 PRECEDING 100 FOLLOWING)', 'COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 0 PRECEDING 100 FOLLOWING)', 'COUNT(*) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING)', 'MAX(SAL) OVER(ORDER BY SAL RANGE BETWEEN 50 PRECEDING 100 FOLLOWING)', FALSE, '해설: 먼저 위의 Mytest 테이블에서 결괏값과 같이 반환되도록 \'\'SAL" 속성을 기준으로 정렬을 수행하고 각각의 행에서의 SAL 속성값을 기준으로 -50에서 +150 범위 사이에 포함되는 SAL값을 가지는 모든 행의 수를 COUNT하여 CNT 속성값으로 조회한다.'),
(76, 2, 'DML', '다음 SQL 문장의 결과로 출력되는 데이터는 무엇인가?', '', 'SELECT PLAYER_NAME 선수명, E_PLAYER_NAME 선수영문명 FROM PLAYER WHERE E_PLAYER_NMAE_LIKE \'_A%\';', '위치에 상관없이 선수의 영문 이름에 A를 포함하는 선수들의 이름', '선수의 영문 이름이 A로 시작하는 선수들의 이름', '선수의 영문 이름이 A나 a로 시작하는 선수들의 이름', '선수의 영문 이름의 두 번째 문자가 A인 선수들의 이름', FALSE, '해설: "_"와 "%"는 와일드카드로 하나의 글자 또는 모든 문자를 대신하여 사용이 되므로 두 번째 문자가 대문자 A인 경우만 출력된다.'),
(77, 2, 'DML', '다음 SQL중 실행 결과가 다른 하나는?', '', '', 'SELECT CASE DEPTNO WHEN 10 THEN CASE WHEN JOB = \'CLERK\' THEN \'A\' ELSE \'B\' END WHEN 20 THEN \'C\' ELSE \'D\' END FROM EMP;', 'SELECT CASE WHEN DEPTNO = 10 THEN CASE WHEN JOB = \'CLERK\' THEN \'A\' ELSE \'B\' END WHEN DEPTNO = 20 THEN \'C\' ELSE \'D\' END FROM EMP;', 'SELECT CASE WHEN (DEPTNO = 10 AND JOB = \'CLERK\') THEN \'A\' ELSE \'B\' WHEN DEPTNO = 20 THEN \'C\' ELSE \'D\' END FROM EMP;', 'SELECT DECODE(DEPTNO, 10, DECODE(JOB, \'CLERK\', \'A\', \'B\'), 20, \'C\', \'D\') FROM EMP;', FALSE, '해설: 2번은 에러가 발생하는 문장으로 마지막 WHEN절에만 ELSE를 사용할 수 있다.'),
(78, 2, '계층형 질의', '다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. ( )에 올바른 것은?', '', 'SELECT LEVEL, LPAD(\' \',4 + (LEVEL -1) )|| EMPNO, MGR, ( ) AS ISLEAF FROM Mytest START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;', 'CONNECT_BY_LEAF', 'SYS_CONNECT_BY_PATH', 'CONNECT_BY_ISCYCLE', 'CONNECT_BY_ISLEAF', FALSE, '해설: -CONNECT_BY_ISLEAF : 전개 과정에서 해당 데이터가 리프 데이터면 1, 아니면 0을 반환한다. -CONNECT_BY_ISCYCLE : 전개 과정에서 자식을 갖는데, 해당 데이터가 조상으로 존재하면1, 그렇지 않으면 0을 반환한다. 여기서 조상이란 자신으로부터 루트까지의 경로에 존재하는 데이터를 말한다. -SYS_CONNECT_BY_PATH : 하위 레벨의 칼럼까지 모두 표시해준다.'),
(79, 2, 'DML', '다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?', '', '', 'FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY', 'FROM - WHERE - GROUP BY - HAVING - ORDER BY - SELECT', 'FROM - SELECT - WHERE - GROUP BY - HAVING - ORDER BY', 'SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY', FALSE, '해설: None'),
(80, 2, '집합 연산자', 'Orders 테이블의 고객id에는 Customers 테이블에 존재하지 않는 고객id도 있다. Customers 테이블에 존재하지 않는 고객id만 Orders 테이블에서 추출하는 SQL을 ( )를 채워 완성하시오.', '', 'SELECT * FROM Orders WHERE ( ㄱ ) (SELECT * FROM Customers WHERE ( ㄴ ));', 'ㄱ: NOT EXISTS ㄴ: Customers. id <> Orders. id', 'ㄱ: NOT EXISTS ㄴ: Customers. id = Orders. id', 'ㄱ: EXISTS ㄴ: Customers. id <> Orders. id', 'ㄱ: EXISTS ㄴ: Customers. id = Orders. id', FALSE, '해설: Customers 테이블에서 존재하지 않은 고객id를 식별하기 위해서는 NOT EXISTS를 사용하고 WHERE구에 "Customers. id = Orders. id"를 사용해야 한다.'),
(81, 2, 'JOIN', '아래 결과를 출력하기 위해 빈칸에 들어갈 문장으로 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j653-1.png', '', 'SELECT 고객.고객번호, 상품.상품명 FROM 고객, 상품 ON 고객.포인트 >= 상품.최소포인트(+);', 'SELECT 고객.고객번호, 상품.상품명 FROM 고객 JOIN 상품 ON 고객.포인트 BETWEEN 상품.최소포인트 AND 상품.최대포인트;', 'SELECT 고객.고객번호, 상품.상품명 FROM 고객 INNER JOIN 상품 ON 고객.포인트 <= 상품.최대포인트;', 'SELECT 고객.고객번호, 상품.상품명 FROM 고객 INNER JOIN 상품 ON 고객.포인트 >= 상품.최소포인트;', FALSE, '해설: 결과표를 보면 고객이 보유한 포인트에 맞춰서 상품을 출력한 것을 알 수 있다. 따라서 고객이 보유한 포인트가 상품 테이블의 최소포인트와 최대포인트 사이에 있는 조건을 갖는 쿼리는 3번이다.'),
(82, 2, '집계 함수', '주어진 테이블에 대해서 아래와 같은 결괏값을 반환하는 SQL문을 고르시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j494-1.png', '', 'SELECT COUNT(CASE WHEN BAN=1 THEN 1 END) AS Result, COUNT(CASE WHEN BAN=2 THEN 1 END) AS B, COUNT(CASE WHEN BAN=3 THEN 1 END) AS C FROM TEST15;', 'SELECT BAN, COUNT(DISTINCT NAME) AS RESULT FROM TEST15 GROUP BY BAN;', 'SELECT BAN, COUNT(1) AS RESULT FROM TEST15 GROUP BY BAN;', 'SELECT BAN, COUNT(*) AS RESULT FROM TEST15 GROUP BY BAN;', FALSE, '해설: ②번 보기는 BAN칼럼으로 그룹핑하고 DISTINCT를 사용해서 중복된 이름을 제거하고 카운팅한다.'),
(83, 2, 'NULL', '다음 중 틀린 설명은? (단, DBMS는 ORACLE)', '', '', 'ORDER BY COMM DESC NULLS LAST 시 NULL이 맨 앞에 배치된다.', 'ORDER BY COMM DESC 시 NULL이 맨 앞에 배치된다.', 'ORDER BY COMM NULLS FIRST 시 NULL이 맨 앞에 배치된다.', 'ORDER BY COMM 시 NULL이 마지막에 배치된다.', FALSE, '해설: ORDER BY 시 DESC NULLS LAST 하면 NULL값이 맨 뒤에 배치된다.'),
(84, 2, 'DML', 'SQL의 LIKE 구문을 사용해서 데이터 내부에 "_"이 있는 것을 검색하는 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j414-1.png', '', 'SELECT * FROM Mytest WHERE NAME LIKE \'%_%\' ESCAPE \'_\'', 'SELECT * FROM Mytest WHERE NAME LIKE \'%@_%\' ESCAPE \'@\'', 'SELECT * FROM Mytest WHERE NAME LIKE \'%#_%\'', 'SELECT * FROM Mytest WHERE NAME LIKE \'%_%\'', FALSE, '해설: LIKE 연산은 \'%\'나 \'_\'가 들어간 문자를 검색하기 위해서는 ESCAPE 명령어를 사용할 수 있다. 사용 방법은 \'_\' 나 \'%\' 앞에 ESCAPE로 특수 문자를 지정하여 검색한다.'),
(85, 2, 'DML', 'SELECT 문에 대한 설명으로 가장 적절하지 않은 것은?', '', '', 'SELECT절에 DISTINCT는 항상 SELECT 바로 뒤에 위치한다.', 'FROM 절은 모든 DBMS에서 생략 가능하다.', 'ORDER BY절은 문법 순서도 맨 마지막에 위치하며, 실행 순서 역시 마지막이다.', '오라클에서는 GROUP BY절 위에 HAVING절을 명시할 수 있다.', FALSE, '해설: FROM 절은 ORACLE 에서는 생략 불가하다. GROUP BY 절과 HAVING 절은 순서가 바뀌어도 상관없으나 가급적 순서대로 사용한다.'),
(86, 2, '그룹 함수', '소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?', '', '', 'CUBE, SUM', 'ROLLUP, CUBE', 'GROUPING, SUM', 'ROLLUP, SUM', FALSE, '해설: ROLLUP, CUBE 는 GROUP BY의 확장된 형태로 병렬로 수행이 가능하고 사용하기가 쉽기 때문에 효과적이다. 다차원적인 집계가 필요한 경우는 CUBE를 사용한다.'),
(87, 2, 'DML', 'SELECT 문에 대한 설명으로 가장 적절하지 않은 것은?', '', '', 'SELECT문의 6개 절 중에서 SELECT절이 가장 마지막에 실행된다.', 'HAVING절에서는 그룹함수가 없는 일반 조건을 사용할 수 있다.', 'WHERE절에는 그룹함수를 사용한 조건 전달이 불가하다.', 'GROUP BY절에는 컬럼별칭을 사용할 수 없다.', FALSE, '해설: SELECT문 수행 순서는 FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY 순이다.'),
(88, 2, 'DML', '다음 SQL문과 동일한 결과를 반환하는 SQL문은?', '', 'select * from Mytest where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);', 'select * from Mytest where COL1 = 1 or (COL2 = 3 or COL2 = 4);', 'select * from Mytest where COL1 in (1,3) or COL2 in (1,4);', 'select * from Mytest where COL1 in (1,3) and COL2 in (1,4);', 'select * from Mytest where COL1 = 1 and (COL2 = 3 or COL2 = 4);', FALSE, '해설: 주어진 SQL문은 COL1, COL2 값이 각각(1,3) (1,4)인 행들만 조회되는 SQL문이다. 이와 같은 값을 반환하는 보기는 COL1이 1이면서 COL2가 3 또는 4인 값을 조회하는 ④번 보기이다.'),
(89, 2, 'DML', '야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)', '', '', 'SELECT * FROM 야구선수 ORDER BY 선수명, 팀명, DESC, 연봉 ASC', 'SELECT * FROM 야구선수 ORDER BY 선수명 ASC, 팀명, ASC, 연봉 ASC', 'SELECT * FROM 야구선수 ORDER BY 선수명 DESC, 팀명, DESC, 연봉 ASC', 'SELECT * FROM 야구선수 ORDER BY 선수명 ASC, 팀명, 3 DESC', FALSE, '해설: ORDER BY 구는 기본적으로 오름차순을 한다. 즉, 보기 ④번은 "선수명 ASC"로 오름차순하고 "팀명"도 오름차순이다. "3 DESC"는 연봉으로 내림차순을 한다.'),
(90, 2, 'DDL', '다음 중 아래의데이터모델과 깉은테이블 및 제익조건을 생성하는 DDL문장으로 올바른 것은? (단, DBMS는 Oracle을 기준으로 한다.)', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j42-1.png', '', 'CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) NOT NULL ,PROD_NM VARCHAR2(100) NOT NULL ,REG_DT DATE NOT NULL ,REGR_NO NUMBER(10) .CONSTRAINT PRODUCT_PK PRIMARY KEY (PROD_ID) );', 'CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) NOT NULL ,PROD_NM VARCHAR2(100) NOT NULL ,REG_DT DATE NOT NULL ,REGR_NO NUMBER(IO) NULL ,ADD CONSTRAINT PRIMARY KEY (PROD_ID) );', 'CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) ,PROD_NM VARCHAR2(100) ,REG_DT DATE ,REGR_NO NUMBER(10) ); ALTER TABLE PRODUCT ADD CONSTRAINT PRODUCT_PK PRIMARY KEY (PROD_ID);', 'CREATE TABLE PRODUCT ( PROD_ID VARCHAR2(10) NOT NULL ,PROD_NM VARCHAR2(100) NOT NULL ,REG_DT DATE NOT NULL ,REGR_NO NUMBER(10) NULL); ALTER TABLE PRODUCT ADD PRIMARY KEY PRODUCT_PK ON (PROD_ID);', FALSE, '해설: None'),
(91, 2, '집합 연산자', '다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?', '', '', 'intersect', 'except', 'union all', 'union', FALSE, '해설: ①번은 교집합 집합 연산자이다. ③번은 중복 포함 합집합이다. ④번은 중복 제거 합집합이다.'),
(92, 2, '윈도우 함수', '다음 중 [사원] 테이블에 대하여 아래와같은 SQL을 수행하였을 때 예상되는 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j135-1.png', '', '', '', '', '', FALSE, '해설: None'),
(93, 2, 'JOIN', 'JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?', '', '', 'SELF JOIN은 하나의 테이블을 논리적으로 분리시켜 EQUI JOIN을 이용하는 방법이다.', 'OUTER JOIN은 JOIN 조건을 만족하지 않는 데이터도 볼 수 있는 JOIN 방법이다.', 'EQUI JOIN은 반드시 기본키, 외래키 관계에 의해서만 성립된다.', 'NON-EQUI JOIN은 등가 조건이 성립되지 않은 테이블에 JOIN을 걸어주는 방법이다.', FALSE, '해설: EQUI JOIN은 반드시 기본키,외래키 관계에 의해서만 성립되는 것은 아니다. 조인 칼럼이 1:1로 맵핑이 가능하면 사용할 수 있다.'),
(94, 2, 'JOIN', '다음 중 아래와 같은 데이터 상황에서 SQL의 수행 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j98-1.png', '', '', '', '', '', FALSE, '해설: None'),
(95, 2, '계층형 질의', '다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?', '', '', '루트 노드의 LEVEL 값은 1이 아니다.', '순방향 전개란 부모 노드로부터 자식 노드로 전개하는 것이고 역방향 전개는 자식 노드에서 부모 노드로 전개하는 것이다.', 'ORDER SIBILINGS BY구는 형제 노드 사이에 정렬을 수행한다.', 'START WITH절은 계층 구조의 시작점을 지정하는 구문이다.', FALSE, '해설: Oracle 계층형 질의에서 루트 노드의 LEVEL값은 1이다.'),
(96, 2, '트랜잭션 관리', '트랜잭션의 특징 중 옳지 않은 것은?', '', '', '중복성', '지속성', '원자성', '일관성', FALSE, '해설: 트랜잭션의 특징으로는 일관성, 원자성, 지속성, 고립성 등이 있다.'),
(97, 2, 'JOIN', '아래와 같은 데이터 모델에서 ORACLE을 기준으로 SQL을 작성하였다. 그러나 SQL Server에서도 동일한 결과를 보장할 수 있도록 ANSI 구문으로 SQL을 변경하려고 한다. 다음 중 아래의 SQL을 ANSI 표준 구문으로 변경한 것으로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j99-1.png', '', 'SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A RIGHT OUTER JOIN 게시글 B ON (A.게시판ID = B.게시판ID AND A.사용여부 = \'Y\' AND B.삭제여부 = \'N\') GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;', 'SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A LEFT OUTER JOIN 게시글 B ON (A.게시판ID = B.게시판ID) WHERE A.사용여부 = \'Y\' AND B.삭제여부 = \'N\' GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;', 'SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A LEFT OUTER JOIN 게시글 B ON(A.게시판ID = B.게시판ID AND A.사용여부 = \'Y\') WHERE B. 삭제여부 = \'N\' GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;', 'SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A LEFT OUTER JOIN 게시글 B ON (A.게시판ID = B.게시판ID AND B.삭제여부 = \'N\') WHERE A.사용여부 = \'Y\' GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;', FALSE, '해설: None'),
(98, 2, '계층형 질의', '주어진 테이블에 대해서 아래의 SQL문을 수행한 결과로 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j491-1.png', 'select count(*) from TEST11 where COL3 <> 3 start with COL3 = 4 connect by COL1 = prior COL2;', '3', '2', '1', '0', FALSE, '해설: None'),
(99, 2, '서브쿼리', '아래와 같은 데이터 모델에서 평가대상상품에 대한 품질평기향목별 최종 평가 결과를 추출하는 SQL 문장으로 옳은 것은? (단, 평가항목에 대한 평가(평가등급)가 기대수준에 미치지 못할 경우 해당 평기항목에 대해서만 재평가를 수행한다)', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j120-1.png', '', 'SELECT B.상품ID. B.상품명, C.평가항목ID, C.평가항목명, A.평가회차, A.평가등급, A.평가일자 FROM (SELECT 상품ID, 평가항목ID ,MAX(평가회차) AS 평가회차 ,MAX(평가등급) AS 평가등급 ,MAX(평가일자) AS 평가일자 FROM 평가결과 GROUP BY 상품ID, 평가항목ID) A, 평가대상상품 B, 품질평가항목 C WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID;', 'SELECT B.상품ID, B.상품명, C.평가항목ID, C.평가항목명 ,MAX(A.평가회차) AS 평가회차 ,MAX(A.평가등급) AS 평가등급 ,MAX(A.평가일자) AS 평가일자 FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID GROUP BY B.상품ID, B.상품명, C.평가항목ID, C.평가항목명;', 'SELECT B.상품ID, B.상품명, C.평가항목ID, C.평가항목명, A.평가회차, A.평가등급, A.평가일자 FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID AND A.평가회차 = (SELECT MAX(X.평가회차) FROM 평가결과 X WHERE X.상품ID = B.상품ID AND X.평가항목ID = C.평가항목ID);', 'SELECT B.상품ID, B.상품명, C.평가항목ID, C.평가항목명, A.평가회차, A.평가등급, A.평가일자 FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C, (SELECT MAX(평가회차) AS 평가회차 FROM 평가결과) D WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID AND A.평가회차 = D.평가회차;', FALSE, '해설: ① 특정 평가회차에 대한 결과가 아닌, 상품ID, 평가항목ID별로 개별 MAX값을 구하므로 원하는 결과 가 아니다. ② 특정 평가회차에 대한 결과가 아닌, 평가결과 엔터티의 평가회차, 평가등급, 평가일자 속성에 대해 서 개별 MAX 값을 구하므로 원하는 결과가 아니다. ③ 연관 서브쿼리를 활용하여 특정 상품, 평가항목별로 최종 평가회차와 Join을 수행하여 원하는 결과를 출력한다. ④ Inline View D 에서 평가결과 엔터티의 특정상품 및 평가항목에 대한 최종 평가회차가 아닌 전체 데이터 중 평가회차가 가장 큰 값을 가지고 JOIN을 수행하므로 원하는 결과가 아니다.'),
(100, 1, 'ER 모델링', '다음 중 엔터티 간의 관계에서 1:1, 1:M과 같이 관계의 기수성을 나타내는 것은?', '', '', '관계정의', '도메인', '관계차수', '관계명', FALSE, '해설: 관계의 기수성을 나타내는 개념은 관계차수에 해당한다. 즉, 카디널리티는 하나의 릴레이션에서 튜플의 전체 개수를 의미한다.'),
(101, 1, 'ER 모델링', '아래 ERD에 대한 설명으로 가장 올바르지 않은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j484-1.png', '', '여러 사원이 동일한 콘도를 이용할 수 있다.', '사원은 동일 일자에 여러 콘도를 이용할 수 있다.', '회사 콘도는 누구도 이용하지 않을 수 있다.', '사원은 동일한 콘도를 예약해서 반복적으로 방문할 수 있다.', FALSE, '해설: 이용내역\' 엔터티에서 이용일자 + 사원번호가 기본키이므로 일자가 같은 날에 여러 콘도를 이용할 수 없다.'),
(102, 1, '데이터 무결성', '외래키에 대한 설명으로 가장 적절하지 않은 것은?', '', '', '자식 테이블은 UPDATE, INSERT 시 제약을 받는다.', 'ON DELETE CASCADE 옵션으로 외래키 생성 시 부모 데이터만 삭제되고 자식데이터는 그대로 남는다.', '외래키 생성 후 부모 테이블은 자식 데이터가 있을 경우 삭제 불가하다.', '외래키 생성 시 참조 테이블의 참조키에 반드시 기본키 또는 고유키가 생성되어 있어야 한다.', FALSE, '해설: ON DELETE CASCADE 옵션으로 외래키 생성 시 부모 데이터 삭제 시 자식 데이터도 함께 삭제된다.'),
(103, 1, 'ER 모델링', '다음 중 주식별자의 특징으로 올바르지 않은 것은?', '', '', '존재성 : 주식별자로 지정되면 데이터값이 존재하지 않을 수 있다.', '불변성 : 식별자의 값은 변하지 않아야 한다.', '최소성 : 속성의 수는 유일성을 만족해야 하고 최소의 수가 되어야 한다.', '유일성 : 엔터티 내에서 모든 인스턴스들은 유일해야 한다.', FALSE, '해설: 주식별자는 NULL값을 가질 수 가 없다. 즉, 주식별자는 NOT NULL이어야 한다.'),
(104, 1, '정규화', '데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?', '', '', '제4정규화', '제3정규화', '제2정규화', '제1정규화', FALSE, '해설: 제3정규화는 이행 함수 종속성 제거로 칼럼 간에 종속성이 발생하면 테이블을 분할한다.'),
(105, 1, '데이터 무결성', '다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.', '', '', '외래키 값은 참조 무결성 제약을 받을 수 있다.', '한 테이블에 하나만 존재해야 한다.', '외래키 값은 널 값을 가질 수 없다.', '테이블 생성시 설정할 수 있다.', TRUE, '해설: None'),
(106, 1, 'NULL', 'NULL에 대한 설명으로 틀린 것은?', '', '', '공백과 같은 ASCII 값을 가진다.', 'NULL과의 수치연산은 NULL 값을 리턴한다.', 'NULL과의 비교연산은 FALSE(거짓)를 리턴한다.', '값이 존재하지 않거나 확정되지 않은 값을 의미한다.', FALSE, '해설: 공백과는 다른 개념이므로 공백과 다른 ASCII 값을 갖는다.'),
(107, 1, 'ER 모델링', '속성의 특성에 따른 분류로 올바른 것은?', '', '', '일반 속성, 설계 속성, 파생 속성', '기본 속성, 설계 속성, 일반 속성', '기본 속성, 설계 속성, 파생 속성', '기본 속성, 일반 속성, 파생 속성', FALSE, '해설: None'),
(108, 1, 'NULL', '다음 중 아래 데이터를 가지고 있는 EMP_Q 테이블에서 세개의 SQL 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j74-1.png', '', '0,에러 발생, NULL', '에러 발생, 에러 발생, NULL', '0, 에러 발생, 에러 발생', '0, NULL, NULL', FALSE, '해설: None'),
(109, 1, 'ER 모델링', '다음의 ERD에 대한 설명으로 올바르지 않은 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j481-1.png', '', '의사가 없이 진료할 수 있다.', '진료는 반드시 의사가 해야 한다.', '한 개의 상급종합병원에는 여러 명의 의사가 근무한다.', '상급종합병원에는 의사가 근무하지 않을 수가 있다.', FALSE, '해설: 상급종합병원에는 한 명의 혹은 여러 명의 의사가 근무하고 모델링으로는 의사가 없을 수도 있다. 진료는 의사만 할 수 있고 의사는 진료를 하지 않을 수도 있다.'),
(110, 2, '집계 함수', '다음 SQL 문장 중 실행 결과가 다른 하나는?', '', '', 'SELECT COUNT(*) FROM EMP WHERE (DEPTNO = 10 OR DEPTNO = 20 AND JOB = \'CLERK\') ;', 'SELECT COUNT(*) FROM EMP WHERE DEPTNO = 10 OR (DEPTNO = 20 AND JOB = \'CLERK\');', 'SELECT COUNT(*) FROM EMP WHERE (DEPTNO = 10 OR DEPTNO = 20) AND JOB = \'CLERK\';', 'SELECT COUNT(*) FROM EMP WHERE DEPTNO = 10 OR DEPTNO = 20 AND JOB = \'CLERK\';', FALSE, '해설: 연산자는 NOT > AND > OR 순서대로의 우선순위를 가지고 있다. 따라서 1, 3, 4 번의 경우 DEPTNO = 20 AND JOB=\'CLERK\' 조건이 먼저 실행되고, 이 결과에 DEPTNO = 10 조건에 만족하는 집합을 합하여 리턴되므로 2 번과의 결과가 달라진다.'),
(111, 2, '집합 연산자', '테이블이 아래와 같을 때, 다음 집합연산자 수행 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j655-1.png', 'SELECT * FROM (SELECT COL1, COL2 FROM TAB1 UNION SELECT COL1, COL2 FROM TAB2) MINUS SELECT COL1, COL2 FROM TAB3;', '', '', '', '', FALSE, '해설: 먼저 TAB1과 TAB2의 UNION 결과는 아래와 같다. 이들 중 TAB3의 결과를 빼면 3번 결과가 같다.'),
(112, 2, '집계 함수', '도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)', '', '', 'SELECT 출판사명 FROM 도서 WHERE 발행연도 >= 2000 GROUP BY 출판사명 HAVING COUNT(도서번호) >= 10;', 'SELECT 출판사명 FROM 도서 WHERE COUNT(도서번호) >= 10 GROUP BY 출판사명 HAVING 발행연도 >= 2000;', 'SELECT 출판사명 FROM 도서 WHERE 발행연도 >= 2000 AND COUNT(도서번호) >= 10 GROUP BY 출판사명;', 'SELECT 출판사명 FROM 도서 WHERE 발행연도 >= 2000 ORDER BY COUNT(도서번호) >= 10;', FALSE, '해설: 문제에서 10권 이상 구매한 사람을 출력하기 위해서 "HAVING COUNT(도서번호)=10" 의 HAVING 절을 추가하고 발행연도가 2000 이후 이므로 WHERE절에 "발행연도 >= 2000"을 넣어야 한다. 또한 출판사명은 이름에 중복이 없어야 하므로 GROUP BY구로 "출판사명"을 추가하면 된다.'),
(113, 2, '단일행 함수', '다음 함수의 출력 결과로 가장 적절하지 않은 것은?', '', '', 'LAST_DAY(TO_DATE(\'2024-01-01\',\'YYYY-MM-DD\')) : 2024-01-31', 'POWER(3,3) = 9', 'FLOOR(3.5) = 3', 'DATE_FORMAT(\'2024-01-01\',\'%Y-%m-%d\') : 2024-01-01', FALSE, '해설: POWER 는 거듭제곱을 출력하는 함수이다. 따라서 POWER(3,3) 는 3의 3 거듭제곱, 27이 리턴된다. LAST_DAY는 지정된 날짜가 속한 달의 마지막 날짜를 리턴한다.'),
(114, 2, 'JOIN', '다음 중 HASH 조인의 순서로 올바른 것은?', '', '가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다. 나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다. 다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다. 라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다. 마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.', '가 -> 라 -> 나 -> 마 -> 다', '나 -> 가 -> 마 -> 라 -> 다', '가 -> 나 -> 라 -> 마 -> 다', '가 -> 나 -> 다 -> 라 -> 마', FALSE, '해설: 가->나->다->라->마 순서대로 해시 조인을 실행한다.'),
(115, 2, '그룹 함수', '다음 중 주어진 테이블에서 SQL문의 실행 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j461-1.png', 'SELECT ID FROM test29 GROUP BY ID HAVING COUNT(*) = 2 ORDER BY (CASE WHEN ID = 1000 THEN 0 ELSE ID END);', '', '', '', '', FALSE, '해설: CASE문으로 ID가 1000인 것은 0 으로 변경하고 나머지는 ID값으로 ASC(오름차순) 한다. 단, COUNT 함수로 2건만 조회된다. 따라서 3000, 9999의 값이 2건이라서 3000, 9999만 조회된다.'),
(116, 2, '집합 연산자', '다음 SQL 중 정상 수행이 불가한 것은?', '', '', 'UPDATE TAB1 A SET A.NAME = (SELECT B.NAME FROM TAB2 B WHERE A.NO = B.NO);', 'SELECT NO FROM TAB1 A JOIN TAB2 B USING (NO);', 'SELECT A.NO, (SELECT B.NAME FROM TAB2 B) FROM TAB1 A WHERE A.NO = B.NO;', 'SELECT * FROM TAB1 A WHERE NOT EXISTS (SELECT \'X\' FROM TAB2 B WHERE A.NO = B.NO);', FALSE, '해설: 3번 지문의 경우 스칼라 서브쿼리 결과가 여러 행인 경우 출력이 불가하다. 또한, 메인 쿼리 절에 사용된 WHERE A.NO = B.NO 조건은 실행이 불가한데 메인 쿼리에서는 FROM 절에 A 테이블만 선언되었기 때문에 B 테이블은 인식할 수 없기 때문이다.'),
(117, 2, '단일행 함수', '다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?', '', 'SELECT SYSDATE FROM DUAL;', 'CONVERT', 'TO_CHAR', 'TO_DATE', 'TO_NUMBER', FALSE, '해설: TO_CHAR문을 사용하면 문자형 타입으로 변환한다.'),
(118, 2, '집계 함수', '다음의 SQL문을 실행한 결과로 올바른 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j377-1.png', 'SELECT COUNT(C1) FROM Mytest', '4', '3', '2', '1', FALSE, '해설: COUNT(C1)은 NULL 값은 제외된다. 따라서 3개가 된다.'),
(119, 2, 'JOIN', '다음 SQL의 실행 결과로 맞는 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j89-1.png', '', '6', '4', '2', '0', FALSE, '해설: None'),
(120, 2, 'NULL', '다음 보기의 SQL문을 실행 했을 때 결괏값이 다른 하나는?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j294-1.png', '', 'select NVL(a.COL1,-1) as data from Mytest a;', 'select DECODE(a.COL1, null,-1,a.col1) as data from Mytest a;', 'select case when a.COL1 is null then -1 else 0 end as data from Mytest a;', 'select case a.COL1 when null then -1 else 0 end as data from Mytest a;', FALSE, '해설: 나머지 보기는 모두 COL1 값이 NULL일 때 -1을 반환하는데 ④번 보기만 COL1값이 NULL일 때 0 을 반환한다. 즉, CASE문으로 NULL을 비교할 때 알수 없음이 된다.'),
(121, 2, '집합 연산자', '다음의 SQL문 중에서 결과가 동일한 하나의 SQL문은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j470-1.png', 'select * from kpipool where (subkpi, mainkpi) in((20,10),(0,30));', 'select * from kpipool where (subkpi, mainkpi) in ((20,30),(30,40));', 'select * from kpipool where (subkpi, mainkpi) in ((10,20),(20,30));', 'select * from kpipool where subkpi in (20,10);', 'select * from kpipool where subkpi = 20;', FALSE, '해설: ④번의 SQL문 subkpi가 20번인 행을 조회한다. 그리고 문제에서 제시한 SQL문도 in구로 (20,10)을 사용했으므로 똑같이 subkpi가 20인 행이 조회된다.'),
(122, 2, 'DDL', '다음 중 SQL 명령어가 올바르지 않은 것은?', '', '', 'DML : RENAME', 'DCL : REVOKE', 'DDL : ALTER', 'DDL : TRUNCATE', FALSE, '해설: DDL은 CREATE, ALTER, DROP 문이 있다.'),
(123, 2, '그룹 함수', '아래 쿼리중 결과값이 다른 하나는?', '', '', 'SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY DNAME, JOB UNION ALL SELECT DNAME, \'\' AS JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY DNAME UNION ALL SELECT \'\' AS DNAME, \'\' AS JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO ORDER BY 1, 2;', ' SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY CUBE(DNAME, JOB) ORDER BY 1, 2;', 'SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY GROUPING SETS((DNAME,JOB), DNAME, NULL) ORDER BY 1, 2;', 'SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL FROM SCOTT.EMP A, SCOTT.DEPT B WHERE A.DEPTNO = B.DEPTNO GROUP BY ROLLUP(DNAME,JOB) ORDER BY DNAME, JOB;', FALSE, '해설: ROLLUP(A, B)는 A별, (A, B)별, 전체 그룹 연산 결과가 출력, CUBE(A, B)는 A별, B별, (A, B)별, 전체 그룹 연산 결과 출력 GROUPING SET은 나열한 것만 출력된다.'),
(124, 2, '그룹 함수', '다음 중 아래의 테이블에서 SQL을 실행할 때 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j124-1.png', '[SQL] SELECT CASE WHEN GROUPING(A.서비스ID) = 0 THEN A.서비스ID ELSE \'합계\', END AS 서비스ID ,CASE WHEN GROUPING (B.가입일자) = 0 THEN NVL (B.가입일자, \'-\') ELSE \'소계\' END AS 가입일자 ,COUNT (B. 회원번호) AS 가입건수 FROM 서비스 A LEFT OUTER JOIN 서비스가입 B ON (A.서비스ID = B. 서비스ID AND B.가입일자 BETWEEN \'2013-01-01\' AND \'2013-01-31\') GROUP BY ROLLUP (A.서비스ID, B.가입일자);', 'execute \'TRUNCATE TABLE DEPT\';', 'execute immediate \'TRUNCATE TABLE DEPT\';', 'DELETE FROM DEPT;', 'TRUNCATE TABLE DEPT;', FALSE, '해설: ROLLUP은 계층 구조를 가진 SUB TOTAL을 생성하는 함수로 나열된 컬럼의 순서가 변경되면 수행 결과도 변경된다. 위의 SQL문장은 서비스ID에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수 를 구하되 Outer Join을 수행하였으므로 가입내역이 없는 서비스ID(004)에 대해서도 SUB TOTAL을 출력하고 있다. ④은 서비스ID 에 대해서 가입일자별 가입건수 및 소계와 전체 가입건수를 구한 것은 맞으나 LEFT OUTER JOIN이 아닌 INNER JOIN에 대한 결과로 서비스ID 004가 출력되지 않았다.'),
(125, 2, '그룹 함수', '아래의 결괏값을 보고 SQL문의 빈칸에 들어 갈 수 있는 내용을 고르시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j205-1.png', 'SELECT DEPTNO, JOB, SUM(SAL) FROM SQLD_73 GROUP BY ( );', 'CUBE(DEPTNO, JOB)', 'DEPTNO, JOB', 'GROUPING SETS(DEPTNO, JOB)', 'ROLLUP(DEPTNO, JOB)', FALSE, '해설: 주어진 결괏값을 보면 1.DEPTNO별 합계, 2.DEPTNO, JOB별 합계, 3.전체 합계가 조회되므로 빈칸에는 그룹 함수 중 ROLLUP이 와야 한다.'),
(126, 2, '계층형 질의', '다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?', '', '', 'CONNECT_BY_ISLEAF에서 해당 데이터가 리프 데이터면 1, 그렇지 않으면 0을 반환한다.', 'CONNECT BY는 부모 자식을 설명하는 것이다.', '계층형 쿼리는 계층형 형태로 데이터를 질의할 때 사용된다.', 'PRIOR 자식 = 부모 형태를 사용하면 계층 구조에서 순방향 전개를 수행한다.', FALSE, '해설: CONNECT BY는 부모 계층형 쿼리에서 부모 노드와 자식 노드 사이의 특정한 관계를 나타내는데 사용된다.'),
(127, 2, 'JOIN', '다음 SQL문에서 ( )에 들어갈 알맞은 명령어는 무엇인가?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j244-1.png', '', 'CROSS JOIN', 'RIGHT OUTER JOIN', 'LEFT OUTER JOIN', 'FULL OUTER JOIN', FALSE, '해설: DEPT 테이블에 있는 40번이 조회되고 EMP테이블은 NULL로 조회되므로 RIGHT OUTER JOIN이다.'),
(128, 2, '집계 함수', '다음 SQL 실행 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j642-1.png', 'SELECT COL1 AS C1, SUM(COL2) AS C2 FROM TAB1 GROUP BY COL1 HAVING SUM(COL2) >= 400;', '', '', '', '', FALSE, '해설: GROUP BY 후 SUM(COL2) 연산 결과 (10, 300), (20, 400), (30, 500), (NULL, 600) 그룹이 출력된다. 이들 중 HAVING 조건에 만족하는 그룹은 (20, 400), (30, 500), (NULL, 600) 이다.'),
(129, 2, '집계 함수', '다음 중 잘못된 SQL문을 고르시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j427-1.png', '', 'SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal IN (SELECT SAL from Limbest.emp where DEPTNO = 10);', 'SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal >= ANY(30,40,50,60,70);', 'SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal <= ANY(30,40,50,60,70);', 'SELECT b.dname, a.ename, a.sal FROM Limbest.emp a, Limbest.dept b where a.deptno = b.deptno and sal <= (SELECT MAX(sal) FROM Limbest.emp GROUP BY DEPTNO);', FALSE, '해설: 문제의 핵심은 Sub Query 시에 다중행 서브쿼리르 묻고 있는 것이다. 보기 ④번은 서브쿼리로 여러 개의 행이 되돌아 오기 때문에 ALL, ANY, IN 함수를 사용해야 한다.'),
(130, 2, 'DML', '다음의 주어진 ERD에서 실행했을 때 오류가 발생하는 SQL문은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j480-1.png', '', 'INSERT INTO 주문 VALUES (\'O002\', \'C002\', \'YYY\');', 'UPDATE 주문 SET 고객ID = NULL WHERE 주문ID = \'O001\';', 'INSERT INTO 주문 VALUES (\'O001\', \'C001\', \'XXX\');', 'INSERT INTO 고객 VALUES (\'C001\', \'AAA\');', FALSE, '해설: ④번 지문은 문법 오류로 2개의 칼럼만 입력하려면 테이블명 뒤에 칼럼명을 포함시켜야 한다.'),
(131, 2, '단일행 함수', '아래 함수 결과로 가장 적절하지 않은 것은?', '', '', 'RTRIM(\'ABCAA\', \'A\') : BC', 'TO_CHAR(1000,\'9,999\') : 1,000', 'SUBSTR(\'Sql Developer\', -5, 2) : lo', 'UPPER(\'Sql Developer\') : SQL DEVELOPER', FALSE, '해설: RTRIM(\'ABCAA\', \'A\') 는 오른쪽에서부터 A를 연속적으로 지우고 지울 대상이 아닌 문자를 만나면 더 이상 글자를 지우지 않는다.'),
(132, 2, '계층형 질의', '다음 중 아래의 TEST10 테이블에 대해서 SQL문을 수행하였을 때의 결과 건수는?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j533-1.png', 'SELECT LPAD(\'**\', (LEVEL-1)*2, \' \')|| EMPNO AS EMP, NAME FROM TEST10 WHERE EMPNO <> 3 START WITH EMPNO = 3 CONNECT BY EMPNO = PRIOR MANAGER;', '3', '2', '1', '0', FALSE, '해설: 위의 SQL에서 WHERE 조건에 의하여 EMPNO 3번은 조회에서 제외된다. 그리고 EMPNO가 3번으로 시작하여 계층형 조회를 한다. 따라서 EMPNO 1번과 2번 2개의 행이 조회된다.'),
(133, 2, '집계 함수', 'SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?', '', '', 'SELECT DEPTNO, ROUND(AVG(SAL)) AS ROUND_VALUE', 'FROM EMP E', 'WHERE ROUND_VALUE >= 3000', 'GROUP BY DEPTNO;', FALSE, '해설: WHERE 절은 SELECT 절보다 먼저 수행되므로 SELECT 절에서 정의한 컬럼 별칭을 사용할 수 없다.'),
(134, 2, '집합 연산자', 'SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?', '', '', 'EXCEPT', 'MINUS', 'INTERSECT', 'UNION', FALSE, '해설: SET OPERATOR :합집합은 UNION, 교집합은 INTERSECT, 차집합은 MINUS/EXCEPT 이다.'),
(135, 2, '집계 함수', '다음 보기의 SQL문을 실행했을 때의 결괏값은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j307-1.png', 'SELECT SUM(SCORE) / COUNT(NO) FROM Mytest', '400', '300', '200', '100', FALSE, '해설: COUNT(칼럼명)으로 조회를 하는 경우는 NULL 값이 제외된다. 따라서 3이 된다. 즉, 합계 1200/3=400이다.'),
(136, 2, 'DML', 'DML에 대한 설명으로 가장 적절한 것은?', '', '', 'UPDATE 사용 시 동시에 여러 컬럼 수정은 불가능하다.', 'DML은 반드시 COMMIT 또는 ROLLBACK을 입력하여 TRANSACTION을 종료해야 한다.', '원하는 데이터 DELETE 시 WHERE 절은 반드시 붙이지 않아도 된다.', 'DELETE 사용 시 FROM 문구는 생략이 불가능하다.', FALSE, '해설: UPDATE로 동시 여러 컬럼 수정 가능하다. DELETE 시 FROM은 생략이 가능하다. DML 시 COMMIT 또는 ROLLBACK으로 트랜잭션을 종료하지 않으면 변경된 행의 잠금이 발생하여 다른 사용자의 사용에 제한이 생긴다.'),
(137, 2, '집합 연산자', 'SQL문의 집합 연산자에 대한 설명이다. 다음 중 INTERSECT로 올바른 것은?', '', '', '양쪽 모두 포함된 행을 검색한다.', '차집합을 검색한다.', '중복을 제거한 결과의 합을 검색한다.', '중복을 포함한 결과의 합을 검색한다.', FALSE, '해설: ①번 보기는 INTERSECT 연산자로 중복된 행을 하나의 행으로 표시하고 ②번 보기는 MINUS ③번 보기는 UNION 연산자 ④번 보기는 UNION ALL 이다.'),
(138, 2, '집합 연산자', '다음 중 아래의 EMP 테이블의 데이터를 참조하여 실행한 SQL의 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j103-1.png', '', '', '', '', '', FALSE, '해설: UNION ALL을 사용하는 경우 칼럼 ALIAS는 첫번째 SQL 모듈 기준으로 표시되며, 정렬 기준은 마지막 SQL 모듈에 표시하면 됨.'),
(139, 2, '집계 함수', '다음의 SQL문 실행 결과로 올바른 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j431-1.png', 'SELECT COUNT(DATA1), COUNT(DATA2) FROM (SELECT DISTINCT DATA1, DATA2 FROM Mytest);', '1,1', '2,2', '2,1', '1,3', FALSE, '해설: 인라인 뷰에 있는 DISTINCT구는 중복을 제거하기 때문에 1,A 와 1,B 두개의 행이 조회된다. 따라서 행 수를 계산하는 COUNT는 2,2가 조회된다.'),
(140, 2, 'JOIN', '아래 SQL 수행 결과로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j696-1.png', 'SELECT COUNT(TAB1.COL1) AS CNT FROM TAB1 LEFT OUTER JOIN TAB2 ON TAB1.COL2 = TAB2.COL2 AND TAB1.COL1 = TAB2.COL1;', '6', '5', '4', '3', FALSE, '해설: None'),
(141, 2, 'JOIN', '다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은?', '', '', 'RIGHT OUTER JOIN, LEFT OUTER JOIN에서 OUTER는 생략 가능하다.', 'RIGHT OUTER JOIN 결과와 LEFT OUTER JOIN 결과는 항상 다르다.', 'INNER JOIN 사용 시, USING 조건절이나 ON 조건절을 반드시 사용해야 한다.', 'INNER JOIN은 WHERE 절에서 사용하던 JOIN 조건을 FROM 절에서 정의하겠다는 표시이다.', FALSE, '해설: 두 테이블 조인 시, 조인 조건에 의해 생략되는 쪽이 둘 다 없을 경우 LEFT OUTER JOIN / RIGHT OUTER JOIN 결과는 같다.'),
(142, 2, '집계 함수', '다음 중 오류가 발생하는 SQL 문장인 것은?', '', '', 'SELECT 메뉴ID, 사용유형코드, AVG(COUNT(*)) AS AVGCNT FROM 시스템사용이력 GROUP BY 메뉴ID, 사용유형코드;', 'SELECT 메뉴ID, 사용유형코드, COUNT(*) AS CNT FROM 시스템사용이력 WHERE 사용일시 BETWEEN SYSDATE - 1 AND SYSDATE GROUP BY 메뉴ID, 사용유형코드 HAVING 메뉴ID = 3 AND 사용유형코드 = 100;', 'SELECT SUM(주문금액) AS 합계 FROM 주문 HAVING AVG(주문금액) > 100;', 'SELECT 회원ID, SUM(주문금액) AS 합계 FROM 주문 GROUP BY 회원ID HAVING COUNT(*) > 1;', FALSE, '해설: None'),
(143, 2, '집합 연산자', '아래와 같은 데이터 모델에 대해 SQL을 수행 하였다. 다음 중 수행된 SQL과 동일한 결과를 도출하는 SQL은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j101-1.png', '', 'SELECT A.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A WHERE 서비스ID IN (SELECT 서비스ID FROM 서비스이용 MINUS SELECT 서비스ID FROM 서비스);', 'SELECT B.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A LEFT OUTER JOIN 서비스이용 B ON (A.서비스ID = B.서비스ID) WHERE B.서비스ID IS NULL GROUP BY B.서비스ID, A.서비스명, A.서비스URL;', 'SELECT X.서비스ID, X.서비스명, X.서비스URL FROM 서비스 X WHERE NOT EXISTS (SELECT 1 FROM (SELECT 서비스ID FROM 서비스 MINUS SELECT 서비스ID FROM 서비스이용) Y WHERE X.서비스ID = Y.서비스ID);', 'SELECT B.서비스ID, A.서비스명, A.서비스URL FROM 서비스 A, 서비스이용 B WHERE A.서비스ID = B.서비스ID;', FALSE, '해설: 수행한 SQL은 이용된 적이 있었던 서비스를 추출하는 SQL이다. ① 서비스와 서비스이용 테이블의 순서를 변경하고 IN 절을 NOT IN으로 변경하면 동일한 결과를 출력할 수 있다. ② 서비스를 기준으로 OUTER JOIN을 수행하였으므로, 이용된 적이 없었던 서비스만 출력된다. B.서비스ID IS NOT NULL로 변경해야 동일한 결과가 출력된다. ③ 전체 서비스에서 이용된 적이 있었던 서비스를 MINUS하였으므로 이용된 적이 없었던 서비스가 서브쿼리에서 추출된다. 그러므로 NOT EXISTS 구문을 적용하면 이용된 적이 있었던 서비스가 출력된다. ④ 이용된 적이 있었던 서비스를 추출하는 것은 동일하나 서비스와 서비스이용은 1:n 관계이므로 서비스 이용건수 만큼 추출되므로 전체 결과가 다르다. GROUP BY를 수행하면 동일한 결과를 출력할 수 있다.'),
(144, 2, 'DML', '다음 중 SQL문의 실행 순서로 올바른 것은?', '', '', 'FROM-WHERE-GROUP BY-HAVING-SELECT-ORDER BY', 'FROM-WHERE-GROUP BY-SELECT-HAVING-ORDER BY', 'FROM-WHERE-HAVING-GROUP BY-ORDER BY-SELECT', 'FROM-WHERE-GROUP BY-HAVING-ORDER BY-SELECT', FALSE, '해설: FROM구는 테이블을 선택하고 WHERE 조건을 만족하도록 필터링한다. 그 다음 GROUP BY와 HAVING구가 실행되고 SELECT구로 데이터를 인출 한 후에 ORDER BY로 정렬한다.'),
(145, 2, '트랜잭션 관리', '주어진 SQL문을 수행한 결과로 올바른 것은?', '', 'INSERT INTO test24 VALUES (1); INSERT INTO test24 VALUES (2); COMMIT; INSERT INTO test24 VALUES (3); SAVEPOINT SP; INSERT INTO test24 VALUES (4); ROLLBACK to SP; SELECT COUNT(*) FROM test24;', '6', '5', '3', '2', FALSE, '해설: None'),
(146, 2, '계층형 질의', '다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. ( )에 올바른 것은?', '', 'SELECT LEVEL, LPAD(\' \',4 + (LEVEL -1) )|| EMPNO, MGR, ( ) AS ISLEAF FROM Mytest START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;', 'CONNECT_BY_LEAF', 'SYS_CONNECT_BY_PATH', 'CONNECT_BY_ISCYCLE', 'CONNECT_BY_ISLEAF', FALSE, '해설: -CONNECT_BY_ISLEAF : 전개 과정에서 해당 데이터가 리프 데이터면 1, 아니면 0을 반환한다. -CONNECT_BY_ISCYCLE : 전개 과정에서 자식을 갖는데, 해당 데이터가 조상으로 존재하면1, 그렇지 않으면 0을 반환한다. 여기서 조상이란 자신으로부터 루트까지의 경로에 존재하는 데이터를 말한다. -SYS_CONNECT_BY_PATH : 하위 레벨의 칼럼까지 모두 표시해준다.'),
(147, 2, 'DDL', '다음 중 DDL 문이 아닌 것은?', '', '', 'ALTER', 'COMMIT', 'RENAME', 'CREATE TABLE', FALSE, '해설: COMMIT 과 ROLLBACK문은 TCL이고 DDL에는 CREATE, ALTER, DROP, RENAME 등이 있다.'),
(148, 2, 'JOIN', '다음 출력 결과를 얻기 위한 SQL 문장으로 가장 적절한 것은?', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j794-1.png', '', 'SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.EMPNO = E2.MGR(+) ORDER BY E1.EMPNO;', 'SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.EMPNO = E2.MGR ORDER BY E1.EMPNO;', 'SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO(+) ORDER BY E1.EMPNO;', 'SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;', FALSE, '해설: SELECT절을 보면 E2.ENAME이 매니저이름이다. 따라서 E1의 MGR(매니저번호)을 갖는 E2에서의 EMPNO가 E1 사 원의 매니저라고 볼 수 있다. 또한, 매니저가 없는 MARTIN도 출력을 하기 위해서는 LEFT OUTER JOIN이 필요하므 로 오라클 표준으로 E1의 반대쪽 컬럼에 (+) 기호를 붙여주면 된다.'),
(149, 2, '윈도우 함수', '아래와 같은 결과가 나오도록 (ㄱ)에 알맞은 SQL문을 완성하시오.', 'https://sqld-bk.s3.ap-southeast-2.amazonaws.com/j460-1.png', 'SELECT 회원ID, DENSE_RANK() OVER(ORDER BY (ㄱ) ) AS RANK, 주문금액 FROM SQLD7;', '주문금액 1', '주문금액 ASC', '(주문금액)', '(주문금액) DESC', FALSE, '해설: 결과 테이블은 주문금액이 큰 순서대로 순위를 부여하는 테이블로 주문금액 속성을 내림차순 정렬했을 때의 순위이고 같은 등수 다음에는 바로 다음 등수가 부여되었으므로 DENSE 랭크 함수가 들어가야 한다.');

insert into quiz_answer (quiz_id, answer) values
(1, 3),
(2, 1),
(3, 3),
(4, 3),
(5, 1),
(6, 4),
(7, 1),
(8, 2),
(9, 1),
(10, 2),
(10, 3),
(11, 4),
(12, 3),
(13, 2),
(14, 1),
(15, 2),
(16, 1),
(17, 4),
(18, 2),
(19, 2),
(20, 3),
(21, 4),
(22, 1),
(23, 3),
(24, 3),
(25, 3),
(26, 2),
(27, 2),
(28, 2),
(29, 1),
(30, 4),
(31, 3),
(32, 2),
(33, 2),
(34, 4),
(35, 3),
(36, 2),
(37, 3),
(38, 1),
(39, 2),
(40, 2),
(41, 3),
(42, 3),
(43, 3),
(44, 1),
(45, 2),
(46, 2),
(47, 4),
(48, 4),
(49, 3),
(50, 1),
(51, 3),
(52, 4),
(53, 3),
(54, 2),
(55, 2),
(55, 3),
(56, 4),
(57, 2),
(58, 1),
(59, 1),
(60, 3),
(61, 4),
(62, 2),
(63, 1),
(64, 3),
(65, 2),
(66, 1),
(67, 4),
(68, 3),
(69, 1),
(70, 3),
(71, 2),
(72, 3),
(73, 4),
(74, 1),
(75, 3),
(76, 4),
(77, 3),
(78, 2),
(79, 1),
(80, 2),
(81, 2),
(82, 2),
(83, 1),
(84, 2),
(85, 2),
(86, 2),
(87, 1),
(88, 4),
(89, 4),
(90, 1),
(91, 2),
(92, 4),
(93, 3),
(94, 3),
(95, 1),
(96, 1),
(97, 4),
(98, 1),
(99, 3),
(100, 3),
(101, 2),
(102, 2),
(103, 1),
(104, 2),
(105, 2),
(105, 3),
(106, 1),
(107, 3),
(108, 1),
(109, 1),
(110, 3),
(111, 3),
(112, 1),
(113, 2),
(114, 4),
(115, 4),
(116, 3),
(117, 2),
(118, 2),
(119, 2),
(120, 4),
(121, 4),
(122, 1),
(123, 2),
(124, 2),
(125, 4),
(126, 2),
(127, 2),
(128, 3),
(129, 4),
(130, 4),
(131, 1),
(132, 2),
(133, 3),
(134, 3),
(135, 1),
(136, 2),
(137, 1),
(138, 3),
(139, 2),
(140, 2),
(141, 2),
(142, 1),
(143, 3),
(144, 1),
(145, 3),
(146, 2),
(147, 2),
(148, 3),
(149, 4);
